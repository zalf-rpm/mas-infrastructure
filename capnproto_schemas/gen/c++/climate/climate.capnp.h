// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: climate.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1000002
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "common.capnp.h"
#include "date.capnp.h"
#include "geo.capnp.h"
#include "persistence.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(ce396869eede9f10);
enum class GCM_ce396869eede9f10: uint16_t {
  CCCMA_CAN_ESM2,
  ICHEC_EC_EARTH,
  IPSL_IPSL_CM5_A_MR,
  MIROC_MIROC5,
  MPI_M_MPI_ESM_LR,
  GFDL_ESM4,
  IPSL_CM6A_LR,
  MPI_ESM12_HR,
  MRI_ESM20,
  UKESM10_LL,
  GSWP3_W5_E5,
  MOHC_HAD_GEM2_ES,
};
CAPNP_DECLARE_ENUM(GCM, ce396869eede9f10);
CAPNP_DECLARE_SCHEMA(8671dec53083e351);
enum class RCM_8671dec53083e351: uint16_t {
  CLMCOM_CCLM4817,
  GERICS_REMO2015,
  KNMI_RACMO22_E,
  SMHI_RCA4,
  CLMCOM_BTU_CCLM4817,
  MPI_CSC_REMO2009,
  UHOH_WRF361_H,
};
CAPNP_DECLARE_ENUM(RCM, 8671dec53083e351);
CAPNP_DECLARE_SCHEMA(d3780ae416347aee);
enum class SSP_d3780ae416347aee: uint16_t {
  SSP1,
  SSP2,
  SSP3,
  SSP4,
  SSP5,
};
CAPNP_DECLARE_ENUM(SSP, d3780ae416347aee);
CAPNP_DECLARE_SCHEMA(8ef30778310c94cc);
enum class RCP_8ef30778310c94cc: uint16_t {
  RCP19,
  RCP26,
  RCP34,
  RCP45,
  RCP60,
  RCP70,
  RCP85,
};
CAPNP_DECLARE_ENUM(RCP, 8ef30778310c94cc);
CAPNP_DECLARE_SCHEMA(c8caacd1cd5da434);
CAPNP_DECLARE_SCHEMA(fb36d2e966556db0);
CAPNP_DECLARE_SCHEMA(ab06444b30722e01);
CAPNP_DECLARE_SCHEMA(95887677293b5682);
CAPNP_DECLARE_SCHEMA(e49e838ea9c34b40);
CAPNP_DECLARE_SCHEMA(c6d2329c05f7e208);
CAPNP_DECLARE_SCHEMA(e0a71ff36670f715);
CAPNP_DECLARE_SCHEMA(c48e24c968a234db);
CAPNP_DECLARE_SCHEMA(85af7fea06d0820c);
CAPNP_DECLARE_SCHEMA(c781edeab8160cb7);
CAPNP_DECLARE_SCHEMA(df705ef1e0b7d506);
CAPNP_DECLARE_SCHEMA(e246d49c91fa330a);
CAPNP_DECLARE_SCHEMA(9f35030ba55fed78);
CAPNP_DECLARE_SCHEMA(f635fdd1f05960f0);
CAPNP_DECLARE_SCHEMA(d61ba043f14fe175);
CAPNP_DECLARE_SCHEMA(e64112993dc4d4e0);
CAPNP_DECLARE_SCHEMA(fa8540d5d8065df1);
CAPNP_DECLARE_SCHEMA(b4c346906ee84815);
CAPNP_DECLARE_SCHEMA(b0496f3d284f4a13);
CAPNP_DECLARE_SCHEMA(edee5faa03af6a1e);
CAPNP_DECLARE_SCHEMA(d9f867b0a2a15d7f);
CAPNP_DECLARE_SCHEMA(e30c466e5bc2735c);
CAPNP_DECLARE_SCHEMA(d2a02e856c28d4ba);
CAPNP_DECLARE_SCHEMA(aa8cfcdc401d5fdd);
CAPNP_DECLARE_SCHEMA(fca3f0f431b64506);
CAPNP_DECLARE_SCHEMA(9ebadb578b79fa06);
CAPNP_DECLARE_SCHEMA(d7a67fec5f22e5a0);
CAPNP_DECLARE_SCHEMA(e35760b4db5ab564);
enum class Element_e35760b4db5ab564: uint16_t {
  TMIN,
  TAVG,
  TMAX,
  PRECIP,
  GLOBRAD,
  WIND,
  SUNHOURS,
  CLOUDAMOUNT,
  RELHUMID,
  AIRPRESS,
  VAPORPRESS,
  CO2,
  O3,
  ET0,
  DEWPOINT_TEMP,
  SPECIFIC_HUMIDITY,
  SNOWFALL_FLUX,
  SURFACE_DOWNWELLING_LONGWAVE_RADIATION,
};
CAPNP_DECLARE_ENUM(Element, e35760b4db5ab564);
CAPNP_DECLARE_SCHEMA(85ba7385f313fe19);
CAPNP_DECLARE_SCHEMA(c5fd13a53ae6d46a);
CAPNP_DECLARE_SCHEMA(a7769f40fe6e6de8);
CAPNP_DECLARE_SCHEMA(b466cacf63ec03c2);
enum class Resolution_b466cacf63ec03c2: uint16_t {
  DAILY,
  HOURLY,
};
CAPNP_DECLARE_ENUM(Resolution, b466cacf63ec03c2);
CAPNP_DECLARE_SCHEMA(ea3f0519d272fdd1);
CAPNP_DECLARE_SCHEMA(cd0eadd9a1a66ed6);
CAPNP_DECLARE_SCHEMA(ff6bcf0c6b23c916);
CAPNP_DECLARE_SCHEMA(b9ec27f476022c1b);
CAPNP_DECLARE_SCHEMA(8fd77002ae8a97a1);
CAPNP_DECLARE_SCHEMA(8976146f144fa050);
CAPNP_DECLARE_SCHEMA(8e78986bc45d7dcd);
CAPNP_DECLARE_SCHEMA(9c3d3448d73eeae9);
CAPNP_DECLARE_SCHEMA(eff8f923b1853525);
CAPNP_DECLARE_SCHEMA(c2e0dec0a6ea94fb);
CAPNP_DECLARE_SCHEMA(f8aa5b6fe2496fee);
CAPNP_DECLARE_SCHEMA(f7dfe7147d09b732);
CAPNP_DECLARE_SCHEMA(8cc364dee8f693b8);
CAPNP_DECLARE_SCHEMA(c3238163cae880df);
CAPNP_DECLARE_SCHEMA(ce2cc4225c956634);
CAPNP_DECLARE_SCHEMA(cb329eb01b0fa313);
CAPNP_DECLARE_SCHEMA(f1c1ccf59bc6964f);
CAPNP_DECLARE_SCHEMA(fe7d08d4352b0c5f);
CAPNP_DECLARE_SCHEMA(804cca489405d451);
CAPNP_DECLARE_SCHEMA(916880859435c6e8);
CAPNP_DECLARE_SCHEMA(9d7d1f83dda3e6db);
CAPNP_DECLARE_SCHEMA(cd95f79174b0eab0);
CAPNP_DECLARE_SCHEMA(a418c26cc59929d9);
CAPNP_DECLARE_SCHEMA(eba81ca9f46690b8);
CAPNP_DECLARE_SCHEMA(cfaa8d2601750547);
CAPNP_DECLARE_SCHEMA(efefafebc8ae5534);
CAPNP_DECLARE_SCHEMA(e1f480ef979784b2);
CAPNP_DECLARE_SCHEMA(d085b9baf390bec5);
CAPNP_DECLARE_SCHEMA(b5dd785107c358ca);
enum class AlterType_b5dd785107c358ca: uint16_t {
  ADD,
  MUL,
};
CAPNP_DECLARE_ENUM(AlterType, b5dd785107c358ca);
CAPNP_DECLARE_SCHEMA(e31f26eed9fb36a9);
CAPNP_DECLARE_SCHEMA(fb2eddb58f90f7aa);
CAPNP_DECLARE_SCHEMA(cba0220cda41869e);
CAPNP_DECLARE_SCHEMA(dd5b75b5bc711766);
CAPNP_DECLARE_SCHEMA(d36b1e9c2929e6e4);
CAPNP_DECLARE_SCHEMA(c4a1ec6280be841c);
CAPNP_DECLARE_SCHEMA(db7bfcfe4d45ff53);
CAPNP_DECLARE_SCHEMA(f44980b23013003b);
CAPNP_DECLARE_SCHEMA(8f08162dbd7e5068);
CAPNP_DECLARE_SCHEMA(8b0a787e82cd94bb);
CAPNP_DECLARE_SCHEMA(c5f12df0a2a52744);
CAPNP_DECLARE_SCHEMA(95064806dc018bfe);
CAPNP_DECLARE_SCHEMA(b48982ac9bcd5d11);

}  // namespace schemas
}  // namespace capnp

namespace mas {
namespace schema {
namespace climate {

typedef ::capnp::schemas::GCM_ce396869eede9f10 GCM;

typedef ::capnp::schemas::RCM_8671dec53083e351 RCM;

typedef ::capnp::schemas::SSP_d3780ae416347aee SSP;

typedef ::capnp::schemas::RCP_8ef30778310c94cc RCP;

struct EnsembleMember {
  EnsembleMember() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c8caacd1cd5da434, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Metadata {
  Metadata() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Supported;
  struct Value;
  struct Entry;
  struct Information;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fb36d2e966556db0, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Metadata::Supported {
  Supported() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct CategoriesParams;
  struct CategoriesResults;
  struct SupportedValuesParams;
  struct SupportedValuesResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(ab06444b30722e01)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Metadata::Supported::CategoriesParams {
  CategoriesParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(95887677293b5682, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Metadata::Supported::CategoriesResults {
  CategoriesResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e49e838ea9c34b40, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Metadata::Supported::SupportedValuesParams {
  SupportedValuesParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c6d2329c05f7e208, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Metadata::Supported::SupportedValuesResults {
  SupportedValuesResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e0a71ff36670f715, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Metadata::Value {
  Value() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    TEXT,
    FLOAT,
    INT,
    BOOL,
    DATE,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c48e24c968a234db, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Metadata::Entry {
  Entry() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    GCM,
    RCM,
    HISTORICAL,
    RCP,
    SSP,
    ENS_MEM,
    VERSION,
    START,
    END,
    CO2,
    PICONTROL,
    DESCRIPTION,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(85af7fea06d0820c, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Metadata::Information {
  Information() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct ForOneParams;
  struct ForAllParams;
  struct ForAllResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(c781edeab8160cb7)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Metadata::Information::ForOneParams {
  ForOneParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(df705ef1e0b7d506, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Metadata::Information::ForAllParams {
  ForAllParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e246d49c91fa330a, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Metadata::Information::ForAllResults {
  ForAllResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9f35030ba55fed78, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Dataset {
  Dataset() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct GetLocationsCallback;
  struct MetadataParams;
  struct ClosestTimeSeriesAtParams;
  struct ClosestTimeSeriesAtResults;
  struct TimeSeriesAtParams;
  struct TimeSeriesAtResults;
  struct LocationsParams;
  struct LocationsResults;
  struct StreamLocationsParams;
  struct StreamLocationsResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(f635fdd1f05960f0)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Dataset::GetLocationsCallback {
  GetLocationsCallback() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct NextLocationsParams;
  struct NextLocationsResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(d61ba043f14fe175)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Dataset::GetLocationsCallback::NextLocationsParams {
  NextLocationsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e64112993dc4d4e0, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Dataset::GetLocationsCallback::NextLocationsResults {
  NextLocationsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fa8540d5d8065df1, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Dataset::MetadataParams {
  MetadataParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b4c346906ee84815, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Dataset::ClosestTimeSeriesAtParams {
  ClosestTimeSeriesAtParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b0496f3d284f4a13, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Dataset::ClosestTimeSeriesAtResults {
  ClosestTimeSeriesAtResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(edee5faa03af6a1e, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Dataset::TimeSeriesAtParams {
  TimeSeriesAtParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d9f867b0a2a15d7f, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Dataset::TimeSeriesAtResults {
  TimeSeriesAtResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e30c466e5bc2735c, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Dataset::LocationsParams {
  LocationsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d2a02e856c28d4ba, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Dataset::LocationsResults {
  LocationsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(aa8cfcdc401d5fdd, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Dataset::StreamLocationsParams {
  StreamLocationsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fca3f0f431b64506, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Dataset::StreamLocationsResults {
  StreamLocationsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9ebadb578b79fa06, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct MetaPlusData {
  MetaPlusData() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d7a67fec5f22e5a0, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

typedef ::capnp::schemas::Element_e35760b4db5ab564 Element;

struct Location {
  Location() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct KV;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(85ba7385f313fe19, 1, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Location::KV {
  KV() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c5fd13a53ae6d46a, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TimeSeries {
  TimeSeries() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  typedef ::capnp::schemas::Resolution_b466cacf63ec03c2 Resolution;

  struct ResolutionParams;
  struct ResolutionResults;
  struct RangeParams;
  struct RangeResults;
  struct HeaderParams;
  struct HeaderResults;
  struct DataParams;
  struct DataResults;
  struct DataTParams;
  struct DataTResults;
  struct SubrangeParams;
  struct SubrangeResults;
  struct SubheaderParams;
  struct SubheaderResults;
  struct MetadataParams;
  struct LocationParams;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(a7769f40fe6e6de8)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct TimeSeries::ResolutionParams {
  ResolutionParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ea3f0519d272fdd1, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TimeSeries::ResolutionResults {
  ResolutionResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cd0eadd9a1a66ed6, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TimeSeries::RangeParams {
  RangeParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ff6bcf0c6b23c916, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TimeSeries::RangeResults {
  RangeResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b9ec27f476022c1b, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TimeSeries::HeaderParams {
  HeaderParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8fd77002ae8a97a1, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TimeSeries::HeaderResults {
  HeaderResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8976146f144fa050, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TimeSeries::DataParams {
  DataParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8e78986bc45d7dcd, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TimeSeries::DataResults {
  DataResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9c3d3448d73eeae9, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TimeSeries::DataTParams {
  DataTParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(eff8f923b1853525, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TimeSeries::DataTResults {
  DataTResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c2e0dec0a6ea94fb, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TimeSeries::SubrangeParams {
  SubrangeParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f8aa5b6fe2496fee, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TimeSeries::SubrangeResults {
  SubrangeResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f7dfe7147d09b732, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TimeSeries::SubheaderParams {
  SubheaderParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8cc364dee8f693b8, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TimeSeries::SubheaderResults {
  SubheaderResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c3238163cae880df, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TimeSeries::MetadataParams {
  MetadataParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ce2cc4225c956634, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TimeSeries::LocationParams {
  LocationParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cb329eb01b0fa313, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TimeSeriesData {
  TimeSeriesData() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f1c1ccf59bc6964f, 1, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Service {
  Service() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct GetAvailableDatasetsParams;
  struct GetAvailableDatasetsResults;
  struct GetDatasetsForParams;
  struct GetDatasetsForResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(fe7d08d4352b0c5f)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Service::GetAvailableDatasetsParams {
  GetAvailableDatasetsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(804cca489405d451, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Service::GetAvailableDatasetsResults {
  GetAvailableDatasetsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(916880859435c6e8, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Service::GetDatasetsForParams {
  GetDatasetsForParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9d7d1f83dda3e6db, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Service::GetDatasetsForResults {
  GetDatasetsForResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cd95f79174b0eab0, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CSVTimeSeriesFactory {
  CSVTimeSeriesFactory() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct CSVConfig;
  struct CreateParams;
  struct CreateResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(a418c26cc59929d9)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct CSVTimeSeriesFactory::CSVConfig {
  CSVConfig() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(eba81ca9f46690b8, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CSVTimeSeriesFactory::CreateParams {
  CreateParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cfaa8d2601750547, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CSVTimeSeriesFactory::CreateResults {
  CreateResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(efefafebc8ae5534, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AlterTimeSeriesWrapper {
  AlterTimeSeriesWrapper() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct Altered;
  typedef ::capnp::schemas::AlterType_b5dd785107c358ca AlterType;

  struct WrappedTimeSeriesParams;
  struct WrappedTimeSeriesResults;
  struct AlteredElementsParams;
  struct AlteredElementsResults;
  struct AlterParams;
  struct AlterResults;
  struct RemoveParams;
  struct RemoveResults;
  struct ReplaceWrappedTimeSeriesParams;
  struct ReplaceWrappedTimeSeriesResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(e1f480ef979784b2)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct AlterTimeSeriesWrapper::Altered {
  Altered() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d085b9baf390bec5, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AlterTimeSeriesWrapper::WrappedTimeSeriesParams {
  WrappedTimeSeriesParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e31f26eed9fb36a9, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AlterTimeSeriesWrapper::WrappedTimeSeriesResults {
  WrappedTimeSeriesResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fb2eddb58f90f7aa, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AlterTimeSeriesWrapper::AlteredElementsParams {
  AlteredElementsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cba0220cda41869e, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AlterTimeSeriesWrapper::AlteredElementsResults {
  AlteredElementsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dd5b75b5bc711766, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AlterTimeSeriesWrapper::AlterParams {
  AlterParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d36b1e9c2929e6e4, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AlterTimeSeriesWrapper::AlterResults {
  AlterResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c4a1ec6280be841c, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AlterTimeSeriesWrapper::RemoveParams {
  RemoveParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(db7bfcfe4d45ff53, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AlterTimeSeriesWrapper::RemoveResults {
  RemoveResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f44980b23013003b, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AlterTimeSeriesWrapper::ReplaceWrappedTimeSeriesParams {
  ReplaceWrappedTimeSeriesParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8f08162dbd7e5068, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AlterTimeSeriesWrapper::ReplaceWrappedTimeSeriesResults {
  ReplaceWrappedTimeSeriesResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8b0a787e82cd94bb, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AlterTimeSeriesWrapperFactory {
  AlterTimeSeriesWrapperFactory() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct WrapParams;
  struct WrapResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(c5f12df0a2a52744)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct AlterTimeSeriesWrapperFactory::WrapParams {
  WrapParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(95064806dc018bfe, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AlterTimeSeriesWrapperFactory::WrapResults {
  WrapResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b48982ac9bcd5d11, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class EnsembleMember::Reader {
public:
  typedef EnsembleMember Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getR() const;

  inline  ::uint16_t getI() const;

  inline  ::uint16_t getP() const;

  inline  ::uint16_t getF() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class EnsembleMember::Builder {
public:
  typedef EnsembleMember Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getR();
  inline void setR( ::uint16_t value);

  inline  ::uint16_t getI();
  inline void setI( ::uint16_t value);

  inline  ::uint16_t getP();
  inline void setP( ::uint16_t value);

  inline  ::uint16_t getF();
  inline void setF( ::uint16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class EnsembleMember::Pipeline {
public:
  typedef EnsembleMember Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Metadata::Reader {
public:
  typedef Metadata Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasEntries() const;
  inline  ::capnp::List< ::mas::schema::climate::Metadata::Entry,  ::capnp::Kind::STRUCT>::Reader getEntries() const;

  inline bool hasInfo() const;
#if !CAPNP_LITE
  inline  ::mas::schema::climate::Metadata::Information::Client getInfo() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Metadata::Builder {
public:
  typedef Metadata Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasEntries();
  inline  ::capnp::List< ::mas::schema::climate::Metadata::Entry,  ::capnp::Kind::STRUCT>::Builder getEntries();
  inline void setEntries( ::capnp::List< ::mas::schema::climate::Metadata::Entry,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::climate::Metadata::Entry,  ::capnp::Kind::STRUCT>::Builder initEntries(unsigned int size);
  inline void adoptEntries(::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Metadata::Entry,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Metadata::Entry,  ::capnp::Kind::STRUCT>> disownEntries();

  inline bool hasInfo();
#if !CAPNP_LITE
  inline  ::mas::schema::climate::Metadata::Information::Client getInfo();
  inline void setInfo( ::mas::schema::climate::Metadata::Information::Client&& value);
  inline void setInfo( ::mas::schema::climate::Metadata::Information::Client& value);
  inline void adoptInfo(::capnp::Orphan< ::mas::schema::climate::Metadata::Information>&& value);
  inline ::capnp::Orphan< ::mas::schema::climate::Metadata::Information> disownInfo();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Metadata::Pipeline {
public:
  typedef Metadata Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::climate::Metadata::Information::Client getInfo();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Metadata::Supported::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Supported Calls;
  typedef Supported Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::climate::Metadata::Supported::CategoriesParams,  ::mas::schema::climate::Metadata::Supported::CategoriesResults> categoriesRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::climate::Metadata::Supported::SupportedValuesParams,  ::mas::schema::climate::Metadata::Supported::SupportedValuesResults> supportedValuesRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Metadata::Supported::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Supported Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::climate::Metadata::Supported::CategoriesParams CategoriesParams;
  typedef  ::mas::schema::climate::Metadata::Supported::CategoriesResults CategoriesResults;
  typedef ::capnp::CallContext<CategoriesParams, CategoriesResults> CategoriesContext;
  virtual ::kj::Promise<void> categories(CategoriesContext context);
  typedef  ::mas::schema::climate::Metadata::Supported::SupportedValuesParams SupportedValuesParams;
  typedef  ::mas::schema::climate::Metadata::Supported::SupportedValuesResults SupportedValuesResults;
  typedef ::capnp::CallContext<SupportedValuesParams, SupportedValuesResults> SupportedValuesContext;
  virtual ::kj::Promise<void> supportedValues(SupportedValuesContext context);

  inline  ::mas::schema::climate::Metadata::Supported::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::climate::Metadata::Supported>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Metadata::Supported::CategoriesParams::Reader {
public:
  typedef CategoriesParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Metadata::Supported::CategoriesParams::Builder {
public:
  typedef CategoriesParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Metadata::Supported::CategoriesParams::Pipeline {
public:
  typedef CategoriesParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Metadata::Supported::CategoriesResults::Reader {
public:
  typedef CategoriesResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTypes() const;
  inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Reader getTypes() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Metadata::Supported::CategoriesResults::Builder {
public:
  typedef CategoriesResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTypes();
  inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Builder getTypes();
  inline void setTypes( ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Builder initTypes(unsigned int size);
  inline void adoptTypes(::capnp::Orphan< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>> disownTypes();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Metadata::Supported::CategoriesResults::Pipeline {
public:
  typedef CategoriesResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Metadata::Supported::SupportedValuesParams::Reader {
public:
  typedef SupportedValuesParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTypeId() const;
  inline  ::capnp::Text::Reader getTypeId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Metadata::Supported::SupportedValuesParams::Builder {
public:
  typedef SupportedValuesParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTypeId();
  inline  ::capnp::Text::Builder getTypeId();
  inline void setTypeId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initTypeId(unsigned int size);
  inline void adoptTypeId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownTypeId();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Metadata::Supported::SupportedValuesParams::Pipeline {
public:
  typedef SupportedValuesParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Metadata::Supported::SupportedValuesResults::Reader {
public:
  typedef SupportedValuesResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasValues() const;
  inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Reader getValues() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Metadata::Supported::SupportedValuesResults::Builder {
public:
  typedef SupportedValuesResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasValues();
  inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Builder getValues();
  inline void setValues( ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Builder initValues(unsigned int size);
  inline void adoptValues(::capnp::Orphan< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>> disownValues();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Metadata::Supported::SupportedValuesResults::Pipeline {
public:
  typedef SupportedValuesResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Metadata::Value::Reader {
public:
  typedef Value Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isText() const;
  inline bool hasText() const;
  inline  ::capnp::Text::Reader getText() const;

  inline bool isFloat() const;
  inline double getFloat() const;

  inline bool isInt() const;
  inline  ::int64_t getInt() const;

  inline bool isBool() const;
  inline bool getBool() const;

  inline bool isDate() const;
  inline bool hasDate() const;
  inline  ::mas::schema::common::Date::Reader getDate() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Metadata::Value::Builder {
public:
  typedef Value Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isText();
  inline bool hasText();
  inline  ::capnp::Text::Builder getText();
  inline void setText( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initText(unsigned int size);
  inline void adoptText(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownText();

  inline bool isFloat();
  inline double getFloat();
  inline void setFloat(double value);

  inline bool isInt();
  inline  ::int64_t getInt();
  inline void setInt( ::int64_t value);

  inline bool isBool();
  inline bool getBool();
  inline void setBool(bool value);

  inline bool isDate();
  inline bool hasDate();
  inline  ::mas::schema::common::Date::Builder getDate();
  inline void setDate( ::mas::schema::common::Date::Reader value);
  inline  ::mas::schema::common::Date::Builder initDate();
  inline void adoptDate(::capnp::Orphan< ::mas::schema::common::Date>&& value);
  inline ::capnp::Orphan< ::mas::schema::common::Date> disownDate();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Metadata::Value::Pipeline {
public:
  typedef Value Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Metadata::Entry::Reader {
public:
  typedef Entry Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isGcm() const;
  inline  ::mas::schema::climate::GCM getGcm() const;

  inline bool isRcm() const;
  inline  ::mas::schema::climate::RCM getRcm() const;

  inline bool isHistorical() const;
  inline  ::capnp::Void getHistorical() const;

  inline bool isRcp() const;
  inline  ::mas::schema::climate::RCP getRcp() const;

  inline bool isSsp() const;
  inline  ::mas::schema::climate::SSP getSsp() const;

  inline bool isEnsMem() const;
  inline bool hasEnsMem() const;
  inline  ::mas::schema::climate::EnsembleMember::Reader getEnsMem() const;

  inline bool isVersion() const;
  inline bool hasVersion() const;
  inline  ::capnp::Text::Reader getVersion() const;

  inline bool isStart() const;
  inline bool hasStart() const;
  inline  ::mas::schema::common::Date::Reader getStart() const;

  inline bool isEnd() const;
  inline bool hasEnd() const;
  inline  ::mas::schema::common::Date::Reader getEnd() const;

  inline bool isCo2() const;
  inline float getCo2() const;

  inline bool isPicontrol() const;
  inline  ::capnp::Void getPicontrol() const;

  inline bool isDescription() const;
  inline bool hasDescription() const;
  inline  ::capnp::Text::Reader getDescription() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Metadata::Entry::Builder {
public:
  typedef Entry Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isGcm();
  inline  ::mas::schema::climate::GCM getGcm();
  inline void setGcm( ::mas::schema::climate::GCM value);

  inline bool isRcm();
  inline  ::mas::schema::climate::RCM getRcm();
  inline void setRcm( ::mas::schema::climate::RCM value);

  inline bool isHistorical();
  inline  ::capnp::Void getHistorical();
  inline void setHistorical( ::capnp::Void value = ::capnp::VOID);

  inline bool isRcp();
  inline  ::mas::schema::climate::RCP getRcp();
  inline void setRcp( ::mas::schema::climate::RCP value);

  inline bool isSsp();
  inline  ::mas::schema::climate::SSP getSsp();
  inline void setSsp( ::mas::schema::climate::SSP value);

  inline bool isEnsMem();
  inline bool hasEnsMem();
  inline  ::mas::schema::climate::EnsembleMember::Builder getEnsMem();
  inline void setEnsMem( ::mas::schema::climate::EnsembleMember::Reader value);
  inline  ::mas::schema::climate::EnsembleMember::Builder initEnsMem();
  inline void adoptEnsMem(::capnp::Orphan< ::mas::schema::climate::EnsembleMember>&& value);
  inline ::capnp::Orphan< ::mas::schema::climate::EnsembleMember> disownEnsMem();

  inline bool isVersion();
  inline bool hasVersion();
  inline  ::capnp::Text::Builder getVersion();
  inline void setVersion( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initVersion(unsigned int size);
  inline void adoptVersion(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownVersion();

  inline bool isStart();
  inline bool hasStart();
  inline  ::mas::schema::common::Date::Builder getStart();
  inline void setStart( ::mas::schema::common::Date::Reader value);
  inline  ::mas::schema::common::Date::Builder initStart();
  inline void adoptStart(::capnp::Orphan< ::mas::schema::common::Date>&& value);
  inline ::capnp::Orphan< ::mas::schema::common::Date> disownStart();

  inline bool isEnd();
  inline bool hasEnd();
  inline  ::mas::schema::common::Date::Builder getEnd();
  inline void setEnd( ::mas::schema::common::Date::Reader value);
  inline  ::mas::schema::common::Date::Builder initEnd();
  inline void adoptEnd(::capnp::Orphan< ::mas::schema::common::Date>&& value);
  inline ::capnp::Orphan< ::mas::schema::common::Date> disownEnd();

  inline bool isCo2();
  inline float getCo2();
  inline void setCo2(float value);

  inline bool isPicontrol();
  inline  ::capnp::Void getPicontrol();
  inline void setPicontrol( ::capnp::Void value = ::capnp::VOID);

  inline bool isDescription();
  inline bool hasDescription();
  inline  ::capnp::Text::Builder getDescription();
  inline void setDescription( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initDescription(unsigned int size);
  inline void adoptDescription(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownDescription();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Metadata::Entry::Pipeline {
public:
  typedef Entry Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Metadata::Information::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Information Calls;
  typedef Information Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::climate::Metadata::Information::ForOneParams,  ::mas::schema::common::IdInformation> forOneRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::climate::Metadata::Information::ForAllParams,  ::mas::schema::climate::Metadata::Information::ForAllResults> forAllRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Metadata::Information::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Information Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::climate::Metadata::Information::ForOneParams ForOneParams;
  typedef ::capnp::CallContext<ForOneParams,  ::mas::schema::common::IdInformation> ForOneContext;
  virtual ::kj::Promise<void> forOne(ForOneContext context);
  typedef  ::mas::schema::climate::Metadata::Information::ForAllParams ForAllParams;
  typedef  ::mas::schema::climate::Metadata::Information::ForAllResults ForAllResults;
  typedef ::capnp::CallContext<ForAllParams, ForAllResults> ForAllContext;
  virtual ::kj::Promise<void> forAll(ForAllContext context);

  inline  ::mas::schema::climate::Metadata::Information::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::climate::Metadata::Information>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Metadata::Information::ForOneParams::Reader {
public:
  typedef ForOneParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasEntry() const;
  inline  ::mas::schema::climate::Metadata::Entry::Reader getEntry() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Metadata::Information::ForOneParams::Builder {
public:
  typedef ForOneParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasEntry();
  inline  ::mas::schema::climate::Metadata::Entry::Builder getEntry();
  inline void setEntry( ::mas::schema::climate::Metadata::Entry::Reader value);
  inline  ::mas::schema::climate::Metadata::Entry::Builder initEntry();
  inline void adoptEntry(::capnp::Orphan< ::mas::schema::climate::Metadata::Entry>&& value);
  inline ::capnp::Orphan< ::mas::schema::climate::Metadata::Entry> disownEntry();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Metadata::Information::ForOneParams::Pipeline {
public:
  typedef ForOneParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::climate::Metadata::Entry::Pipeline getEntry();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Metadata::Information::ForAllParams::Reader {
public:
  typedef ForAllParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Metadata::Information::ForAllParams::Builder {
public:
  typedef ForAllParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Metadata::Information::ForAllParams::Pipeline {
public:
  typedef ForAllParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Metadata::Information::ForAllResults::Reader {
public:
  typedef ForAllResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasAll() const;
  inline  ::capnp::List< ::mas::schema::common::Pair< ::mas::schema::climate::Metadata::Entry,  ::mas::schema::common::IdInformation>,  ::capnp::Kind::STRUCT>::Reader getAll() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Metadata::Information::ForAllResults::Builder {
public:
  typedef ForAllResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasAll();
  inline  ::capnp::List< ::mas::schema::common::Pair< ::mas::schema::climate::Metadata::Entry,  ::mas::schema::common::IdInformation>,  ::capnp::Kind::STRUCT>::Builder getAll();
  inline void setAll( ::capnp::List< ::mas::schema::common::Pair< ::mas::schema::climate::Metadata::Entry,  ::mas::schema::common::IdInformation>,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::common::Pair< ::mas::schema::climate::Metadata::Entry,  ::mas::schema::common::IdInformation>,  ::capnp::Kind::STRUCT>::Builder initAll(unsigned int size);
  inline void adoptAll(::capnp::Orphan< ::capnp::List< ::mas::schema::common::Pair< ::mas::schema::climate::Metadata::Entry,  ::mas::schema::common::IdInformation>,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Pair< ::mas::schema::climate::Metadata::Entry,  ::mas::schema::common::IdInformation>,  ::capnp::Kind::STRUCT>> disownAll();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Metadata::Information::ForAllResults::Pipeline {
public:
  typedef ForAllResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Dataset::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client,
      public virtual  ::mas::schema::persistence::Persistent::Client {
public:
  typedef Dataset Calls;
  typedef Dataset Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::climate::Dataset::MetadataParams,  ::mas::schema::climate::Metadata> metadataRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::climate::Dataset::ClosestTimeSeriesAtParams,  ::mas::schema::climate::Dataset::ClosestTimeSeriesAtResults> closestTimeSeriesAtRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::climate::Dataset::TimeSeriesAtParams,  ::mas::schema::climate::Dataset::TimeSeriesAtResults> timeSeriesAtRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::climate::Dataset::LocationsParams,  ::mas::schema::climate::Dataset::LocationsResults> locationsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::climate::Dataset::StreamLocationsParams,  ::mas::schema::climate::Dataset::StreamLocationsResults> streamLocationsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Dataset::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server,
      public virtual  ::mas::schema::persistence::Persistent::Server {
public:
  typedef Dataset Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::climate::Dataset::MetadataParams MetadataParams;
  typedef ::capnp::CallContext<MetadataParams,  ::mas::schema::climate::Metadata> MetadataContext;
  virtual ::kj::Promise<void> metadata(MetadataContext context);
  typedef  ::mas::schema::climate::Dataset::ClosestTimeSeriesAtParams ClosestTimeSeriesAtParams;
  typedef  ::mas::schema::climate::Dataset::ClosestTimeSeriesAtResults ClosestTimeSeriesAtResults;
  typedef ::capnp::CallContext<ClosestTimeSeriesAtParams, ClosestTimeSeriesAtResults> ClosestTimeSeriesAtContext;
  virtual ::kj::Promise<void> closestTimeSeriesAt(ClosestTimeSeriesAtContext context);
  typedef  ::mas::schema::climate::Dataset::TimeSeriesAtParams TimeSeriesAtParams;
  typedef  ::mas::schema::climate::Dataset::TimeSeriesAtResults TimeSeriesAtResults;
  typedef ::capnp::CallContext<TimeSeriesAtParams, TimeSeriesAtResults> TimeSeriesAtContext;
  virtual ::kj::Promise<void> timeSeriesAt(TimeSeriesAtContext context);
  typedef  ::mas::schema::climate::Dataset::LocationsParams LocationsParams;
  typedef  ::mas::schema::climate::Dataset::LocationsResults LocationsResults;
  typedef ::capnp::CallContext<LocationsParams, LocationsResults> LocationsContext;
  virtual ::kj::Promise<void> locations(LocationsContext context);
  typedef  ::mas::schema::climate::Dataset::StreamLocationsParams StreamLocationsParams;
  typedef  ::mas::schema::climate::Dataset::StreamLocationsResults StreamLocationsResults;
  typedef ::capnp::CallContext<StreamLocationsParams, StreamLocationsResults> StreamLocationsContext;
  virtual ::kj::Promise<void> streamLocations(StreamLocationsContext context);

  inline  ::mas::schema::climate::Dataset::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::climate::Dataset>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Dataset::GetLocationsCallback::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef GetLocationsCallback Calls;
  typedef GetLocationsCallback Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::climate::Dataset::GetLocationsCallback::NextLocationsParams,  ::mas::schema::climate::Dataset::GetLocationsCallback::NextLocationsResults> nextLocationsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Dataset::GetLocationsCallback::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef GetLocationsCallback Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::climate::Dataset::GetLocationsCallback::NextLocationsParams NextLocationsParams;
  typedef  ::mas::schema::climate::Dataset::GetLocationsCallback::NextLocationsResults NextLocationsResults;
  typedef ::capnp::CallContext<NextLocationsParams, NextLocationsResults> NextLocationsContext;
  virtual ::kj::Promise<void> nextLocations(NextLocationsContext context);

  inline  ::mas::schema::climate::Dataset::GetLocationsCallback::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::climate::Dataset::GetLocationsCallback>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Dataset::GetLocationsCallback::NextLocationsParams::Reader {
public:
  typedef NextLocationsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int64_t getMaxCount() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Dataset::GetLocationsCallback::NextLocationsParams::Builder {
public:
  typedef NextLocationsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int64_t getMaxCount();
  inline void setMaxCount( ::int64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Dataset::GetLocationsCallback::NextLocationsParams::Pipeline {
public:
  typedef NextLocationsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Dataset::GetLocationsCallback::NextLocationsResults::Reader {
public:
  typedef NextLocationsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLocations() const;
  inline  ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>::Reader getLocations() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Dataset::GetLocationsCallback::NextLocationsResults::Builder {
public:
  typedef NextLocationsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLocations();
  inline  ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>::Builder getLocations();
  inline void setLocations( ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>::Builder initLocations(unsigned int size);
  inline void adoptLocations(::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>> disownLocations();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Dataset::GetLocationsCallback::NextLocationsResults::Pipeline {
public:
  typedef NextLocationsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Dataset::MetadataParams::Reader {
public:
  typedef MetadataParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Dataset::MetadataParams::Builder {
public:
  typedef MetadataParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Dataset::MetadataParams::Pipeline {
public:
  typedef MetadataParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Dataset::ClosestTimeSeriesAtParams::Reader {
public:
  typedef ClosestTimeSeriesAtParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLatlon() const;
  inline  ::mas::schema::geo::LatLonCoord::Reader getLatlon() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Dataset::ClosestTimeSeriesAtParams::Builder {
public:
  typedef ClosestTimeSeriesAtParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLatlon();
  inline  ::mas::schema::geo::LatLonCoord::Builder getLatlon();
  inline void setLatlon( ::mas::schema::geo::LatLonCoord::Reader value);
  inline  ::mas::schema::geo::LatLonCoord::Builder initLatlon();
  inline void adoptLatlon(::capnp::Orphan< ::mas::schema::geo::LatLonCoord>&& value);
  inline ::capnp::Orphan< ::mas::schema::geo::LatLonCoord> disownLatlon();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Dataset::ClosestTimeSeriesAtParams::Pipeline {
public:
  typedef ClosestTimeSeriesAtParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::geo::LatLonCoord::Pipeline getLatlon();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Dataset::ClosestTimeSeriesAtResults::Reader {
public:
  typedef ClosestTimeSeriesAtResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTimeSeries() const;
#if !CAPNP_LITE
  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Dataset::ClosestTimeSeriesAtResults::Builder {
public:
  typedef ClosestTimeSeriesAtResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTimeSeries();
#if !CAPNP_LITE
  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries();
  inline void setTimeSeries( ::mas::schema::climate::TimeSeries::Client&& value);
  inline void setTimeSeries( ::mas::schema::climate::TimeSeries::Client& value);
  inline void adoptTimeSeries(::capnp::Orphan< ::mas::schema::climate::TimeSeries>&& value);
  inline ::capnp::Orphan< ::mas::schema::climate::TimeSeries> disownTimeSeries();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Dataset::ClosestTimeSeriesAtResults::Pipeline {
public:
  typedef ClosestTimeSeriesAtResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Dataset::TimeSeriesAtParams::Reader {
public:
  typedef TimeSeriesAtParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLocationId() const;
  inline  ::capnp::Text::Reader getLocationId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Dataset::TimeSeriesAtParams::Builder {
public:
  typedef TimeSeriesAtParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLocationId();
  inline  ::capnp::Text::Builder getLocationId();
  inline void setLocationId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initLocationId(unsigned int size);
  inline void adoptLocationId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownLocationId();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Dataset::TimeSeriesAtParams::Pipeline {
public:
  typedef TimeSeriesAtParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Dataset::TimeSeriesAtResults::Reader {
public:
  typedef TimeSeriesAtResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTimeSeries() const;
#if !CAPNP_LITE
  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Dataset::TimeSeriesAtResults::Builder {
public:
  typedef TimeSeriesAtResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTimeSeries();
#if !CAPNP_LITE
  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries();
  inline void setTimeSeries( ::mas::schema::climate::TimeSeries::Client&& value);
  inline void setTimeSeries( ::mas::schema::climate::TimeSeries::Client& value);
  inline void adoptTimeSeries(::capnp::Orphan< ::mas::schema::climate::TimeSeries>&& value);
  inline ::capnp::Orphan< ::mas::schema::climate::TimeSeries> disownTimeSeries();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Dataset::TimeSeriesAtResults::Pipeline {
public:
  typedef TimeSeriesAtResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Dataset::LocationsParams::Reader {
public:
  typedef LocationsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Dataset::LocationsParams::Builder {
public:
  typedef LocationsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Dataset::LocationsParams::Pipeline {
public:
  typedef LocationsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Dataset::LocationsResults::Reader {
public:
  typedef LocationsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLocations() const;
  inline  ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>::Reader getLocations() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Dataset::LocationsResults::Builder {
public:
  typedef LocationsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLocations();
  inline  ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>::Builder getLocations();
  inline void setLocations( ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>::Builder initLocations(unsigned int size);
  inline void adoptLocations(::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>> disownLocations();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Dataset::LocationsResults::Pipeline {
public:
  typedef LocationsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Dataset::StreamLocationsParams::Reader {
public:
  typedef StreamLocationsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasStartAfterLocationId() const;
  inline  ::capnp::Text::Reader getStartAfterLocationId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Dataset::StreamLocationsParams::Builder {
public:
  typedef StreamLocationsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasStartAfterLocationId();
  inline  ::capnp::Text::Builder getStartAfterLocationId();
  inline void setStartAfterLocationId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initStartAfterLocationId(unsigned int size);
  inline void adoptStartAfterLocationId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownStartAfterLocationId();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Dataset::StreamLocationsParams::Pipeline {
public:
  typedef StreamLocationsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Dataset::StreamLocationsResults::Reader {
public:
  typedef StreamLocationsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLocationsCallback() const;
#if !CAPNP_LITE
  inline  ::mas::schema::climate::Dataset::GetLocationsCallback::Client getLocationsCallback() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Dataset::StreamLocationsResults::Builder {
public:
  typedef StreamLocationsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLocationsCallback();
#if !CAPNP_LITE
  inline  ::mas::schema::climate::Dataset::GetLocationsCallback::Client getLocationsCallback();
  inline void setLocationsCallback( ::mas::schema::climate::Dataset::GetLocationsCallback::Client&& value);
  inline void setLocationsCallback( ::mas::schema::climate::Dataset::GetLocationsCallback::Client& value);
  inline void adoptLocationsCallback(::capnp::Orphan< ::mas::schema::climate::Dataset::GetLocationsCallback>&& value);
  inline ::capnp::Orphan< ::mas::schema::climate::Dataset::GetLocationsCallback> disownLocationsCallback();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Dataset::StreamLocationsResults::Pipeline {
public:
  typedef StreamLocationsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::climate::Dataset::GetLocationsCallback::Client getLocationsCallback();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MetaPlusData::Reader {
public:
  typedef MetaPlusData Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasMeta() const;
  inline  ::mas::schema::climate::Metadata::Reader getMeta() const;

  inline bool hasData() const;
#if !CAPNP_LITE
  inline  ::mas::schema::climate::Dataset::Client getData() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MetaPlusData::Builder {
public:
  typedef MetaPlusData Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMeta();
  inline  ::mas::schema::climate::Metadata::Builder getMeta();
  inline void setMeta( ::mas::schema::climate::Metadata::Reader value);
  inline  ::mas::schema::climate::Metadata::Builder initMeta();
  inline void adoptMeta(::capnp::Orphan< ::mas::schema::climate::Metadata>&& value);
  inline ::capnp::Orphan< ::mas::schema::climate::Metadata> disownMeta();

  inline bool hasData();
#if !CAPNP_LITE
  inline  ::mas::schema::climate::Dataset::Client getData();
  inline void setData( ::mas::schema::climate::Dataset::Client&& value);
  inline void setData( ::mas::schema::climate::Dataset::Client& value);
  inline void adoptData(::capnp::Orphan< ::mas::schema::climate::Dataset>&& value);
  inline ::capnp::Orphan< ::mas::schema::climate::Dataset> disownData();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MetaPlusData::Pipeline {
public:
  typedef MetaPlusData Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::climate::Metadata::Pipeline getMeta();
  inline  ::mas::schema::climate::Dataset::Client getData();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Location::Reader {
public:
  typedef Location Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasId() const;
  inline  ::mas::schema::common::IdInformation::Reader getId() const;

  inline float getHeightNN() const;

  inline bool hasLatlon() const;
  inline  ::mas::schema::geo::LatLonCoord::Reader getLatlon() const;

  inline bool hasTimeSeries() const;
#if !CAPNP_LITE
  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries() const;
#endif  // !CAPNP_LITE

  inline bool hasCustomData() const;
  inline  ::capnp::List< ::mas::schema::climate::Location::KV,  ::capnp::Kind::STRUCT>::Reader getCustomData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Location::Builder {
public:
  typedef Location Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasId();
  inline  ::mas::schema::common::IdInformation::Builder getId();
  inline void setId( ::mas::schema::common::IdInformation::Reader value);
  inline  ::mas::schema::common::IdInformation::Builder initId();
  inline void adoptId(::capnp::Orphan< ::mas::schema::common::IdInformation>&& value);
  inline ::capnp::Orphan< ::mas::schema::common::IdInformation> disownId();

  inline float getHeightNN();
  inline void setHeightNN(float value);

  inline bool hasLatlon();
  inline  ::mas::schema::geo::LatLonCoord::Builder getLatlon();
  inline void setLatlon( ::mas::schema::geo::LatLonCoord::Reader value);
  inline  ::mas::schema::geo::LatLonCoord::Builder initLatlon();
  inline void adoptLatlon(::capnp::Orphan< ::mas::schema::geo::LatLonCoord>&& value);
  inline ::capnp::Orphan< ::mas::schema::geo::LatLonCoord> disownLatlon();

  inline bool hasTimeSeries();
#if !CAPNP_LITE
  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries();
  inline void setTimeSeries( ::mas::schema::climate::TimeSeries::Client&& value);
  inline void setTimeSeries( ::mas::schema::climate::TimeSeries::Client& value);
  inline void adoptTimeSeries(::capnp::Orphan< ::mas::schema::climate::TimeSeries>&& value);
  inline ::capnp::Orphan< ::mas::schema::climate::TimeSeries> disownTimeSeries();
#endif  // !CAPNP_LITE

  inline bool hasCustomData();
  inline  ::capnp::List< ::mas::schema::climate::Location::KV,  ::capnp::Kind::STRUCT>::Builder getCustomData();
  inline void setCustomData( ::capnp::List< ::mas::schema::climate::Location::KV,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::climate::Location::KV,  ::capnp::Kind::STRUCT>::Builder initCustomData(unsigned int size);
  inline void adoptCustomData(::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Location::KV,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Location::KV,  ::capnp::Kind::STRUCT>> disownCustomData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Location::Pipeline {
public:
  typedef Location Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::common::IdInformation::Pipeline getId();
  inline  ::mas::schema::geo::LatLonCoord::Pipeline getLatlon();
  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Location::KV::Reader {
public:
  typedef KV Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasKey() const;
  inline  ::capnp::Text::Reader getKey() const;

  inline bool hasValue() const;
  inline ::capnp::AnyPointer::Reader getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Location::KV::Builder {
public:
  typedef KV Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasKey();
  inline  ::capnp::Text::Builder getKey();
  inline void setKey( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initKey(unsigned int size);
  inline void adoptKey(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownKey();

  inline bool hasValue();
  inline ::capnp::AnyPointer::Builder getValue();
  inline ::capnp::AnyPointer::Builder initValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Location::KV::Pipeline {
public:
  typedef KV Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class TimeSeries::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client,
      public virtual  ::mas::schema::persistence::Persistent::Client {
public:
  typedef TimeSeries Calls;
  typedef TimeSeries Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::climate::TimeSeries::ResolutionParams,  ::mas::schema::climate::TimeSeries::ResolutionResults> resolutionRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::climate::TimeSeries::RangeParams,  ::mas::schema::climate::TimeSeries::RangeResults> rangeRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::climate::TimeSeries::HeaderParams,  ::mas::schema::climate::TimeSeries::HeaderResults> headerRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::climate::TimeSeries::DataParams,  ::mas::schema::climate::TimeSeries::DataResults> dataRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::climate::TimeSeries::DataTParams,  ::mas::schema::climate::TimeSeries::DataTResults> dataTRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::climate::TimeSeries::SubrangeParams,  ::mas::schema::climate::TimeSeries::SubrangeResults> subrangeRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::climate::TimeSeries::SubheaderParams,  ::mas::schema::climate::TimeSeries::SubheaderResults> subheaderRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::climate::TimeSeries::MetadataParams,  ::mas::schema::climate::Metadata> metadataRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::climate::TimeSeries::LocationParams,  ::mas::schema::climate::Location> locationRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class TimeSeries::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server,
      public virtual  ::mas::schema::persistence::Persistent::Server {
public:
  typedef TimeSeries Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::climate::TimeSeries::ResolutionParams ResolutionParams;
  typedef  ::mas::schema::climate::TimeSeries::ResolutionResults ResolutionResults;
  typedef ::capnp::CallContext<ResolutionParams, ResolutionResults> ResolutionContext;
  virtual ::kj::Promise<void> resolution(ResolutionContext context);
  typedef  ::mas::schema::climate::TimeSeries::RangeParams RangeParams;
  typedef  ::mas::schema::climate::TimeSeries::RangeResults RangeResults;
  typedef ::capnp::CallContext<RangeParams, RangeResults> RangeContext;
  virtual ::kj::Promise<void> range(RangeContext context);
  typedef  ::mas::schema::climate::TimeSeries::HeaderParams HeaderParams;
  typedef  ::mas::schema::climate::TimeSeries::HeaderResults HeaderResults;
  typedef ::capnp::CallContext<HeaderParams, HeaderResults> HeaderContext;
  virtual ::kj::Promise<void> header(HeaderContext context);
  typedef  ::mas::schema::climate::TimeSeries::DataParams DataParams;
  typedef  ::mas::schema::climate::TimeSeries::DataResults DataResults;
  typedef ::capnp::CallContext<DataParams, DataResults> DataContext;
  virtual ::kj::Promise<void> data(DataContext context);
  typedef  ::mas::schema::climate::TimeSeries::DataTParams DataTParams;
  typedef  ::mas::schema::climate::TimeSeries::DataTResults DataTResults;
  typedef ::capnp::CallContext<DataTParams, DataTResults> DataTContext;
  virtual ::kj::Promise<void> dataT(DataTContext context);
  typedef  ::mas::schema::climate::TimeSeries::SubrangeParams SubrangeParams;
  typedef  ::mas::schema::climate::TimeSeries::SubrangeResults SubrangeResults;
  typedef ::capnp::CallContext<SubrangeParams, SubrangeResults> SubrangeContext;
  virtual ::kj::Promise<void> subrange(SubrangeContext context);
  typedef  ::mas::schema::climate::TimeSeries::SubheaderParams SubheaderParams;
  typedef  ::mas::schema::climate::TimeSeries::SubheaderResults SubheaderResults;
  typedef ::capnp::CallContext<SubheaderParams, SubheaderResults> SubheaderContext;
  virtual ::kj::Promise<void> subheader(SubheaderContext context);
  typedef  ::mas::schema::climate::TimeSeries::MetadataParams MetadataParams;
  typedef ::capnp::CallContext<MetadataParams,  ::mas::schema::climate::Metadata> MetadataContext;
  virtual ::kj::Promise<void> metadata(MetadataContext context);
  typedef  ::mas::schema::climate::TimeSeries::LocationParams LocationParams;
  typedef ::capnp::CallContext<LocationParams,  ::mas::schema::climate::Location> LocationContext;
  virtual ::kj::Promise<void> location(LocationContext context);

  inline  ::mas::schema::climate::TimeSeries::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::climate::TimeSeries>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class TimeSeries::ResolutionParams::Reader {
public:
  typedef ResolutionParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimeSeries::ResolutionParams::Builder {
public:
  typedef ResolutionParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimeSeries::ResolutionParams::Pipeline {
public:
  typedef ResolutionParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TimeSeries::ResolutionResults::Reader {
public:
  typedef ResolutionResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::mas::schema::climate::TimeSeries::Resolution getResolution() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimeSeries::ResolutionResults::Builder {
public:
  typedef ResolutionResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::mas::schema::climate::TimeSeries::Resolution getResolution();
  inline void setResolution( ::mas::schema::climate::TimeSeries::Resolution value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimeSeries::ResolutionResults::Pipeline {
public:
  typedef ResolutionResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TimeSeries::RangeParams::Reader {
public:
  typedef RangeParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimeSeries::RangeParams::Builder {
public:
  typedef RangeParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimeSeries::RangeParams::Pipeline {
public:
  typedef RangeParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TimeSeries::RangeResults::Reader {
public:
  typedef RangeResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasStartDate() const;
  inline  ::mas::schema::common::Date::Reader getStartDate() const;

  inline bool hasEndDate() const;
  inline  ::mas::schema::common::Date::Reader getEndDate() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimeSeries::RangeResults::Builder {
public:
  typedef RangeResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasStartDate();
  inline  ::mas::schema::common::Date::Builder getStartDate();
  inline void setStartDate( ::mas::schema::common::Date::Reader value);
  inline  ::mas::schema::common::Date::Builder initStartDate();
  inline void adoptStartDate(::capnp::Orphan< ::mas::schema::common::Date>&& value);
  inline ::capnp::Orphan< ::mas::schema::common::Date> disownStartDate();

  inline bool hasEndDate();
  inline  ::mas::schema::common::Date::Builder getEndDate();
  inline void setEndDate( ::mas::schema::common::Date::Reader value);
  inline  ::mas::schema::common::Date::Builder initEndDate();
  inline void adoptEndDate(::capnp::Orphan< ::mas::schema::common::Date>&& value);
  inline ::capnp::Orphan< ::mas::schema::common::Date> disownEndDate();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimeSeries::RangeResults::Pipeline {
public:
  typedef RangeResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::common::Date::Pipeline getStartDate();
  inline  ::mas::schema::common::Date::Pipeline getEndDate();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TimeSeries::HeaderParams::Reader {
public:
  typedef HeaderParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimeSeries::HeaderParams::Builder {
public:
  typedef HeaderParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimeSeries::HeaderParams::Pipeline {
public:
  typedef HeaderParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TimeSeries::HeaderResults::Reader {
public:
  typedef HeaderResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>::Reader getHeader() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimeSeries::HeaderResults::Builder {
public:
  typedef HeaderResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>::Builder getHeader();
  inline void setHeader( ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>::Reader value);
  inline void setHeader(::kj::ArrayPtr<const  ::mas::schema::climate::Element> value);
  inline  ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>::Builder initHeader(unsigned int size);
  inline void adoptHeader(::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>> disownHeader();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimeSeries::HeaderResults::Pipeline {
public:
  typedef HeaderResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TimeSeries::DataParams::Reader {
public:
  typedef DataParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimeSeries::DataParams::Builder {
public:
  typedef DataParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimeSeries::DataParams::Pipeline {
public:
  typedef DataParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TimeSeries::DataResults::Reader {
public:
  typedef DataResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimeSeries::DataResults::Builder {
public:
  typedef DataResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>::Builder getData();
  inline void setData( ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>::Reader value);
  inline void setData(::kj::ArrayPtr<const  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader> value);
  inline  ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimeSeries::DataResults::Pipeline {
public:
  typedef DataResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TimeSeries::DataTParams::Reader {
public:
  typedef DataTParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimeSeries::DataTParams::Builder {
public:
  typedef DataTParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimeSeries::DataTParams::Pipeline {
public:
  typedef DataTParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TimeSeries::DataTResults::Reader {
public:
  typedef DataTResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimeSeries::DataTResults::Builder {
public:
  typedef DataTResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>::Builder getData();
  inline void setData( ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>::Reader value);
  inline void setData(::kj::ArrayPtr<const  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader> value);
  inline  ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimeSeries::DataTResults::Pipeline {
public:
  typedef DataTResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TimeSeries::SubrangeParams::Reader {
public:
  typedef SubrangeParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasStart() const;
  inline  ::mas::schema::common::Date::Reader getStart() const;

  inline bool hasEnd() const;
  inline  ::mas::schema::common::Date::Reader getEnd() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimeSeries::SubrangeParams::Builder {
public:
  typedef SubrangeParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasStart();
  inline  ::mas::schema::common::Date::Builder getStart();
  inline void setStart( ::mas::schema::common::Date::Reader value);
  inline  ::mas::schema::common::Date::Builder initStart();
  inline void adoptStart(::capnp::Orphan< ::mas::schema::common::Date>&& value);
  inline ::capnp::Orphan< ::mas::schema::common::Date> disownStart();

  inline bool hasEnd();
  inline  ::mas::schema::common::Date::Builder getEnd();
  inline void setEnd( ::mas::schema::common::Date::Reader value);
  inline  ::mas::schema::common::Date::Builder initEnd();
  inline void adoptEnd(::capnp::Orphan< ::mas::schema::common::Date>&& value);
  inline ::capnp::Orphan< ::mas::schema::common::Date> disownEnd();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimeSeries::SubrangeParams::Pipeline {
public:
  typedef SubrangeParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::common::Date::Pipeline getStart();
  inline  ::mas::schema::common::Date::Pipeline getEnd();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TimeSeries::SubrangeResults::Reader {
public:
  typedef SubrangeResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTimeSeries() const;
#if !CAPNP_LITE
  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimeSeries::SubrangeResults::Builder {
public:
  typedef SubrangeResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTimeSeries();
#if !CAPNP_LITE
  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries();
  inline void setTimeSeries( ::mas::schema::climate::TimeSeries::Client&& value);
  inline void setTimeSeries( ::mas::schema::climate::TimeSeries::Client& value);
  inline void adoptTimeSeries(::capnp::Orphan< ::mas::schema::climate::TimeSeries>&& value);
  inline ::capnp::Orphan< ::mas::schema::climate::TimeSeries> disownTimeSeries();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimeSeries::SubrangeResults::Pipeline {
public:
  typedef SubrangeResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TimeSeries::SubheaderParams::Reader {
public:
  typedef SubheaderParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasElements() const;
  inline  ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>::Reader getElements() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimeSeries::SubheaderParams::Builder {
public:
  typedef SubheaderParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasElements();
  inline  ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>::Builder getElements();
  inline void setElements( ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>::Reader value);
  inline void setElements(::kj::ArrayPtr<const  ::mas::schema::climate::Element> value);
  inline  ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>::Builder initElements(unsigned int size);
  inline void adoptElements(::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>> disownElements();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimeSeries::SubheaderParams::Pipeline {
public:
  typedef SubheaderParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TimeSeries::SubheaderResults::Reader {
public:
  typedef SubheaderResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTimeSeries() const;
#if !CAPNP_LITE
  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimeSeries::SubheaderResults::Builder {
public:
  typedef SubheaderResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTimeSeries();
#if !CAPNP_LITE
  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries();
  inline void setTimeSeries( ::mas::schema::climate::TimeSeries::Client&& value);
  inline void setTimeSeries( ::mas::schema::climate::TimeSeries::Client& value);
  inline void adoptTimeSeries(::capnp::Orphan< ::mas::schema::climate::TimeSeries>&& value);
  inline ::capnp::Orphan< ::mas::schema::climate::TimeSeries> disownTimeSeries();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimeSeries::SubheaderResults::Pipeline {
public:
  typedef SubheaderResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TimeSeries::MetadataParams::Reader {
public:
  typedef MetadataParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimeSeries::MetadataParams::Builder {
public:
  typedef MetadataParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimeSeries::MetadataParams::Pipeline {
public:
  typedef MetadataParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TimeSeries::LocationParams::Reader {
public:
  typedef LocationParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimeSeries::LocationParams::Builder {
public:
  typedef LocationParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimeSeries::LocationParams::Pipeline {
public:
  typedef LocationParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TimeSeriesData::Reader {
public:
  typedef TimeSeriesData Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>::Reader getData() const;

  inline bool getIsTransposed() const;

  inline bool hasHeader() const;
  inline  ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>::Reader getHeader() const;

  inline bool hasStartDate() const;
  inline  ::mas::schema::common::Date::Reader getStartDate() const;

  inline bool hasEndDate() const;
  inline  ::mas::schema::common::Date::Reader getEndDate() const;

  inline  ::mas::schema::climate::TimeSeries::Resolution getResolution() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TimeSeriesData::Builder {
public:
  typedef TimeSeriesData Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>::Builder getData();
  inline void setData( ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>::Reader value);
  inline void setData(::kj::ArrayPtr<const  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader> value);
  inline  ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>> disownData();

  inline bool getIsTransposed();
  inline void setIsTransposed(bool value);

  inline bool hasHeader();
  inline  ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>::Builder getHeader();
  inline void setHeader( ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>::Reader value);
  inline void setHeader(::kj::ArrayPtr<const  ::mas::schema::climate::Element> value);
  inline  ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>::Builder initHeader(unsigned int size);
  inline void adoptHeader(::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>> disownHeader();

  inline bool hasStartDate();
  inline  ::mas::schema::common::Date::Builder getStartDate();
  inline void setStartDate( ::mas::schema::common::Date::Reader value);
  inline  ::mas::schema::common::Date::Builder initStartDate();
  inline void adoptStartDate(::capnp::Orphan< ::mas::schema::common::Date>&& value);
  inline ::capnp::Orphan< ::mas::schema::common::Date> disownStartDate();

  inline bool hasEndDate();
  inline  ::mas::schema::common::Date::Builder getEndDate();
  inline void setEndDate( ::mas::schema::common::Date::Reader value);
  inline  ::mas::schema::common::Date::Builder initEndDate();
  inline void adoptEndDate(::capnp::Orphan< ::mas::schema::common::Date>&& value);
  inline ::capnp::Orphan< ::mas::schema::common::Date> disownEndDate();

  inline  ::mas::schema::climate::TimeSeries::Resolution getResolution();
  inline void setResolution( ::mas::schema::climate::TimeSeries::Resolution value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TimeSeriesData::Pipeline {
public:
  typedef TimeSeriesData Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::common::Date::Pipeline getStartDate();
  inline  ::mas::schema::common::Date::Pipeline getEndDate();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Service::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client,
      public virtual  ::mas::schema::persistence::Persistent::Client {
public:
  typedef Service Calls;
  typedef Service Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::climate::Service::GetAvailableDatasetsParams,  ::mas::schema::climate::Service::GetAvailableDatasetsResults> getAvailableDatasetsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::climate::Service::GetDatasetsForParams,  ::mas::schema::climate::Service::GetDatasetsForResults> getDatasetsForRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Service::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server,
      public virtual  ::mas::schema::persistence::Persistent::Server {
public:
  typedef Service Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::climate::Service::GetAvailableDatasetsParams GetAvailableDatasetsParams;
  typedef  ::mas::schema::climate::Service::GetAvailableDatasetsResults GetAvailableDatasetsResults;
  typedef ::capnp::CallContext<GetAvailableDatasetsParams, GetAvailableDatasetsResults> GetAvailableDatasetsContext;
  virtual ::kj::Promise<void> getAvailableDatasets(GetAvailableDatasetsContext context);
  typedef  ::mas::schema::climate::Service::GetDatasetsForParams GetDatasetsForParams;
  typedef  ::mas::schema::climate::Service::GetDatasetsForResults GetDatasetsForResults;
  typedef ::capnp::CallContext<GetDatasetsForParams, GetDatasetsForResults> GetDatasetsForContext;
  virtual ::kj::Promise<void> getDatasetsFor(GetDatasetsForContext context);

  inline  ::mas::schema::climate::Service::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::climate::Service>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Service::GetAvailableDatasetsParams::Reader {
public:
  typedef GetAvailableDatasetsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Service::GetAvailableDatasetsParams::Builder {
public:
  typedef GetAvailableDatasetsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Service::GetAvailableDatasetsParams::Pipeline {
public:
  typedef GetAvailableDatasetsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Service::GetAvailableDatasetsResults::Reader {
public:
  typedef GetAvailableDatasetsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasDatasets() const;
  inline  ::capnp::List< ::mas::schema::climate::MetaPlusData,  ::capnp::Kind::STRUCT>::Reader getDatasets() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Service::GetAvailableDatasetsResults::Builder {
public:
  typedef GetAvailableDatasetsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasDatasets();
  inline  ::capnp::List< ::mas::schema::climate::MetaPlusData,  ::capnp::Kind::STRUCT>::Builder getDatasets();
  inline void setDatasets( ::capnp::List< ::mas::schema::climate::MetaPlusData,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::climate::MetaPlusData,  ::capnp::Kind::STRUCT>::Builder initDatasets(unsigned int size);
  inline void adoptDatasets(::capnp::Orphan< ::capnp::List< ::mas::schema::climate::MetaPlusData,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::MetaPlusData,  ::capnp::Kind::STRUCT>> disownDatasets();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Service::GetAvailableDatasetsResults::Pipeline {
public:
  typedef GetAvailableDatasetsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Service::GetDatasetsForParams::Reader {
public:
  typedef GetDatasetsForParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTemplate() const;
  inline  ::mas::schema::climate::Metadata::Reader getTemplate() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Service::GetDatasetsForParams::Builder {
public:
  typedef GetDatasetsForParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTemplate();
  inline  ::mas::schema::climate::Metadata::Builder getTemplate();
  inline void setTemplate( ::mas::schema::climate::Metadata::Reader value);
  inline  ::mas::schema::climate::Metadata::Builder initTemplate();
  inline void adoptTemplate(::capnp::Orphan< ::mas::schema::climate::Metadata>&& value);
  inline ::capnp::Orphan< ::mas::schema::climate::Metadata> disownTemplate();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Service::GetDatasetsForParams::Pipeline {
public:
  typedef GetDatasetsForParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::climate::Metadata::Pipeline getTemplate();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Service::GetDatasetsForResults::Reader {
public:
  typedef GetDatasetsForResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasDatasets() const;
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::climate::Dataset,  ::capnp::Kind::INTERFACE>::Reader getDatasets() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Service::GetDatasetsForResults::Builder {
public:
  typedef GetDatasetsForResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasDatasets();
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::climate::Dataset,  ::capnp::Kind::INTERFACE>::Builder getDatasets();
  inline void setDatasets( ::capnp::List< ::mas::schema::climate::Dataset,  ::capnp::Kind::INTERFACE>::Reader value);
  inline  ::capnp::List< ::mas::schema::climate::Dataset,  ::capnp::Kind::INTERFACE>::Builder initDatasets(unsigned int size);
  inline void adoptDatasets(::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Dataset,  ::capnp::Kind::INTERFACE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Dataset,  ::capnp::Kind::INTERFACE>> disownDatasets();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Service::GetDatasetsForResults::Pipeline {
public:
  typedef GetDatasetsForResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class CSVTimeSeriesFactory::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client {
public:
  typedef CSVTimeSeriesFactory Calls;
  typedef CSVTimeSeriesFactory Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::climate::CSVTimeSeriesFactory::CreateParams,  ::mas::schema::climate::CSVTimeSeriesFactory::CreateResults> createRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class CSVTimeSeriesFactory::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server {
public:
  typedef CSVTimeSeriesFactory Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::climate::CSVTimeSeriesFactory::CreateParams CreateParams;
  typedef  ::mas::schema::climate::CSVTimeSeriesFactory::CreateResults CreateResults;
  typedef ::capnp::CallContext<CreateParams, CreateResults> CreateContext;
  virtual ::kj::Promise<void> create(CreateContext context);

  inline  ::mas::schema::climate::CSVTimeSeriesFactory::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::climate::CSVTimeSeriesFactory>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class CSVTimeSeriesFactory::CSVConfig::Reader {
public:
  typedef CSVConfig Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasSep() const;
  inline  ::capnp::Text::Reader getSep() const;

  inline bool hasHeaderMap() const;
  inline  ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>::Reader getHeaderMap() const;

  inline  ::int16_t getSkipLinesToHeader() const;

  inline  ::int16_t getSkipLinesFromHeaderToData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CSVTimeSeriesFactory::CSVConfig::Builder {
public:
  typedef CSVConfig Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasSep();
  inline  ::capnp::Text::Builder getSep();
  inline void setSep( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initSep(unsigned int size);
  inline void adoptSep(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownSep();

  inline bool hasHeaderMap();
  inline  ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>::Builder getHeaderMap();
  inline void setHeaderMap( ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>::Builder initHeaderMap(unsigned int size);
  inline void adoptHeaderMap(::capnp::Orphan< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>> disownHeaderMap();

  inline  ::int16_t getSkipLinesToHeader();
  inline void setSkipLinesToHeader( ::int16_t value);

  inline  ::int16_t getSkipLinesFromHeaderToData();
  inline void setSkipLinesFromHeaderToData( ::int16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CSVTimeSeriesFactory::CSVConfig::Pipeline {
public:
  typedef CSVConfig Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CSVTimeSeriesFactory::CreateParams::Reader {
public:
  typedef CreateParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCsvData() const;
  inline  ::capnp::Text::Reader getCsvData() const;

  inline bool hasConfig() const;
  inline  ::mas::schema::climate::CSVTimeSeriesFactory::CSVConfig::Reader getConfig() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CSVTimeSeriesFactory::CreateParams::Builder {
public:
  typedef CreateParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCsvData();
  inline  ::capnp::Text::Builder getCsvData();
  inline void setCsvData( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initCsvData(unsigned int size);
  inline void adoptCsvData(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownCsvData();

  inline bool hasConfig();
  inline  ::mas::schema::climate::CSVTimeSeriesFactory::CSVConfig::Builder getConfig();
  inline void setConfig( ::mas::schema::climate::CSVTimeSeriesFactory::CSVConfig::Reader value);
  inline  ::mas::schema::climate::CSVTimeSeriesFactory::CSVConfig::Builder initConfig();
  inline void adoptConfig(::capnp::Orphan< ::mas::schema::climate::CSVTimeSeriesFactory::CSVConfig>&& value);
  inline ::capnp::Orphan< ::mas::schema::climate::CSVTimeSeriesFactory::CSVConfig> disownConfig();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CSVTimeSeriesFactory::CreateParams::Pipeline {
public:
  typedef CreateParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::climate::CSVTimeSeriesFactory::CSVConfig::Pipeline getConfig();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CSVTimeSeriesFactory::CreateResults::Reader {
public:
  typedef CreateResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTimeseries() const;
#if !CAPNP_LITE
  inline  ::mas::schema::climate::TimeSeries::Client getTimeseries() const;
#endif  // !CAPNP_LITE

  inline bool hasError() const;
  inline  ::capnp::Text::Reader getError() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CSVTimeSeriesFactory::CreateResults::Builder {
public:
  typedef CreateResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTimeseries();
#if !CAPNP_LITE
  inline  ::mas::schema::climate::TimeSeries::Client getTimeseries();
  inline void setTimeseries( ::mas::schema::climate::TimeSeries::Client&& value);
  inline void setTimeseries( ::mas::schema::climate::TimeSeries::Client& value);
  inline void adoptTimeseries(::capnp::Orphan< ::mas::schema::climate::TimeSeries>&& value);
  inline ::capnp::Orphan< ::mas::schema::climate::TimeSeries> disownTimeseries();
#endif  // !CAPNP_LITE

  inline bool hasError();
  inline  ::capnp::Text::Builder getError();
  inline void setError( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initError(unsigned int size);
  inline void adoptError(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownError();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CSVTimeSeriesFactory::CreateResults::Pipeline {
public:
  typedef CreateResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::climate::TimeSeries::Client getTimeseries();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class AlterTimeSeriesWrapper::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::climate::TimeSeries::Client {
public:
  typedef AlterTimeSeriesWrapper Calls;
  typedef AlterTimeSeriesWrapper Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::climate::AlterTimeSeriesWrapper::WrappedTimeSeriesParams,  ::mas::schema::climate::AlterTimeSeriesWrapper::WrappedTimeSeriesResults> wrappedTimeSeriesRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::climate::AlterTimeSeriesWrapper::AlteredElementsParams,  ::mas::schema::climate::AlterTimeSeriesWrapper::AlteredElementsResults> alteredElementsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::climate::AlterTimeSeriesWrapper::AlterParams,  ::mas::schema::climate::AlterTimeSeriesWrapper::AlterResults> alterRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::climate::AlterTimeSeriesWrapper::RemoveParams,  ::mas::schema::climate::AlterTimeSeriesWrapper::RemoveResults> removeRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::climate::AlterTimeSeriesWrapper::ReplaceWrappedTimeSeriesParams,  ::mas::schema::climate::AlterTimeSeriesWrapper::ReplaceWrappedTimeSeriesResults> replaceWrappedTimeSeriesRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class AlterTimeSeriesWrapper::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::climate::TimeSeries::Server {
public:
  typedef AlterTimeSeriesWrapper Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::climate::AlterTimeSeriesWrapper::WrappedTimeSeriesParams WrappedTimeSeriesParams;
  typedef  ::mas::schema::climate::AlterTimeSeriesWrapper::WrappedTimeSeriesResults WrappedTimeSeriesResults;
  typedef ::capnp::CallContext<WrappedTimeSeriesParams, WrappedTimeSeriesResults> WrappedTimeSeriesContext;
  virtual ::kj::Promise<void> wrappedTimeSeries(WrappedTimeSeriesContext context);
  typedef  ::mas::schema::climate::AlterTimeSeriesWrapper::AlteredElementsParams AlteredElementsParams;
  typedef  ::mas::schema::climate::AlterTimeSeriesWrapper::AlteredElementsResults AlteredElementsResults;
  typedef ::capnp::CallContext<AlteredElementsParams, AlteredElementsResults> AlteredElementsContext;
  virtual ::kj::Promise<void> alteredElements(AlteredElementsContext context);
  typedef  ::mas::schema::climate::AlterTimeSeriesWrapper::AlterParams AlterParams;
  typedef  ::mas::schema::climate::AlterTimeSeriesWrapper::AlterResults AlterResults;
  typedef ::capnp::CallContext<AlterParams, AlterResults> AlterContext;
  virtual ::kj::Promise<void> alter(AlterContext context);
  typedef  ::mas::schema::climate::AlterTimeSeriesWrapper::RemoveParams RemoveParams;
  typedef  ::mas::schema::climate::AlterTimeSeriesWrapper::RemoveResults RemoveResults;
  typedef ::capnp::CallContext<RemoveParams, RemoveResults> RemoveContext;
  virtual ::kj::Promise<void> remove(RemoveContext context);
  typedef  ::mas::schema::climate::AlterTimeSeriesWrapper::ReplaceWrappedTimeSeriesParams ReplaceWrappedTimeSeriesParams;
  typedef  ::mas::schema::climate::AlterTimeSeriesWrapper::ReplaceWrappedTimeSeriesResults ReplaceWrappedTimeSeriesResults;
  typedef ::capnp::CallContext<ReplaceWrappedTimeSeriesParams, ReplaceWrappedTimeSeriesResults> ReplaceWrappedTimeSeriesContext;
  virtual ::kj::Promise<void> replaceWrappedTimeSeries(ReplaceWrappedTimeSeriesContext context);

  inline  ::mas::schema::climate::AlterTimeSeriesWrapper::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::climate::AlterTimeSeriesWrapper>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class AlterTimeSeriesWrapper::Altered::Reader {
public:
  typedef Altered Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::mas::schema::climate::Element getElement() const;

  inline float getValue() const;

  inline  ::mas::schema::climate::AlterTimeSeriesWrapper::AlterType getType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AlterTimeSeriesWrapper::Altered::Builder {
public:
  typedef Altered Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::mas::schema::climate::Element getElement();
  inline void setElement( ::mas::schema::climate::Element value);

  inline float getValue();
  inline void setValue(float value);

  inline  ::mas::schema::climate::AlterTimeSeriesWrapper::AlterType getType();
  inline void setType( ::mas::schema::climate::AlterTimeSeriesWrapper::AlterType value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AlterTimeSeriesWrapper::Altered::Pipeline {
public:
  typedef Altered Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AlterTimeSeriesWrapper::WrappedTimeSeriesParams::Reader {
public:
  typedef WrappedTimeSeriesParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AlterTimeSeriesWrapper::WrappedTimeSeriesParams::Builder {
public:
  typedef WrappedTimeSeriesParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AlterTimeSeriesWrapper::WrappedTimeSeriesParams::Pipeline {
public:
  typedef WrappedTimeSeriesParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AlterTimeSeriesWrapper::WrappedTimeSeriesResults::Reader {
public:
  typedef WrappedTimeSeriesResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTimeSeries() const;
#if !CAPNP_LITE
  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AlterTimeSeriesWrapper::WrappedTimeSeriesResults::Builder {
public:
  typedef WrappedTimeSeriesResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTimeSeries();
#if !CAPNP_LITE
  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries();
  inline void setTimeSeries( ::mas::schema::climate::TimeSeries::Client&& value);
  inline void setTimeSeries( ::mas::schema::climate::TimeSeries::Client& value);
  inline void adoptTimeSeries(::capnp::Orphan< ::mas::schema::climate::TimeSeries>&& value);
  inline ::capnp::Orphan< ::mas::schema::climate::TimeSeries> disownTimeSeries();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AlterTimeSeriesWrapper::WrappedTimeSeriesResults::Pipeline {
public:
  typedef WrappedTimeSeriesResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AlterTimeSeriesWrapper::AlteredElementsParams::Reader {
public:
  typedef AlteredElementsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AlterTimeSeriesWrapper::AlteredElementsParams::Builder {
public:
  typedef AlteredElementsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AlterTimeSeriesWrapper::AlteredElementsParams::Pipeline {
public:
  typedef AlteredElementsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AlterTimeSeriesWrapper::AlteredElementsResults::Reader {
public:
  typedef AlteredElementsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasList() const;
  inline  ::capnp::List< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered,  ::capnp::Kind::STRUCT>::Reader getList() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AlterTimeSeriesWrapper::AlteredElementsResults::Builder {
public:
  typedef AlteredElementsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasList();
  inline  ::capnp::List< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered,  ::capnp::Kind::STRUCT>::Builder getList();
  inline void setList( ::capnp::List< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered,  ::capnp::Kind::STRUCT>::Builder initList(unsigned int size);
  inline void adoptList(::capnp::Orphan< ::capnp::List< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered,  ::capnp::Kind::STRUCT>> disownList();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AlterTimeSeriesWrapper::AlteredElementsResults::Pipeline {
public:
  typedef AlteredElementsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AlterTimeSeriesWrapper::AlterParams::Reader {
public:
  typedef AlterParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasDesc() const;
  inline  ::mas::schema::climate::AlterTimeSeriesWrapper::Altered::Reader getDesc() const;

  inline bool getAsNewTimeSeries() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AlterTimeSeriesWrapper::AlterParams::Builder {
public:
  typedef AlterParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasDesc();
  inline  ::mas::schema::climate::AlterTimeSeriesWrapper::Altered::Builder getDesc();
  inline void setDesc( ::mas::schema::climate::AlterTimeSeriesWrapper::Altered::Reader value);
  inline  ::mas::schema::climate::AlterTimeSeriesWrapper::Altered::Builder initDesc();
  inline void adoptDesc(::capnp::Orphan< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered>&& value);
  inline ::capnp::Orphan< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered> disownDesc();

  inline bool getAsNewTimeSeries();
  inline void setAsNewTimeSeries(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AlterTimeSeriesWrapper::AlterParams::Pipeline {
public:
  typedef AlterParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::climate::AlterTimeSeriesWrapper::Altered::Pipeline getDesc();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AlterTimeSeriesWrapper::AlterResults::Reader {
public:
  typedef AlterResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTimeSeries() const;
#if !CAPNP_LITE
  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AlterTimeSeriesWrapper::AlterResults::Builder {
public:
  typedef AlterResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTimeSeries();
#if !CAPNP_LITE
  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries();
  inline void setTimeSeries( ::mas::schema::climate::TimeSeries::Client&& value);
  inline void setTimeSeries( ::mas::schema::climate::TimeSeries::Client& value);
  inline void adoptTimeSeries(::capnp::Orphan< ::mas::schema::climate::TimeSeries>&& value);
  inline ::capnp::Orphan< ::mas::schema::climate::TimeSeries> disownTimeSeries();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AlterTimeSeriesWrapper::AlterResults::Pipeline {
public:
  typedef AlterResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AlterTimeSeriesWrapper::RemoveParams::Reader {
public:
  typedef RemoveParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::mas::schema::climate::Element getAlteredElement() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AlterTimeSeriesWrapper::RemoveParams::Builder {
public:
  typedef RemoveParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::mas::schema::climate::Element getAlteredElement();
  inline void setAlteredElement( ::mas::schema::climate::Element value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AlterTimeSeriesWrapper::RemoveParams::Pipeline {
public:
  typedef RemoveParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AlterTimeSeriesWrapper::RemoveResults::Reader {
public:
  typedef RemoveResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AlterTimeSeriesWrapper::RemoveResults::Builder {
public:
  typedef RemoveResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AlterTimeSeriesWrapper::RemoveResults::Pipeline {
public:
  typedef RemoveResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AlterTimeSeriesWrapper::ReplaceWrappedTimeSeriesParams::Reader {
public:
  typedef ReplaceWrappedTimeSeriesParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTimeSeries() const;
#if !CAPNP_LITE
  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AlterTimeSeriesWrapper::ReplaceWrappedTimeSeriesParams::Builder {
public:
  typedef ReplaceWrappedTimeSeriesParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTimeSeries();
#if !CAPNP_LITE
  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries();
  inline void setTimeSeries( ::mas::schema::climate::TimeSeries::Client&& value);
  inline void setTimeSeries( ::mas::schema::climate::TimeSeries::Client& value);
  inline void adoptTimeSeries(::capnp::Orphan< ::mas::schema::climate::TimeSeries>&& value);
  inline ::capnp::Orphan< ::mas::schema::climate::TimeSeries> disownTimeSeries();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AlterTimeSeriesWrapper::ReplaceWrappedTimeSeriesParams::Pipeline {
public:
  typedef ReplaceWrappedTimeSeriesParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AlterTimeSeriesWrapper::ReplaceWrappedTimeSeriesResults::Reader {
public:
  typedef ReplaceWrappedTimeSeriesResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AlterTimeSeriesWrapper::ReplaceWrappedTimeSeriesResults::Builder {
public:
  typedef ReplaceWrappedTimeSeriesResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AlterTimeSeriesWrapper::ReplaceWrappedTimeSeriesResults::Pipeline {
public:
  typedef ReplaceWrappedTimeSeriesResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class AlterTimeSeriesWrapperFactory::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client {
public:
  typedef AlterTimeSeriesWrapperFactory Calls;
  typedef AlterTimeSeriesWrapperFactory Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::climate::AlterTimeSeriesWrapperFactory::WrapParams,  ::mas::schema::climate::AlterTimeSeriesWrapperFactory::WrapResults> wrapRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class AlterTimeSeriesWrapperFactory::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server {
public:
  typedef AlterTimeSeriesWrapperFactory Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::climate::AlterTimeSeriesWrapperFactory::WrapParams WrapParams;
  typedef  ::mas::schema::climate::AlterTimeSeriesWrapperFactory::WrapResults WrapResults;
  typedef ::capnp::CallContext<WrapParams, WrapResults> WrapContext;
  virtual ::kj::Promise<void> wrap(WrapContext context);

  inline  ::mas::schema::climate::AlterTimeSeriesWrapperFactory::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::climate::AlterTimeSeriesWrapperFactory>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class AlterTimeSeriesWrapperFactory::WrapParams::Reader {
public:
  typedef WrapParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTimeSeries() const;
#if !CAPNP_LITE
  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AlterTimeSeriesWrapperFactory::WrapParams::Builder {
public:
  typedef WrapParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTimeSeries();
#if !CAPNP_LITE
  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries();
  inline void setTimeSeries( ::mas::schema::climate::TimeSeries::Client&& value);
  inline void setTimeSeries( ::mas::schema::climate::TimeSeries::Client& value);
  inline void adoptTimeSeries(::capnp::Orphan< ::mas::schema::climate::TimeSeries>&& value);
  inline ::capnp::Orphan< ::mas::schema::climate::TimeSeries> disownTimeSeries();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AlterTimeSeriesWrapperFactory::WrapParams::Pipeline {
public:
  typedef WrapParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AlterTimeSeriesWrapperFactory::WrapResults::Reader {
public:
  typedef WrapResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasWrapper() const;
#if !CAPNP_LITE
  inline  ::mas::schema::climate::AlterTimeSeriesWrapper::Client getWrapper() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AlterTimeSeriesWrapperFactory::WrapResults::Builder {
public:
  typedef WrapResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasWrapper();
#if !CAPNP_LITE
  inline  ::mas::schema::climate::AlterTimeSeriesWrapper::Client getWrapper();
  inline void setWrapper( ::mas::schema::climate::AlterTimeSeriesWrapper::Client&& value);
  inline void setWrapper( ::mas::schema::climate::AlterTimeSeriesWrapper::Client& value);
  inline void adoptWrapper(::capnp::Orphan< ::mas::schema::climate::AlterTimeSeriesWrapper>&& value);
  inline ::capnp::Orphan< ::mas::schema::climate::AlterTimeSeriesWrapper> disownWrapper();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AlterTimeSeriesWrapperFactory::WrapResults::Pipeline {
public:
  typedef WrapResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::climate::AlterTimeSeriesWrapper::Client getWrapper();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::uint16_t EnsembleMember::Reader::getR() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t EnsembleMember::Builder::getR() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void EnsembleMember::Builder::setR( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t EnsembleMember::Reader::getI() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t EnsembleMember::Builder::getI() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void EnsembleMember::Builder::setI( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t EnsembleMember::Reader::getP() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t EnsembleMember::Builder::getP() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void EnsembleMember::Builder::setP( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t EnsembleMember::Reader::getF() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t EnsembleMember::Builder::getF() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void EnsembleMember::Builder::setF( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool Metadata::Reader::hasEntries() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Metadata::Builder::hasEntries() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::climate::Metadata::Entry,  ::capnp::Kind::STRUCT>::Reader Metadata::Reader::getEntries() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Metadata::Entry,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::climate::Metadata::Entry,  ::capnp::Kind::STRUCT>::Builder Metadata::Builder::getEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Metadata::Entry,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Metadata::Builder::setEntries( ::capnp::List< ::mas::schema::climate::Metadata::Entry,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Metadata::Entry,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::climate::Metadata::Entry,  ::capnp::Kind::STRUCT>::Builder Metadata::Builder::initEntries(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Metadata::Entry,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Metadata::Builder::adoptEntries(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Metadata::Entry,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Metadata::Entry,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Metadata::Entry,  ::capnp::Kind::STRUCT>> Metadata::Builder::disownEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Metadata::Entry,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Metadata::Reader::hasInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Metadata::Builder::hasInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::climate::Metadata::Information::Client Metadata::Reader::getInfo() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::Metadata::Information>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::Metadata::Information::Client Metadata::Builder::getInfo() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::Metadata::Information>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::Metadata::Information::Client Metadata::Pipeline::getInfo() {
  return  ::mas::schema::climate::Metadata::Information::Client(_typeless.getPointerField(1).asCap());
}
inline void Metadata::Builder::setInfo( ::mas::schema::climate::Metadata::Information::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::Metadata::Information>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Metadata::Builder::setInfo( ::mas::schema::climate::Metadata::Information::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::Metadata::Information>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), cap);
}
inline void Metadata::Builder::adoptInfo(
    ::capnp::Orphan< ::mas::schema::climate::Metadata::Information>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::Metadata::Information>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::climate::Metadata::Information> Metadata::Builder::disownInfo() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::Metadata::Information>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
inline Metadata::Supported::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Metadata::Supported::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Metadata::Supported::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Metadata::Supported::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Metadata::Supported::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::climate::Metadata::Supported::Client& Metadata::Supported::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::climate::Metadata::Supported::Client& Metadata::Supported::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Metadata::Supported::CategoriesResults::Reader::hasTypes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Metadata::Supported::CategoriesResults::Builder::hasTypes() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Reader Metadata::Supported::CategoriesResults::Reader::getTypes() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Builder Metadata::Supported::CategoriesResults::Builder::getTypes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Metadata::Supported::CategoriesResults::Builder::setTypes( ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Builder Metadata::Supported::CategoriesResults::Builder::initTypes(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Metadata::Supported::CategoriesResults::Builder::adoptTypes(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>> Metadata::Supported::CategoriesResults::Builder::disownTypes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Metadata::Supported::SupportedValuesParams::Reader::hasTypeId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Metadata::Supported::SupportedValuesParams::Builder::hasTypeId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Metadata::Supported::SupportedValuesParams::Reader::getTypeId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Metadata::Supported::SupportedValuesParams::Builder::getTypeId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Metadata::Supported::SupportedValuesParams::Builder::setTypeId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Metadata::Supported::SupportedValuesParams::Builder::initTypeId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Metadata::Supported::SupportedValuesParams::Builder::adoptTypeId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Metadata::Supported::SupportedValuesParams::Builder::disownTypeId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Metadata::Supported::SupportedValuesResults::Reader::hasValues() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Metadata::Supported::SupportedValuesResults::Builder::hasValues() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Reader Metadata::Supported::SupportedValuesResults::Reader::getValues() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Builder Metadata::Supported::SupportedValuesResults::Builder::getValues() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Metadata::Supported::SupportedValuesResults::Builder::setValues( ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Builder Metadata::Supported::SupportedValuesResults::Builder::initValues(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Metadata::Supported::SupportedValuesResults::Builder::adoptValues(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>> Metadata::Supported::SupportedValuesResults::Builder::disownValues() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::mas::schema::climate::Metadata::Value::Which Metadata::Value::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::mas::schema::climate::Metadata::Value::Which Metadata::Value::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Metadata::Value::Reader::isText() const {
  return which() == Metadata::Value::TEXT;
}
inline bool Metadata::Value::Builder::isText() {
  return which() == Metadata::Value::TEXT;
}
inline bool Metadata::Value::Reader::hasText() const {
  if (which() != Metadata::Value::TEXT) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Metadata::Value::Builder::hasText() {
  if (which() != Metadata::Value::TEXT) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Metadata::Value::Reader::getText() const {
  KJ_IREQUIRE((which() == Metadata::Value::TEXT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Metadata::Value::Builder::getText() {
  KJ_IREQUIRE((which() == Metadata::Value::TEXT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Metadata::Value::Builder::setText( ::capnp::Text::Reader value) {
  _builder.setDataField<Metadata::Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Metadata::Value::TEXT);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Metadata::Value::Builder::initText(unsigned int size) {
  _builder.setDataField<Metadata::Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Metadata::Value::TEXT);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Metadata::Value::Builder::adoptText(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<Metadata::Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Metadata::Value::TEXT);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Metadata::Value::Builder::disownText() {
  KJ_IREQUIRE((which() == Metadata::Value::TEXT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Metadata::Value::Reader::isFloat() const {
  return which() == Metadata::Value::FLOAT;
}
inline bool Metadata::Value::Builder::isFloat() {
  return which() == Metadata::Value::FLOAT;
}
inline double Metadata::Value::Reader::getFloat() const {
  KJ_IREQUIRE((which() == Metadata::Value::FLOAT),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Metadata::Value::Builder::getFloat() {
  KJ_IREQUIRE((which() == Metadata::Value::FLOAT),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Metadata::Value::Builder::setFloat(double value) {
  _builder.setDataField<Metadata::Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Metadata::Value::FLOAT);
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Metadata::Value::Reader::isInt() const {
  return which() == Metadata::Value::INT;
}
inline bool Metadata::Value::Builder::isInt() {
  return which() == Metadata::Value::INT;
}
inline  ::int64_t Metadata::Value::Reader::getInt() const {
  KJ_IREQUIRE((which() == Metadata::Value::INT),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int64_t Metadata::Value::Builder::getInt() {
  KJ_IREQUIRE((which() == Metadata::Value::INT),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Metadata::Value::Builder::setInt( ::int64_t value) {
  _builder.setDataField<Metadata::Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Metadata::Value::INT);
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Metadata::Value::Reader::isBool() const {
  return which() == Metadata::Value::BOOL;
}
inline bool Metadata::Value::Builder::isBool() {
  return which() == Metadata::Value::BOOL;
}
inline bool Metadata::Value::Reader::getBool() const {
  KJ_IREQUIRE((which() == Metadata::Value::BOOL),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}

inline bool Metadata::Value::Builder::getBool() {
  KJ_IREQUIRE((which() == Metadata::Value::BOOL),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}
inline void Metadata::Value::Builder::setBool(bool value) {
  _builder.setDataField<Metadata::Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Metadata::Value::BOOL);
  _builder.setDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS, value);
}

inline bool Metadata::Value::Reader::isDate() const {
  return which() == Metadata::Value::DATE;
}
inline bool Metadata::Value::Builder::isDate() {
  return which() == Metadata::Value::DATE;
}
inline bool Metadata::Value::Reader::hasDate() const {
  if (which() != Metadata::Value::DATE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Metadata::Value::Builder::hasDate() {
  if (which() != Metadata::Value::DATE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::common::Date::Reader Metadata::Value::Reader::getDate() const {
  KJ_IREQUIRE((which() == Metadata::Value::DATE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::Date::Builder Metadata::Value::Builder::getDate() {
  KJ_IREQUIRE((which() == Metadata::Value::DATE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Metadata::Value::Builder::setDate( ::mas::schema::common::Date::Reader value) {
  _builder.setDataField<Metadata::Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Metadata::Value::DATE);
  ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::common::Date::Builder Metadata::Value::Builder::initDate() {
  _builder.setDataField<Metadata::Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Metadata::Value::DATE);
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Metadata::Value::Builder::adoptDate(
    ::capnp::Orphan< ::mas::schema::common::Date>&& value) {
  _builder.setDataField<Metadata::Value::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Metadata::Value::DATE);
  ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::common::Date> Metadata::Value::Builder::disownDate() {
  KJ_IREQUIRE((which() == Metadata::Value::DATE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::mas::schema::climate::Metadata::Entry::Which Metadata::Entry::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline  ::mas::schema::climate::Metadata::Entry::Which Metadata::Entry::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool Metadata::Entry::Reader::isGcm() const {
  return which() == Metadata::Entry::GCM;
}
inline bool Metadata::Entry::Builder::isGcm() {
  return which() == Metadata::Entry::GCM;
}
inline  ::mas::schema::climate::GCM Metadata::Entry::Reader::getGcm() const {
  KJ_IREQUIRE((which() == Metadata::Entry::GCM),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::mas::schema::climate::GCM>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::climate::GCM Metadata::Entry::Builder::getGcm() {
  KJ_IREQUIRE((which() == Metadata::Entry::GCM),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::mas::schema::climate::GCM>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Metadata::Entry::Builder::setGcm( ::mas::schema::climate::GCM value) {
  _builder.setDataField<Metadata::Entry::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Metadata::Entry::GCM);
  _builder.setDataField< ::mas::schema::climate::GCM>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Metadata::Entry::Reader::isRcm() const {
  return which() == Metadata::Entry::RCM;
}
inline bool Metadata::Entry::Builder::isRcm() {
  return which() == Metadata::Entry::RCM;
}
inline  ::mas::schema::climate::RCM Metadata::Entry::Reader::getRcm() const {
  KJ_IREQUIRE((which() == Metadata::Entry::RCM),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::mas::schema::climate::RCM>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::climate::RCM Metadata::Entry::Builder::getRcm() {
  KJ_IREQUIRE((which() == Metadata::Entry::RCM),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::mas::schema::climate::RCM>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Metadata::Entry::Builder::setRcm( ::mas::schema::climate::RCM value) {
  _builder.setDataField<Metadata::Entry::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Metadata::Entry::RCM);
  _builder.setDataField< ::mas::schema::climate::RCM>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Metadata::Entry::Reader::isHistorical() const {
  return which() == Metadata::Entry::HISTORICAL;
}
inline bool Metadata::Entry::Builder::isHistorical() {
  return which() == Metadata::Entry::HISTORICAL;
}
inline  ::capnp::Void Metadata::Entry::Reader::getHistorical() const {
  KJ_IREQUIRE((which() == Metadata::Entry::HISTORICAL),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Metadata::Entry::Builder::getHistorical() {
  KJ_IREQUIRE((which() == Metadata::Entry::HISTORICAL),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Metadata::Entry::Builder::setHistorical( ::capnp::Void value) {
  _builder.setDataField<Metadata::Entry::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Metadata::Entry::HISTORICAL);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Metadata::Entry::Reader::isRcp() const {
  return which() == Metadata::Entry::RCP;
}
inline bool Metadata::Entry::Builder::isRcp() {
  return which() == Metadata::Entry::RCP;
}
inline  ::mas::schema::climate::RCP Metadata::Entry::Reader::getRcp() const {
  KJ_IREQUIRE((which() == Metadata::Entry::RCP),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::mas::schema::climate::RCP>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::climate::RCP Metadata::Entry::Builder::getRcp() {
  KJ_IREQUIRE((which() == Metadata::Entry::RCP),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::mas::schema::climate::RCP>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Metadata::Entry::Builder::setRcp( ::mas::schema::climate::RCP value) {
  _builder.setDataField<Metadata::Entry::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Metadata::Entry::RCP);
  _builder.setDataField< ::mas::schema::climate::RCP>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Metadata::Entry::Reader::isSsp() const {
  return which() == Metadata::Entry::SSP;
}
inline bool Metadata::Entry::Builder::isSsp() {
  return which() == Metadata::Entry::SSP;
}
inline  ::mas::schema::climate::SSP Metadata::Entry::Reader::getSsp() const {
  KJ_IREQUIRE((which() == Metadata::Entry::SSP),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::mas::schema::climate::SSP>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::climate::SSP Metadata::Entry::Builder::getSsp() {
  KJ_IREQUIRE((which() == Metadata::Entry::SSP),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::mas::schema::climate::SSP>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Metadata::Entry::Builder::setSsp( ::mas::schema::climate::SSP value) {
  _builder.setDataField<Metadata::Entry::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Metadata::Entry::SSP);
  _builder.setDataField< ::mas::schema::climate::SSP>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Metadata::Entry::Reader::isEnsMem() const {
  return which() == Metadata::Entry::ENS_MEM;
}
inline bool Metadata::Entry::Builder::isEnsMem() {
  return which() == Metadata::Entry::ENS_MEM;
}
inline bool Metadata::Entry::Reader::hasEnsMem() const {
  if (which() != Metadata::Entry::ENS_MEM) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Metadata::Entry::Builder::hasEnsMem() {
  if (which() != Metadata::Entry::ENS_MEM) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::climate::EnsembleMember::Reader Metadata::Entry::Reader::getEnsMem() const {
  KJ_IREQUIRE((which() == Metadata::Entry::ENS_MEM),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::EnsembleMember>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::EnsembleMember::Builder Metadata::Entry::Builder::getEnsMem() {
  KJ_IREQUIRE((which() == Metadata::Entry::ENS_MEM),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::EnsembleMember>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Metadata::Entry::Builder::setEnsMem( ::mas::schema::climate::EnsembleMember::Reader value) {
  _builder.setDataField<Metadata::Entry::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Metadata::Entry::ENS_MEM);
  ::capnp::_::PointerHelpers< ::mas::schema::climate::EnsembleMember>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::climate::EnsembleMember::Builder Metadata::Entry::Builder::initEnsMem() {
  _builder.setDataField<Metadata::Entry::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Metadata::Entry::ENS_MEM);
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::EnsembleMember>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Metadata::Entry::Builder::adoptEnsMem(
    ::capnp::Orphan< ::mas::schema::climate::EnsembleMember>&& value) {
  _builder.setDataField<Metadata::Entry::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Metadata::Entry::ENS_MEM);
  ::capnp::_::PointerHelpers< ::mas::schema::climate::EnsembleMember>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::climate::EnsembleMember> Metadata::Entry::Builder::disownEnsMem() {
  KJ_IREQUIRE((which() == Metadata::Entry::ENS_MEM),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::EnsembleMember>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Metadata::Entry::Reader::isVersion() const {
  return which() == Metadata::Entry::VERSION;
}
inline bool Metadata::Entry::Builder::isVersion() {
  return which() == Metadata::Entry::VERSION;
}
inline bool Metadata::Entry::Reader::hasVersion() const {
  if (which() != Metadata::Entry::VERSION) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Metadata::Entry::Builder::hasVersion() {
  if (which() != Metadata::Entry::VERSION) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Metadata::Entry::Reader::getVersion() const {
  KJ_IREQUIRE((which() == Metadata::Entry::VERSION),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Metadata::Entry::Builder::getVersion() {
  KJ_IREQUIRE((which() == Metadata::Entry::VERSION),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Metadata::Entry::Builder::setVersion( ::capnp::Text::Reader value) {
  _builder.setDataField<Metadata::Entry::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Metadata::Entry::VERSION);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Metadata::Entry::Builder::initVersion(unsigned int size) {
  _builder.setDataField<Metadata::Entry::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Metadata::Entry::VERSION);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Metadata::Entry::Builder::adoptVersion(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<Metadata::Entry::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Metadata::Entry::VERSION);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Metadata::Entry::Builder::disownVersion() {
  KJ_IREQUIRE((which() == Metadata::Entry::VERSION),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Metadata::Entry::Reader::isStart() const {
  return which() == Metadata::Entry::START;
}
inline bool Metadata::Entry::Builder::isStart() {
  return which() == Metadata::Entry::START;
}
inline bool Metadata::Entry::Reader::hasStart() const {
  if (which() != Metadata::Entry::START) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Metadata::Entry::Builder::hasStart() {
  if (which() != Metadata::Entry::START) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::common::Date::Reader Metadata::Entry::Reader::getStart() const {
  KJ_IREQUIRE((which() == Metadata::Entry::START),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::Date::Builder Metadata::Entry::Builder::getStart() {
  KJ_IREQUIRE((which() == Metadata::Entry::START),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Metadata::Entry::Builder::setStart( ::mas::schema::common::Date::Reader value) {
  _builder.setDataField<Metadata::Entry::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Metadata::Entry::START);
  ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::common::Date::Builder Metadata::Entry::Builder::initStart() {
  _builder.setDataField<Metadata::Entry::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Metadata::Entry::START);
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Metadata::Entry::Builder::adoptStart(
    ::capnp::Orphan< ::mas::schema::common::Date>&& value) {
  _builder.setDataField<Metadata::Entry::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Metadata::Entry::START);
  ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::common::Date> Metadata::Entry::Builder::disownStart() {
  KJ_IREQUIRE((which() == Metadata::Entry::START),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Metadata::Entry::Reader::isEnd() const {
  return which() == Metadata::Entry::END;
}
inline bool Metadata::Entry::Builder::isEnd() {
  return which() == Metadata::Entry::END;
}
inline bool Metadata::Entry::Reader::hasEnd() const {
  if (which() != Metadata::Entry::END) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Metadata::Entry::Builder::hasEnd() {
  if (which() != Metadata::Entry::END) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::common::Date::Reader Metadata::Entry::Reader::getEnd() const {
  KJ_IREQUIRE((which() == Metadata::Entry::END),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::Date::Builder Metadata::Entry::Builder::getEnd() {
  KJ_IREQUIRE((which() == Metadata::Entry::END),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Metadata::Entry::Builder::setEnd( ::mas::schema::common::Date::Reader value) {
  _builder.setDataField<Metadata::Entry::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Metadata::Entry::END);
  ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::common::Date::Builder Metadata::Entry::Builder::initEnd() {
  _builder.setDataField<Metadata::Entry::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Metadata::Entry::END);
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Metadata::Entry::Builder::adoptEnd(
    ::capnp::Orphan< ::mas::schema::common::Date>&& value) {
  _builder.setDataField<Metadata::Entry::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Metadata::Entry::END);
  ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::common::Date> Metadata::Entry::Builder::disownEnd() {
  KJ_IREQUIRE((which() == Metadata::Entry::END),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Metadata::Entry::Reader::isCo2() const {
  return which() == Metadata::Entry::CO2;
}
inline bool Metadata::Entry::Builder::isCo2() {
  return which() == Metadata::Entry::CO2;
}
inline float Metadata::Entry::Reader::getCo2() const {
  KJ_IREQUIRE((which() == Metadata::Entry::CO2),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Metadata::Entry::Builder::getCo2() {
  KJ_IREQUIRE((which() == Metadata::Entry::CO2),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Metadata::Entry::Builder::setCo2(float value) {
  _builder.setDataField<Metadata::Entry::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Metadata::Entry::CO2);
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Metadata::Entry::Reader::isPicontrol() const {
  return which() == Metadata::Entry::PICONTROL;
}
inline bool Metadata::Entry::Builder::isPicontrol() {
  return which() == Metadata::Entry::PICONTROL;
}
inline  ::capnp::Void Metadata::Entry::Reader::getPicontrol() const {
  KJ_IREQUIRE((which() == Metadata::Entry::PICONTROL),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Metadata::Entry::Builder::getPicontrol() {
  KJ_IREQUIRE((which() == Metadata::Entry::PICONTROL),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Metadata::Entry::Builder::setPicontrol( ::capnp::Void value) {
  _builder.setDataField<Metadata::Entry::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Metadata::Entry::PICONTROL);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Metadata::Entry::Reader::isDescription() const {
  return which() == Metadata::Entry::DESCRIPTION;
}
inline bool Metadata::Entry::Builder::isDescription() {
  return which() == Metadata::Entry::DESCRIPTION;
}
inline bool Metadata::Entry::Reader::hasDescription() const {
  if (which() != Metadata::Entry::DESCRIPTION) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Metadata::Entry::Builder::hasDescription() {
  if (which() != Metadata::Entry::DESCRIPTION) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Metadata::Entry::Reader::getDescription() const {
  KJ_IREQUIRE((which() == Metadata::Entry::DESCRIPTION),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Metadata::Entry::Builder::getDescription() {
  KJ_IREQUIRE((which() == Metadata::Entry::DESCRIPTION),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Metadata::Entry::Builder::setDescription( ::capnp::Text::Reader value) {
  _builder.setDataField<Metadata::Entry::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Metadata::Entry::DESCRIPTION);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Metadata::Entry::Builder::initDescription(unsigned int size) {
  _builder.setDataField<Metadata::Entry::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Metadata::Entry::DESCRIPTION);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Metadata::Entry::Builder::adoptDescription(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<Metadata::Entry::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Metadata::Entry::DESCRIPTION);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Metadata::Entry::Builder::disownDescription() {
  KJ_IREQUIRE((which() == Metadata::Entry::DESCRIPTION),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline Metadata::Information::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Metadata::Information::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Metadata::Information::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Metadata::Information::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Metadata::Information::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::climate::Metadata::Information::Client& Metadata::Information::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::climate::Metadata::Information::Client& Metadata::Information::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Metadata::Information::ForOneParams::Reader::hasEntry() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Metadata::Information::ForOneParams::Builder::hasEntry() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::climate::Metadata::Entry::Reader Metadata::Information::ForOneParams::Reader::getEntry() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::Metadata::Entry>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::Metadata::Entry::Builder Metadata::Information::ForOneParams::Builder::getEntry() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::Metadata::Entry>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::climate::Metadata::Entry::Pipeline Metadata::Information::ForOneParams::Pipeline::getEntry() {
  return  ::mas::schema::climate::Metadata::Entry::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Metadata::Information::ForOneParams::Builder::setEntry( ::mas::schema::climate::Metadata::Entry::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::Metadata::Entry>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::climate::Metadata::Entry::Builder Metadata::Information::ForOneParams::Builder::initEntry() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::Metadata::Entry>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Metadata::Information::ForOneParams::Builder::adoptEntry(
    ::capnp::Orphan< ::mas::schema::climate::Metadata::Entry>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::Metadata::Entry>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::climate::Metadata::Entry> Metadata::Information::ForOneParams::Builder::disownEntry() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::Metadata::Entry>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Metadata::Information::ForAllResults::Reader::hasAll() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Metadata::Information::ForAllResults::Builder::hasAll() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::common::Pair< ::mas::schema::climate::Metadata::Entry,  ::mas::schema::common::IdInformation>,  ::capnp::Kind::STRUCT>::Reader Metadata::Information::ForAllResults::Reader::getAll() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::mas::schema::climate::Metadata::Entry,  ::mas::schema::common::IdInformation>,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::common::Pair< ::mas::schema::climate::Metadata::Entry,  ::mas::schema::common::IdInformation>,  ::capnp::Kind::STRUCT>::Builder Metadata::Information::ForAllResults::Builder::getAll() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::mas::schema::climate::Metadata::Entry,  ::mas::schema::common::IdInformation>,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Metadata::Information::ForAllResults::Builder::setAll( ::capnp::List< ::mas::schema::common::Pair< ::mas::schema::climate::Metadata::Entry,  ::mas::schema::common::IdInformation>,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::mas::schema::climate::Metadata::Entry,  ::mas::schema::common::IdInformation>,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::common::Pair< ::mas::schema::climate::Metadata::Entry,  ::mas::schema::common::IdInformation>,  ::capnp::Kind::STRUCT>::Builder Metadata::Information::ForAllResults::Builder::initAll(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::mas::schema::climate::Metadata::Entry,  ::mas::schema::common::IdInformation>,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Metadata::Information::ForAllResults::Builder::adoptAll(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Pair< ::mas::schema::climate::Metadata::Entry,  ::mas::schema::common::IdInformation>,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::mas::schema::climate::Metadata::Entry,  ::mas::schema::common::IdInformation>,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Pair< ::mas::schema::climate::Metadata::Entry,  ::mas::schema::common::IdInformation>,  ::capnp::Kind::STRUCT>> Metadata::Information::ForAllResults::Builder::disownAll() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::mas::schema::climate::Metadata::Entry,  ::mas::schema::common::IdInformation>,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline Dataset::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Dataset::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Dataset::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Dataset::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Dataset::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::climate::Dataset::Client& Dataset::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::climate::Dataset::Client& Dataset::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
#if !CAPNP_LITE
inline Dataset::GetLocationsCallback::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Dataset::GetLocationsCallback::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Dataset::GetLocationsCallback::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Dataset::GetLocationsCallback::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Dataset::GetLocationsCallback::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::climate::Dataset::GetLocationsCallback::Client& Dataset::GetLocationsCallback::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::climate::Dataset::GetLocationsCallback::Client& Dataset::GetLocationsCallback::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline  ::int64_t Dataset::GetLocationsCallback::NextLocationsParams::Reader::getMaxCount() const {
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int64_t Dataset::GetLocationsCallback::NextLocationsParams::Builder::getMaxCount() {
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Dataset::GetLocationsCallback::NextLocationsParams::Builder::setMaxCount( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Dataset::GetLocationsCallback::NextLocationsResults::Reader::hasLocations() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Dataset::GetLocationsCallback::NextLocationsResults::Builder::hasLocations() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>::Reader Dataset::GetLocationsCallback::NextLocationsResults::Reader::getLocations() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>::Builder Dataset::GetLocationsCallback::NextLocationsResults::Builder::getLocations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Dataset::GetLocationsCallback::NextLocationsResults::Builder::setLocations( ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>::Builder Dataset::GetLocationsCallback::NextLocationsResults::Builder::initLocations(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Dataset::GetLocationsCallback::NextLocationsResults::Builder::adoptLocations(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>> Dataset::GetLocationsCallback::NextLocationsResults::Builder::disownLocations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Dataset::ClosestTimeSeriesAtParams::Reader::hasLatlon() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Dataset::ClosestTimeSeriesAtParams::Builder::hasLatlon() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::geo::LatLonCoord::Reader Dataset::ClosestTimeSeriesAtParams::Reader::getLatlon() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::geo::LatLonCoord::Builder Dataset::ClosestTimeSeriesAtParams::Builder::getLatlon() {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::geo::LatLonCoord::Pipeline Dataset::ClosestTimeSeriesAtParams::Pipeline::getLatlon() {
  return  ::mas::schema::geo::LatLonCoord::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Dataset::ClosestTimeSeriesAtParams::Builder::setLatlon( ::mas::schema::geo::LatLonCoord::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::geo::LatLonCoord::Builder Dataset::ClosestTimeSeriesAtParams::Builder::initLatlon() {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Dataset::ClosestTimeSeriesAtParams::Builder::adoptLatlon(
    ::capnp::Orphan< ::mas::schema::geo::LatLonCoord>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::geo::LatLonCoord> Dataset::ClosestTimeSeriesAtParams::Builder::disownLatlon() {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Dataset::ClosestTimeSeriesAtResults::Reader::hasTimeSeries() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Dataset::ClosestTimeSeriesAtResults::Builder::hasTimeSeries() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::climate::TimeSeries::Client Dataset::ClosestTimeSeriesAtResults::Reader::getTimeSeries() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::TimeSeries::Client Dataset::ClosestTimeSeriesAtResults::Builder::getTimeSeries() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::TimeSeries::Client Dataset::ClosestTimeSeriesAtResults::Pipeline::getTimeSeries() {
  return  ::mas::schema::climate::TimeSeries::Client(_typeless.getPointerField(0).asCap());
}
inline void Dataset::ClosestTimeSeriesAtResults::Builder::setTimeSeries( ::mas::schema::climate::TimeSeries::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Dataset::ClosestTimeSeriesAtResults::Builder::setTimeSeries( ::mas::schema::climate::TimeSeries::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Dataset::ClosestTimeSeriesAtResults::Builder::adoptTimeSeries(
    ::capnp::Orphan< ::mas::schema::climate::TimeSeries>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::climate::TimeSeries> Dataset::ClosestTimeSeriesAtResults::Builder::disownTimeSeries() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Dataset::TimeSeriesAtParams::Reader::hasLocationId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Dataset::TimeSeriesAtParams::Builder::hasLocationId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Dataset::TimeSeriesAtParams::Reader::getLocationId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Dataset::TimeSeriesAtParams::Builder::getLocationId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Dataset::TimeSeriesAtParams::Builder::setLocationId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Dataset::TimeSeriesAtParams::Builder::initLocationId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Dataset::TimeSeriesAtParams::Builder::adoptLocationId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Dataset::TimeSeriesAtParams::Builder::disownLocationId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Dataset::TimeSeriesAtResults::Reader::hasTimeSeries() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Dataset::TimeSeriesAtResults::Builder::hasTimeSeries() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::climate::TimeSeries::Client Dataset::TimeSeriesAtResults::Reader::getTimeSeries() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::TimeSeries::Client Dataset::TimeSeriesAtResults::Builder::getTimeSeries() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::TimeSeries::Client Dataset::TimeSeriesAtResults::Pipeline::getTimeSeries() {
  return  ::mas::schema::climate::TimeSeries::Client(_typeless.getPointerField(0).asCap());
}
inline void Dataset::TimeSeriesAtResults::Builder::setTimeSeries( ::mas::schema::climate::TimeSeries::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Dataset::TimeSeriesAtResults::Builder::setTimeSeries( ::mas::schema::climate::TimeSeries::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Dataset::TimeSeriesAtResults::Builder::adoptTimeSeries(
    ::capnp::Orphan< ::mas::schema::climate::TimeSeries>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::climate::TimeSeries> Dataset::TimeSeriesAtResults::Builder::disownTimeSeries() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Dataset::LocationsResults::Reader::hasLocations() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Dataset::LocationsResults::Builder::hasLocations() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>::Reader Dataset::LocationsResults::Reader::getLocations() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>::Builder Dataset::LocationsResults::Builder::getLocations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Dataset::LocationsResults::Builder::setLocations( ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>::Builder Dataset::LocationsResults::Builder::initLocations(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Dataset::LocationsResults::Builder::adoptLocations(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>> Dataset::LocationsResults::Builder::disownLocations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Location,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Dataset::StreamLocationsParams::Reader::hasStartAfterLocationId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Dataset::StreamLocationsParams::Builder::hasStartAfterLocationId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Dataset::StreamLocationsParams::Reader::getStartAfterLocationId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Dataset::StreamLocationsParams::Builder::getStartAfterLocationId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Dataset::StreamLocationsParams::Builder::setStartAfterLocationId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Dataset::StreamLocationsParams::Builder::initStartAfterLocationId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Dataset::StreamLocationsParams::Builder::adoptStartAfterLocationId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Dataset::StreamLocationsParams::Builder::disownStartAfterLocationId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Dataset::StreamLocationsResults::Reader::hasLocationsCallback() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Dataset::StreamLocationsResults::Builder::hasLocationsCallback() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::climate::Dataset::GetLocationsCallback::Client Dataset::StreamLocationsResults::Reader::getLocationsCallback() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::Dataset::GetLocationsCallback>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::Dataset::GetLocationsCallback::Client Dataset::StreamLocationsResults::Builder::getLocationsCallback() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::Dataset::GetLocationsCallback>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::Dataset::GetLocationsCallback::Client Dataset::StreamLocationsResults::Pipeline::getLocationsCallback() {
  return  ::mas::schema::climate::Dataset::GetLocationsCallback::Client(_typeless.getPointerField(0).asCap());
}
inline void Dataset::StreamLocationsResults::Builder::setLocationsCallback( ::mas::schema::climate::Dataset::GetLocationsCallback::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::Dataset::GetLocationsCallback>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Dataset::StreamLocationsResults::Builder::setLocationsCallback( ::mas::schema::climate::Dataset::GetLocationsCallback::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::Dataset::GetLocationsCallback>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Dataset::StreamLocationsResults::Builder::adoptLocationsCallback(
    ::capnp::Orphan< ::mas::schema::climate::Dataset::GetLocationsCallback>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::Dataset::GetLocationsCallback>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::climate::Dataset::GetLocationsCallback> Dataset::StreamLocationsResults::Builder::disownLocationsCallback() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::Dataset::GetLocationsCallback>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool MetaPlusData::Reader::hasMeta() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool MetaPlusData::Builder::hasMeta() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::climate::Metadata::Reader MetaPlusData::Reader::getMeta() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::Metadata>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::Metadata::Builder MetaPlusData::Builder::getMeta() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::Metadata>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::climate::Metadata::Pipeline MetaPlusData::Pipeline::getMeta() {
  return  ::mas::schema::climate::Metadata::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MetaPlusData::Builder::setMeta( ::mas::schema::climate::Metadata::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::Metadata>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::climate::Metadata::Builder MetaPlusData::Builder::initMeta() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::Metadata>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MetaPlusData::Builder::adoptMeta(
    ::capnp::Orphan< ::mas::schema::climate::Metadata>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::Metadata>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::climate::Metadata> MetaPlusData::Builder::disownMeta() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::Metadata>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool MetaPlusData::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool MetaPlusData::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::climate::Dataset::Client MetaPlusData::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::Dataset>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::Dataset::Client MetaPlusData::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::Dataset>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::Dataset::Client MetaPlusData::Pipeline::getData() {
  return  ::mas::schema::climate::Dataset::Client(_typeless.getPointerField(1).asCap());
}
inline void MetaPlusData::Builder::setData( ::mas::schema::climate::Dataset::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::Dataset>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void MetaPlusData::Builder::setData( ::mas::schema::climate::Dataset::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::Dataset>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), cap);
}
inline void MetaPlusData::Builder::adoptData(
    ::capnp::Orphan< ::mas::schema::climate::Dataset>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::Dataset>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::climate::Dataset> MetaPlusData::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::Dataset>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Location::Reader::hasId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Location::Builder::hasId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::common::IdInformation::Reader Location::Reader::getId() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::IdInformation::Builder Location::Builder::getId() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::common::IdInformation::Pipeline Location::Pipeline::getId() {
  return  ::mas::schema::common::IdInformation::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Location::Builder::setId( ::mas::schema::common::IdInformation::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::common::IdInformation::Builder Location::Builder::initId() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Location::Builder::adoptId(
    ::capnp::Orphan< ::mas::schema::common::IdInformation>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::common::IdInformation> Location::Builder::disownId() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float Location::Reader::getHeightNN() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Location::Builder::getHeightNN() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Location::Builder::setHeightNN(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Location::Reader::hasLatlon() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Location::Builder::hasLatlon() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::geo::LatLonCoord::Reader Location::Reader::getLatlon() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::geo::LatLonCoord::Builder Location::Builder::getLatlon() {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::geo::LatLonCoord::Pipeline Location::Pipeline::getLatlon() {
  return  ::mas::schema::geo::LatLonCoord::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Location::Builder::setLatlon( ::mas::schema::geo::LatLonCoord::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::geo::LatLonCoord::Builder Location::Builder::initLatlon() {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Location::Builder::adoptLatlon(
    ::capnp::Orphan< ::mas::schema::geo::LatLonCoord>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::geo::LatLonCoord> Location::Builder::disownLatlon() {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Location::Reader::hasTimeSeries() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Location::Builder::hasTimeSeries() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::climate::TimeSeries::Client Location::Reader::getTimeSeries() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::TimeSeries::Client Location::Builder::getTimeSeries() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::TimeSeries::Client Location::Pipeline::getTimeSeries() {
  return  ::mas::schema::climate::TimeSeries::Client(_typeless.getPointerField(2).asCap());
}
inline void Location::Builder::setTimeSeries( ::mas::schema::climate::TimeSeries::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Location::Builder::setTimeSeries( ::mas::schema::climate::TimeSeries::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), cap);
}
inline void Location::Builder::adoptTimeSeries(
    ::capnp::Orphan< ::mas::schema::climate::TimeSeries>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::climate::TimeSeries> Location::Builder::disownTimeSeries() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Location::Reader::hasCustomData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Location::Builder::hasCustomData() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::climate::Location::KV,  ::capnp::Kind::STRUCT>::Reader Location::Reader::getCustomData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Location::KV,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::climate::Location::KV,  ::capnp::Kind::STRUCT>::Builder Location::Builder::getCustomData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Location::KV,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Location::Builder::setCustomData( ::capnp::List< ::mas::schema::climate::Location::KV,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Location::KV,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::climate::Location::KV,  ::capnp::Kind::STRUCT>::Builder Location::Builder::initCustomData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Location::KV,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void Location::Builder::adoptCustomData(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Location::KV,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Location::KV,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Location::KV,  ::capnp::Kind::STRUCT>> Location::Builder::disownCustomData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Location::KV,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Location::KV::Reader::hasKey() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Location::KV::Builder::hasKey() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Location::KV::Reader::getKey() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Location::KV::Builder::getKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Location::KV::Builder::setKey( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Location::KV::Builder::initKey(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Location::KV::Builder::adoptKey(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Location::KV::Builder::disownKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Location::KV::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Location::KV::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline ::capnp::AnyPointer::Reader Location::KV::Reader::getValue() const {
  return ::capnp::AnyPointer::Reader(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder Location::KV::Builder::getValue() {
  return ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder Location::KV::Builder::initValue() {
  auto result = ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
  result.clear();
  return result;
}

#if !CAPNP_LITE
inline TimeSeries::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline TimeSeries::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline TimeSeries::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline TimeSeries::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline TimeSeries::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::climate::TimeSeries::Client& TimeSeries::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::climate::TimeSeries::Client& TimeSeries::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline  ::mas::schema::climate::TimeSeries::Resolution TimeSeries::ResolutionResults::Reader::getResolution() const {
  return _reader.getDataField< ::mas::schema::climate::TimeSeries::Resolution>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::climate::TimeSeries::Resolution TimeSeries::ResolutionResults::Builder::getResolution() {
  return _builder.getDataField< ::mas::schema::climate::TimeSeries::Resolution>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TimeSeries::ResolutionResults::Builder::setResolution( ::mas::schema::climate::TimeSeries::Resolution value) {
  _builder.setDataField< ::mas::schema::climate::TimeSeries::Resolution>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TimeSeries::RangeResults::Reader::hasStartDate() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TimeSeries::RangeResults::Builder::hasStartDate() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::common::Date::Reader TimeSeries::RangeResults::Reader::getStartDate() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::Date::Builder TimeSeries::RangeResults::Builder::getStartDate() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::common::Date::Pipeline TimeSeries::RangeResults::Pipeline::getStartDate() {
  return  ::mas::schema::common::Date::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void TimeSeries::RangeResults::Builder::setStartDate( ::mas::schema::common::Date::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::common::Date::Builder TimeSeries::RangeResults::Builder::initStartDate() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TimeSeries::RangeResults::Builder::adoptStartDate(
    ::capnp::Orphan< ::mas::schema::common::Date>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::common::Date> TimeSeries::RangeResults::Builder::disownStartDate() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TimeSeries::RangeResults::Reader::hasEndDate() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TimeSeries::RangeResults::Builder::hasEndDate() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::common::Date::Reader TimeSeries::RangeResults::Reader::getEndDate() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::Date::Builder TimeSeries::RangeResults::Builder::getEndDate() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::common::Date::Pipeline TimeSeries::RangeResults::Pipeline::getEndDate() {
  return  ::mas::schema::common::Date::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void TimeSeries::RangeResults::Builder::setEndDate( ::mas::schema::common::Date::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::common::Date::Builder TimeSeries::RangeResults::Builder::initEndDate() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TimeSeries::RangeResults::Builder::adoptEndDate(
    ::capnp::Orphan< ::mas::schema::common::Date>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::common::Date> TimeSeries::RangeResults::Builder::disownEndDate() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TimeSeries::HeaderResults::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TimeSeries::HeaderResults::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>::Reader TimeSeries::HeaderResults::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>::Builder TimeSeries::HeaderResults::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TimeSeries::HeaderResults::Builder::setHeader( ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void TimeSeries::HeaderResults::Builder::setHeader(::kj::ArrayPtr<const  ::mas::schema::climate::Element> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>::Builder TimeSeries::HeaderResults::Builder::initHeader(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TimeSeries::HeaderResults::Builder::adoptHeader(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>> TimeSeries::HeaderResults::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TimeSeries::DataResults::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TimeSeries::DataResults::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>::Reader TimeSeries::DataResults::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>::Builder TimeSeries::DataResults::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TimeSeries::DataResults::Builder::setData( ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void TimeSeries::DataResults::Builder::setData(::kj::ArrayPtr<const  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>::Builder TimeSeries::DataResults::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TimeSeries::DataResults::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>> TimeSeries::DataResults::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TimeSeries::DataTResults::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TimeSeries::DataTResults::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>::Reader TimeSeries::DataTResults::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>::Builder TimeSeries::DataTResults::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TimeSeries::DataTResults::Builder::setData( ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void TimeSeries::DataTResults::Builder::setData(::kj::ArrayPtr<const  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>::Builder TimeSeries::DataTResults::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TimeSeries::DataTResults::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>> TimeSeries::DataTResults::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TimeSeries::SubrangeParams::Reader::hasStart() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TimeSeries::SubrangeParams::Builder::hasStart() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::common::Date::Reader TimeSeries::SubrangeParams::Reader::getStart() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::Date::Builder TimeSeries::SubrangeParams::Builder::getStart() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::common::Date::Pipeline TimeSeries::SubrangeParams::Pipeline::getStart() {
  return  ::mas::schema::common::Date::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void TimeSeries::SubrangeParams::Builder::setStart( ::mas::schema::common::Date::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::common::Date::Builder TimeSeries::SubrangeParams::Builder::initStart() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TimeSeries::SubrangeParams::Builder::adoptStart(
    ::capnp::Orphan< ::mas::schema::common::Date>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::common::Date> TimeSeries::SubrangeParams::Builder::disownStart() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TimeSeries::SubrangeParams::Reader::hasEnd() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TimeSeries::SubrangeParams::Builder::hasEnd() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::common::Date::Reader TimeSeries::SubrangeParams::Reader::getEnd() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::Date::Builder TimeSeries::SubrangeParams::Builder::getEnd() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::common::Date::Pipeline TimeSeries::SubrangeParams::Pipeline::getEnd() {
  return  ::mas::schema::common::Date::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void TimeSeries::SubrangeParams::Builder::setEnd( ::mas::schema::common::Date::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::common::Date::Builder TimeSeries::SubrangeParams::Builder::initEnd() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TimeSeries::SubrangeParams::Builder::adoptEnd(
    ::capnp::Orphan< ::mas::schema::common::Date>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::common::Date> TimeSeries::SubrangeParams::Builder::disownEnd() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TimeSeries::SubrangeResults::Reader::hasTimeSeries() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TimeSeries::SubrangeResults::Builder::hasTimeSeries() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::climate::TimeSeries::Client TimeSeries::SubrangeResults::Reader::getTimeSeries() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::TimeSeries::Client TimeSeries::SubrangeResults::Builder::getTimeSeries() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::TimeSeries::Client TimeSeries::SubrangeResults::Pipeline::getTimeSeries() {
  return  ::mas::schema::climate::TimeSeries::Client(_typeless.getPointerField(0).asCap());
}
inline void TimeSeries::SubrangeResults::Builder::setTimeSeries( ::mas::schema::climate::TimeSeries::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TimeSeries::SubrangeResults::Builder::setTimeSeries( ::mas::schema::climate::TimeSeries::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void TimeSeries::SubrangeResults::Builder::adoptTimeSeries(
    ::capnp::Orphan< ::mas::schema::climate::TimeSeries>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::climate::TimeSeries> TimeSeries::SubrangeResults::Builder::disownTimeSeries() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TimeSeries::SubheaderParams::Reader::hasElements() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TimeSeries::SubheaderParams::Builder::hasElements() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>::Reader TimeSeries::SubheaderParams::Reader::getElements() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>::Builder TimeSeries::SubheaderParams::Builder::getElements() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TimeSeries::SubheaderParams::Builder::setElements( ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void TimeSeries::SubheaderParams::Builder::setElements(::kj::ArrayPtr<const  ::mas::schema::climate::Element> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>::Builder TimeSeries::SubheaderParams::Builder::initElements(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TimeSeries::SubheaderParams::Builder::adoptElements(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>> TimeSeries::SubheaderParams::Builder::disownElements() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TimeSeries::SubheaderResults::Reader::hasTimeSeries() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TimeSeries::SubheaderResults::Builder::hasTimeSeries() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::climate::TimeSeries::Client TimeSeries::SubheaderResults::Reader::getTimeSeries() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::TimeSeries::Client TimeSeries::SubheaderResults::Builder::getTimeSeries() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::TimeSeries::Client TimeSeries::SubheaderResults::Pipeline::getTimeSeries() {
  return  ::mas::schema::climate::TimeSeries::Client(_typeless.getPointerField(0).asCap());
}
inline void TimeSeries::SubheaderResults::Builder::setTimeSeries( ::mas::schema::climate::TimeSeries::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void TimeSeries::SubheaderResults::Builder::setTimeSeries( ::mas::schema::climate::TimeSeries::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void TimeSeries::SubheaderResults::Builder::adoptTimeSeries(
    ::capnp::Orphan< ::mas::schema::climate::TimeSeries>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::climate::TimeSeries> TimeSeries::SubheaderResults::Builder::disownTimeSeries() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TimeSeriesData::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TimeSeriesData::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>::Reader TimeSeriesData::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>::Builder TimeSeriesData::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TimeSeriesData::Builder::setData( ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void TimeSeriesData::Builder::setData(::kj::ArrayPtr<const  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>::Builder TimeSeriesData::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TimeSeriesData::Builder::adoptData(
    ::capnp::Orphan< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>> TimeSeriesData::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>,  ::capnp::Kind::LIST>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TimeSeriesData::Reader::getIsTransposed() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool TimeSeriesData::Builder::getIsTransposed() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TimeSeriesData::Builder::setIsTransposed(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TimeSeriesData::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TimeSeriesData::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>::Reader TimeSeriesData::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>::Builder TimeSeriesData::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TimeSeriesData::Builder::setHeader( ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void TimeSeriesData::Builder::setHeader(::kj::ArrayPtr<const  ::mas::schema::climate::Element> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>::Builder TimeSeriesData::Builder::initHeader(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TimeSeriesData::Builder::adoptHeader(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>> TimeSeriesData::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Element,  ::capnp::Kind::ENUM>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TimeSeriesData::Reader::hasStartDate() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool TimeSeriesData::Builder::hasStartDate() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::common::Date::Reader TimeSeriesData::Reader::getStartDate() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::Date::Builder TimeSeriesData::Builder::getStartDate() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::common::Date::Pipeline TimeSeriesData::Pipeline::getStartDate() {
  return  ::mas::schema::common::Date::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void TimeSeriesData::Builder::setStartDate( ::mas::schema::common::Date::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::common::Date::Builder TimeSeriesData::Builder::initStartDate() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void TimeSeriesData::Builder::adoptStartDate(
    ::capnp::Orphan< ::mas::schema::common::Date>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::common::Date> TimeSeriesData::Builder::disownStartDate() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool TimeSeriesData::Reader::hasEndDate() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool TimeSeriesData::Builder::hasEndDate() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::common::Date::Reader TimeSeriesData::Reader::getEndDate() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::Date::Builder TimeSeriesData::Builder::getEndDate() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::common::Date::Pipeline TimeSeriesData::Pipeline::getEndDate() {
  return  ::mas::schema::common::Date::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void TimeSeriesData::Builder::setEndDate( ::mas::schema::common::Date::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::common::Date::Builder TimeSeriesData::Builder::initEndDate() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void TimeSeriesData::Builder::adoptEndDate(
    ::capnp::Orphan< ::mas::schema::common::Date>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::common::Date> TimeSeriesData::Builder::disownEndDate() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline  ::mas::schema::climate::TimeSeries::Resolution TimeSeriesData::Reader::getResolution() const {
  return _reader.getDataField< ::mas::schema::climate::TimeSeries::Resolution>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::climate::TimeSeries::Resolution TimeSeriesData::Builder::getResolution() {
  return _builder.getDataField< ::mas::schema::climate::TimeSeries::Resolution>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TimeSeriesData::Builder::setResolution( ::mas::schema::climate::TimeSeries::Resolution value) {
  _builder.setDataField< ::mas::schema::climate::TimeSeries::Resolution>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

#if !CAPNP_LITE
inline Service::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Service::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Service::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Service::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Service::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::climate::Service::Client& Service::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::climate::Service::Client& Service::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Service::GetAvailableDatasetsResults::Reader::hasDatasets() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Service::GetAvailableDatasetsResults::Builder::hasDatasets() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::climate::MetaPlusData,  ::capnp::Kind::STRUCT>::Reader Service::GetAvailableDatasetsResults::Reader::getDatasets() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::MetaPlusData,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::climate::MetaPlusData,  ::capnp::Kind::STRUCT>::Builder Service::GetAvailableDatasetsResults::Builder::getDatasets() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::MetaPlusData,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Service::GetAvailableDatasetsResults::Builder::setDatasets( ::capnp::List< ::mas::schema::climate::MetaPlusData,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::MetaPlusData,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::climate::MetaPlusData,  ::capnp::Kind::STRUCT>::Builder Service::GetAvailableDatasetsResults::Builder::initDatasets(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::MetaPlusData,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Service::GetAvailableDatasetsResults::Builder::adoptDatasets(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::MetaPlusData,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::MetaPlusData,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::MetaPlusData,  ::capnp::Kind::STRUCT>> Service::GetAvailableDatasetsResults::Builder::disownDatasets() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::MetaPlusData,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Service::GetDatasetsForParams::Reader::hasTemplate() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Service::GetDatasetsForParams::Builder::hasTemplate() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::climate::Metadata::Reader Service::GetDatasetsForParams::Reader::getTemplate() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::Metadata>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::Metadata::Builder Service::GetDatasetsForParams::Builder::getTemplate() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::Metadata>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::climate::Metadata::Pipeline Service::GetDatasetsForParams::Pipeline::getTemplate() {
  return  ::mas::schema::climate::Metadata::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Service::GetDatasetsForParams::Builder::setTemplate( ::mas::schema::climate::Metadata::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::Metadata>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::climate::Metadata::Builder Service::GetDatasetsForParams::Builder::initTemplate() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::Metadata>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Service::GetDatasetsForParams::Builder::adoptTemplate(
    ::capnp::Orphan< ::mas::schema::climate::Metadata>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::Metadata>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::climate::Metadata> Service::GetDatasetsForParams::Builder::disownTemplate() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::Metadata>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Service::GetDatasetsForResults::Reader::hasDatasets() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Service::GetDatasetsForResults::Builder::hasDatasets() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnp::List< ::mas::schema::climate::Dataset,  ::capnp::Kind::INTERFACE>::Reader Service::GetDatasetsForResults::Reader::getDatasets() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Dataset,  ::capnp::Kind::INTERFACE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::climate::Dataset,  ::capnp::Kind::INTERFACE>::Builder Service::GetDatasetsForResults::Builder::getDatasets() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Dataset,  ::capnp::Kind::INTERFACE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Service::GetDatasetsForResults::Builder::setDatasets( ::capnp::List< ::mas::schema::climate::Dataset,  ::capnp::Kind::INTERFACE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Dataset,  ::capnp::Kind::INTERFACE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::climate::Dataset,  ::capnp::Kind::INTERFACE>::Builder Service::GetDatasetsForResults::Builder::initDatasets(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Dataset,  ::capnp::Kind::INTERFACE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Service::GetDatasetsForResults::Builder::adoptDatasets(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Dataset,  ::capnp::Kind::INTERFACE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Dataset,  ::capnp::Kind::INTERFACE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::Dataset,  ::capnp::Kind::INTERFACE>> Service::GetDatasetsForResults::Builder::disownDatasets() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::Dataset,  ::capnp::Kind::INTERFACE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
inline CSVTimeSeriesFactory::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline CSVTimeSeriesFactory::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline CSVTimeSeriesFactory::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline CSVTimeSeriesFactory::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline CSVTimeSeriesFactory::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::climate::CSVTimeSeriesFactory::Client& CSVTimeSeriesFactory::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::climate::CSVTimeSeriesFactory::Client& CSVTimeSeriesFactory::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool CSVTimeSeriesFactory::CSVConfig::Reader::hasSep() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CSVTimeSeriesFactory::CSVConfig::Builder::hasSep() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader CSVTimeSeriesFactory::CSVConfig::Reader::getSep() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eba81ca9f46690b8 + 56, 1);
}
inline  ::capnp::Text::Builder CSVTimeSeriesFactory::CSVConfig::Builder::getSep() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_eba81ca9f46690b8 + 56, 1);
}
inline void CSVTimeSeriesFactory::CSVConfig::Builder::setSep( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder CSVTimeSeriesFactory::CSVConfig::Builder::initSep(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void CSVTimeSeriesFactory::CSVConfig::Builder::adoptSep(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> CSVTimeSeriesFactory::CSVConfig::Builder::disownSep() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool CSVTimeSeriesFactory::CSVConfig::Reader::hasHeaderMap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool CSVTimeSeriesFactory::CSVConfig::Builder::hasHeaderMap() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>::Reader CSVTimeSeriesFactory::CSVConfig::Reader::getHeaderMap() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>::Builder CSVTimeSeriesFactory::CSVConfig::Builder::getHeaderMap() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CSVTimeSeriesFactory::CSVConfig::Builder::setHeaderMap( ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>::Builder CSVTimeSeriesFactory::CSVConfig::Builder::initHeaderMap(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void CSVTimeSeriesFactory::CSVConfig::Builder::adoptHeaderMap(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>> CSVTimeSeriesFactory::CSVConfig::Builder::disownHeaderMap() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::int16_t CSVTimeSeriesFactory::CSVConfig::Reader::getSkipLinesToHeader() const {
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int16_t CSVTimeSeriesFactory::CSVConfig::Builder::getSkipLinesToHeader() {
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void CSVTimeSeriesFactory::CSVConfig::Builder::setSkipLinesToHeader( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int16_t CSVTimeSeriesFactory::CSVConfig::Reader::getSkipLinesFromHeaderToData() const {
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 1);
}

inline  ::int16_t CSVTimeSeriesFactory::CSVConfig::Builder::getSkipLinesFromHeaderToData() {
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 1);
}
inline void CSVTimeSeriesFactory::CSVConfig::Builder::setSkipLinesFromHeaderToData( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value, 1);
}

inline bool CSVTimeSeriesFactory::CreateParams::Reader::hasCsvData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CSVTimeSeriesFactory::CreateParams::Builder::hasCsvData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader CSVTimeSeriesFactory::CreateParams::Reader::getCsvData() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder CSVTimeSeriesFactory::CreateParams::Builder::getCsvData() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CSVTimeSeriesFactory::CreateParams::Builder::setCsvData( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder CSVTimeSeriesFactory::CreateParams::Builder::initCsvData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void CSVTimeSeriesFactory::CreateParams::Builder::adoptCsvData(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> CSVTimeSeriesFactory::CreateParams::Builder::disownCsvData() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool CSVTimeSeriesFactory::CreateParams::Reader::hasConfig() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool CSVTimeSeriesFactory::CreateParams::Builder::hasConfig() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::climate::CSVTimeSeriesFactory::CSVConfig::Reader CSVTimeSeriesFactory::CreateParams::Reader::getConfig() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::CSVTimeSeriesFactory::CSVConfig>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::CSVTimeSeriesFactory::CSVConfig::Builder CSVTimeSeriesFactory::CreateParams::Builder::getConfig() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::CSVTimeSeriesFactory::CSVConfig>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::climate::CSVTimeSeriesFactory::CSVConfig::Pipeline CSVTimeSeriesFactory::CreateParams::Pipeline::getConfig() {
  return  ::mas::schema::climate::CSVTimeSeriesFactory::CSVConfig::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void CSVTimeSeriesFactory::CreateParams::Builder::setConfig( ::mas::schema::climate::CSVTimeSeriesFactory::CSVConfig::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::CSVTimeSeriesFactory::CSVConfig>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::climate::CSVTimeSeriesFactory::CSVConfig::Builder CSVTimeSeriesFactory::CreateParams::Builder::initConfig() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::CSVTimeSeriesFactory::CSVConfig>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CSVTimeSeriesFactory::CreateParams::Builder::adoptConfig(
    ::capnp::Orphan< ::mas::schema::climate::CSVTimeSeriesFactory::CSVConfig>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::CSVTimeSeriesFactory::CSVConfig>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::climate::CSVTimeSeriesFactory::CSVConfig> CSVTimeSeriesFactory::CreateParams::Builder::disownConfig() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::CSVTimeSeriesFactory::CSVConfig>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool CSVTimeSeriesFactory::CreateResults::Reader::hasTimeseries() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CSVTimeSeriesFactory::CreateResults::Builder::hasTimeseries() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::climate::TimeSeries::Client CSVTimeSeriesFactory::CreateResults::Reader::getTimeseries() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::TimeSeries::Client CSVTimeSeriesFactory::CreateResults::Builder::getTimeseries() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::TimeSeries::Client CSVTimeSeriesFactory::CreateResults::Pipeline::getTimeseries() {
  return  ::mas::schema::climate::TimeSeries::Client(_typeless.getPointerField(0).asCap());
}
inline void CSVTimeSeriesFactory::CreateResults::Builder::setTimeseries( ::mas::schema::climate::TimeSeries::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void CSVTimeSeriesFactory::CreateResults::Builder::setTimeseries( ::mas::schema::climate::TimeSeries::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void CSVTimeSeriesFactory::CreateResults::Builder::adoptTimeseries(
    ::capnp::Orphan< ::mas::schema::climate::TimeSeries>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::climate::TimeSeries> CSVTimeSeriesFactory::CreateResults::Builder::disownTimeseries() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool CSVTimeSeriesFactory::CreateResults::Reader::hasError() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool CSVTimeSeriesFactory::CreateResults::Builder::hasError() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader CSVTimeSeriesFactory::CreateResults::Reader::getError() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder CSVTimeSeriesFactory::CreateResults::Builder::getError() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CSVTimeSeriesFactory::CreateResults::Builder::setError( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder CSVTimeSeriesFactory::CreateResults::Builder::initError(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void CSVTimeSeriesFactory::CreateResults::Builder::adoptError(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> CSVTimeSeriesFactory::CreateResults::Builder::disownError() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline AlterTimeSeriesWrapper::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline AlterTimeSeriesWrapper::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline AlterTimeSeriesWrapper::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline AlterTimeSeriesWrapper::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline AlterTimeSeriesWrapper::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::climate::AlterTimeSeriesWrapper::Client& AlterTimeSeriesWrapper::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::climate::AlterTimeSeriesWrapper::Client& AlterTimeSeriesWrapper::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline  ::mas::schema::climate::Element AlterTimeSeriesWrapper::Altered::Reader::getElement() const {
  return _reader.getDataField< ::mas::schema::climate::Element>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::climate::Element AlterTimeSeriesWrapper::Altered::Builder::getElement() {
  return _builder.getDataField< ::mas::schema::climate::Element>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AlterTimeSeriesWrapper::Altered::Builder::setElement( ::mas::schema::climate::Element value) {
  _builder.setDataField< ::mas::schema::climate::Element>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float AlterTimeSeriesWrapper::Altered::Reader::getValue() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float AlterTimeSeriesWrapper::Altered::Builder::getValue() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void AlterTimeSeriesWrapper::Altered::Builder::setValue(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::mas::schema::climate::AlterTimeSeriesWrapper::AlterType AlterTimeSeriesWrapper::Altered::Reader::getType() const {
  return _reader.getDataField< ::mas::schema::climate::AlterTimeSeriesWrapper::AlterType>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::climate::AlterTimeSeriesWrapper::AlterType AlterTimeSeriesWrapper::Altered::Builder::getType() {
  return _builder.getDataField< ::mas::schema::climate::AlterTimeSeriesWrapper::AlterType>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void AlterTimeSeriesWrapper::Altered::Builder::setType( ::mas::schema::climate::AlterTimeSeriesWrapper::AlterType value) {
  _builder.setDataField< ::mas::schema::climate::AlterTimeSeriesWrapper::AlterType>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool AlterTimeSeriesWrapper::WrappedTimeSeriesResults::Reader::hasTimeSeries() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AlterTimeSeriesWrapper::WrappedTimeSeriesResults::Builder::hasTimeSeries() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::climate::TimeSeries::Client AlterTimeSeriesWrapper::WrappedTimeSeriesResults::Reader::getTimeSeries() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::TimeSeries::Client AlterTimeSeriesWrapper::WrappedTimeSeriesResults::Builder::getTimeSeries() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::TimeSeries::Client AlterTimeSeriesWrapper::WrappedTimeSeriesResults::Pipeline::getTimeSeries() {
  return  ::mas::schema::climate::TimeSeries::Client(_typeless.getPointerField(0).asCap());
}
inline void AlterTimeSeriesWrapper::WrappedTimeSeriesResults::Builder::setTimeSeries( ::mas::schema::climate::TimeSeries::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void AlterTimeSeriesWrapper::WrappedTimeSeriesResults::Builder::setTimeSeries( ::mas::schema::climate::TimeSeries::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void AlterTimeSeriesWrapper::WrappedTimeSeriesResults::Builder::adoptTimeSeries(
    ::capnp::Orphan< ::mas::schema::climate::TimeSeries>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::climate::TimeSeries> AlterTimeSeriesWrapper::WrappedTimeSeriesResults::Builder::disownTimeSeries() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool AlterTimeSeriesWrapper::AlteredElementsResults::Reader::hasList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AlterTimeSeriesWrapper::AlteredElementsResults::Builder::hasList() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered,  ::capnp::Kind::STRUCT>::Reader AlterTimeSeriesWrapper::AlteredElementsResults::Reader::getList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered,  ::capnp::Kind::STRUCT>::Builder AlterTimeSeriesWrapper::AlteredElementsResults::Builder::getList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AlterTimeSeriesWrapper::AlteredElementsResults::Builder::setList( ::capnp::List< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered,  ::capnp::Kind::STRUCT>::Builder AlterTimeSeriesWrapper::AlteredElementsResults::Builder::initList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void AlterTimeSeriesWrapper::AlteredElementsResults::Builder::adoptList(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered,  ::capnp::Kind::STRUCT>> AlterTimeSeriesWrapper::AlteredElementsResults::Builder::disownList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool AlterTimeSeriesWrapper::AlterParams::Reader::hasDesc() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AlterTimeSeriesWrapper::AlterParams::Builder::hasDesc() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::climate::AlterTimeSeriesWrapper::Altered::Reader AlterTimeSeriesWrapper::AlterParams::Reader::getDesc() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::AlterTimeSeriesWrapper::Altered::Builder AlterTimeSeriesWrapper::AlterParams::Builder::getDesc() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::climate::AlterTimeSeriesWrapper::Altered::Pipeline AlterTimeSeriesWrapper::AlterParams::Pipeline::getDesc() {
  return  ::mas::schema::climate::AlterTimeSeriesWrapper::Altered::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void AlterTimeSeriesWrapper::AlterParams::Builder::setDesc( ::mas::schema::climate::AlterTimeSeriesWrapper::Altered::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::climate::AlterTimeSeriesWrapper::Altered::Builder AlterTimeSeriesWrapper::AlterParams::Builder::initDesc() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AlterTimeSeriesWrapper::AlterParams::Builder::adoptDesc(
    ::capnp::Orphan< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered> AlterTimeSeriesWrapper::AlterParams::Builder::disownDesc() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::AlterTimeSeriesWrapper::Altered>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool AlterTimeSeriesWrapper::AlterParams::Reader::getAsNewTimeSeries() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool AlterTimeSeriesWrapper::AlterParams::Builder::getAsNewTimeSeries() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AlterTimeSeriesWrapper::AlterParams::Builder::setAsNewTimeSeries(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool AlterTimeSeriesWrapper::AlterResults::Reader::hasTimeSeries() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AlterTimeSeriesWrapper::AlterResults::Builder::hasTimeSeries() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::climate::TimeSeries::Client AlterTimeSeriesWrapper::AlterResults::Reader::getTimeSeries() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::TimeSeries::Client AlterTimeSeriesWrapper::AlterResults::Builder::getTimeSeries() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::TimeSeries::Client AlterTimeSeriesWrapper::AlterResults::Pipeline::getTimeSeries() {
  return  ::mas::schema::climate::TimeSeries::Client(_typeless.getPointerField(0).asCap());
}
inline void AlterTimeSeriesWrapper::AlterResults::Builder::setTimeSeries( ::mas::schema::climate::TimeSeries::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void AlterTimeSeriesWrapper::AlterResults::Builder::setTimeSeries( ::mas::schema::climate::TimeSeries::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void AlterTimeSeriesWrapper::AlterResults::Builder::adoptTimeSeries(
    ::capnp::Orphan< ::mas::schema::climate::TimeSeries>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::climate::TimeSeries> AlterTimeSeriesWrapper::AlterResults::Builder::disownTimeSeries() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline  ::mas::schema::climate::Element AlterTimeSeriesWrapper::RemoveParams::Reader::getAlteredElement() const {
  return _reader.getDataField< ::mas::schema::climate::Element>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::climate::Element AlterTimeSeriesWrapper::RemoveParams::Builder::getAlteredElement() {
  return _builder.getDataField< ::mas::schema::climate::Element>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AlterTimeSeriesWrapper::RemoveParams::Builder::setAlteredElement( ::mas::schema::climate::Element value) {
  _builder.setDataField< ::mas::schema::climate::Element>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool AlterTimeSeriesWrapper::ReplaceWrappedTimeSeriesParams::Reader::hasTimeSeries() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AlterTimeSeriesWrapper::ReplaceWrappedTimeSeriesParams::Builder::hasTimeSeries() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::climate::TimeSeries::Client AlterTimeSeriesWrapper::ReplaceWrappedTimeSeriesParams::Reader::getTimeSeries() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::TimeSeries::Client AlterTimeSeriesWrapper::ReplaceWrappedTimeSeriesParams::Builder::getTimeSeries() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::TimeSeries::Client AlterTimeSeriesWrapper::ReplaceWrappedTimeSeriesParams::Pipeline::getTimeSeries() {
  return  ::mas::schema::climate::TimeSeries::Client(_typeless.getPointerField(0).asCap());
}
inline void AlterTimeSeriesWrapper::ReplaceWrappedTimeSeriesParams::Builder::setTimeSeries( ::mas::schema::climate::TimeSeries::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void AlterTimeSeriesWrapper::ReplaceWrappedTimeSeriesParams::Builder::setTimeSeries( ::mas::schema::climate::TimeSeries::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void AlterTimeSeriesWrapper::ReplaceWrappedTimeSeriesParams::Builder::adoptTimeSeries(
    ::capnp::Orphan< ::mas::schema::climate::TimeSeries>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::climate::TimeSeries> AlterTimeSeriesWrapper::ReplaceWrappedTimeSeriesParams::Builder::disownTimeSeries() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
inline AlterTimeSeriesWrapperFactory::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline AlterTimeSeriesWrapperFactory::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline AlterTimeSeriesWrapperFactory::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline AlterTimeSeriesWrapperFactory::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline AlterTimeSeriesWrapperFactory::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::climate::AlterTimeSeriesWrapperFactory::Client& AlterTimeSeriesWrapperFactory::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::climate::AlterTimeSeriesWrapperFactory::Client& AlterTimeSeriesWrapperFactory::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool AlterTimeSeriesWrapperFactory::WrapParams::Reader::hasTimeSeries() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AlterTimeSeriesWrapperFactory::WrapParams::Builder::hasTimeSeries() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::climate::TimeSeries::Client AlterTimeSeriesWrapperFactory::WrapParams::Reader::getTimeSeries() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::TimeSeries::Client AlterTimeSeriesWrapperFactory::WrapParams::Builder::getTimeSeries() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::TimeSeries::Client AlterTimeSeriesWrapperFactory::WrapParams::Pipeline::getTimeSeries() {
  return  ::mas::schema::climate::TimeSeries::Client(_typeless.getPointerField(0).asCap());
}
inline void AlterTimeSeriesWrapperFactory::WrapParams::Builder::setTimeSeries( ::mas::schema::climate::TimeSeries::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void AlterTimeSeriesWrapperFactory::WrapParams::Builder::setTimeSeries( ::mas::schema::climate::TimeSeries::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void AlterTimeSeriesWrapperFactory::WrapParams::Builder::adoptTimeSeries(
    ::capnp::Orphan< ::mas::schema::climate::TimeSeries>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::climate::TimeSeries> AlterTimeSeriesWrapperFactory::WrapParams::Builder::disownTimeSeries() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool AlterTimeSeriesWrapperFactory::WrapResults::Reader::hasWrapper() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AlterTimeSeriesWrapperFactory::WrapResults::Builder::hasWrapper() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::climate::AlterTimeSeriesWrapper::Client AlterTimeSeriesWrapperFactory::WrapResults::Reader::getWrapper() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::AlterTimeSeriesWrapper>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::AlterTimeSeriesWrapper::Client AlterTimeSeriesWrapperFactory::WrapResults::Builder::getWrapper() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::AlterTimeSeriesWrapper>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::AlterTimeSeriesWrapper::Client AlterTimeSeriesWrapperFactory::WrapResults::Pipeline::getWrapper() {
  return  ::mas::schema::climate::AlterTimeSeriesWrapper::Client(_typeless.getPointerField(0).asCap());
}
inline void AlterTimeSeriesWrapperFactory::WrapResults::Builder::setWrapper( ::mas::schema::climate::AlterTimeSeriesWrapper::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::AlterTimeSeriesWrapper>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void AlterTimeSeriesWrapperFactory::WrapResults::Builder::setWrapper( ::mas::schema::climate::AlterTimeSeriesWrapper::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::AlterTimeSeriesWrapper>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void AlterTimeSeriesWrapperFactory::WrapResults::Builder::adoptWrapper(
    ::capnp::Orphan< ::mas::schema::climate::AlterTimeSeriesWrapper>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::AlterTimeSeriesWrapper>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::climate::AlterTimeSeriesWrapper> AlterTimeSeriesWrapperFactory::WrapResults::Builder::disownWrapper() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::AlterTimeSeriesWrapper>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

