// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: soil.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1000002
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "common.capnp.h"
#include "geo.capnp.h"
#include "persistence.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(c2e4a3c8ff61b40a);
enum class SType_c2e4a3c8ff61b40a: uint16_t {
  UNKNOWN,
  KA5,
};
CAPNP_DECLARE_ENUM(SType, c2e4a3c8ff61b40a);
CAPNP_DECLARE_SCHEMA(9e391ae1c6cd2567);
enum class PropertyName_9e391ae1c6cd2567: uint16_t {
  SOIL_TYPE,
  SAND,
  CLAY,
  SILT,
  P_H,
  SCELETON,
  ORGANIC_CARBON,
  ORGANIC_MATTER,
  BULK_DENSITY,
  RAW_DENSITY,
  FIELD_CAPACITY,
  PERMANENT_WILTING_POINT,
  SATURATION,
  SOIL_MOISTURE,
  SOIL_WATER_CONDUCTIVITY_COEFFICIENT,
  AMMONIUM,
  NITRATE,
  CN_RATIO,
  IN_GROUNDWATER,
  IMPENETRABLE,
};
CAPNP_DECLARE_ENUM(PropertyName, 9e391ae1c6cd2567);
CAPNP_DECLARE_SCHEMA(984640f05b3ada4f);
CAPNP_DECLARE_SCHEMA(92f4b81bcfdb71b0);
CAPNP_DECLARE_SCHEMA(bd4065087e22ca0d);
CAPNP_DECLARE_SCHEMA(bf4e1b07ad88943f);
CAPNP_DECLARE_SCHEMA(df4bbf1c883a8790);
CAPNP_DECLARE_SCHEMA(ff67c2a593419c29);
CAPNP_DECLARE_SCHEMA(e704b695746374e2);
CAPNP_DECLARE_SCHEMA(8d2a23f8fd1b9151);
CAPNP_DECLARE_SCHEMA(a09aa71427dc64e1);
CAPNP_DECLARE_SCHEMA(f4f8ab568ffbc939);
CAPNP_DECLARE_SCHEMA(81da248df613bc05);
CAPNP_DECLARE_SCHEMA(9f7ae4c2748bddf8);
CAPNP_DECLARE_SCHEMA(8dec5fd8eb3e7c27);
CAPNP_DECLARE_SCHEMA(98a2bf8e6ad97ee3);
CAPNP_DECLARE_SCHEMA(db97e739bf9693c1);
CAPNP_DECLARE_SCHEMA(a0915e668c9317ad);
CAPNP_DECLARE_SCHEMA(d1a74147c92b7957);

}  // namespace schemas
}  // namespace capnp

namespace mas {
namespace schema {
namespace soil {

typedef ::capnp::schemas::SType_c2e4a3c8ff61b40a SType;

typedef ::capnp::schemas::PropertyName_9e391ae1c6cd2567 PropertyName;

struct Layer {
  Layer() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Property;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(984640f05b3ada4f, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Layer::Property {
  Property() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    F32_VALUE,
    B_VALUE,
    TYPE,
    UNSET,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(92f4b81bcfdb71b0, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Query {
  Query() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Result;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bd4065087e22ca0d, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Query::Result {
  Result() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bf4e1b07ad88943f, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ProfileData {
  ProfileData() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(df4bbf1c883a8790, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Profile {
  Profile() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct DataParams;
  struct GeoLocationParams;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(ff67c2a593419c29)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Profile::DataParams {
  DataParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e704b695746374e2, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Profile::GeoLocationParams {
  GeoLocationParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8d2a23f8fd1b9151, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Service {
  Service() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct Stream;
  struct GetAllAvailableParametersParams;
  struct GetAllAvailableParametersResults;
  struct ClosestProfilesAtParams;
  struct ClosestProfilesAtResults;
  struct StreamAllProfilesResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(a09aa71427dc64e1)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Service::Stream {
  Stream() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct NextProfilesParams;
  struct NextProfilesResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(f4f8ab568ffbc939)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Service::Stream::NextProfilesParams {
  NextProfilesParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(81da248df613bc05, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Service::Stream::NextProfilesResults {
  NextProfilesResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9f7ae4c2748bddf8, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Service::GetAllAvailableParametersParams {
  GetAllAvailableParametersParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8dec5fd8eb3e7c27, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Service::GetAllAvailableParametersResults {
  GetAllAvailableParametersResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(98a2bf8e6ad97ee3, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Service::ClosestProfilesAtParams {
  ClosestProfilesAtParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(db97e739bf9693c1, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Service::ClosestProfilesAtResults {
  ClosestProfilesAtResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a0915e668c9317ad, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Service::StreamAllProfilesResults {
  StreamAllProfilesResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d1a74147c92b7957, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Layer::Reader {
public:
  typedef Layer Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasProperties() const;
  inline  ::capnp::List< ::mas::schema::soil::Layer::Property,  ::capnp::Kind::STRUCT>::Reader getProperties() const;

  inline float getSize() const;

  inline bool hasDescription() const;
  inline  ::capnp::Text::Reader getDescription() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Layer::Builder {
public:
  typedef Layer Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasProperties();
  inline  ::capnp::List< ::mas::schema::soil::Layer::Property,  ::capnp::Kind::STRUCT>::Builder getProperties();
  inline void setProperties( ::capnp::List< ::mas::schema::soil::Layer::Property,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::soil::Layer::Property,  ::capnp::Kind::STRUCT>::Builder initProperties(unsigned int size);
  inline void adoptProperties(::capnp::Orphan< ::capnp::List< ::mas::schema::soil::Layer::Property,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::Layer::Property,  ::capnp::Kind::STRUCT>> disownProperties();

  inline float getSize();
  inline void setSize(float value);

  inline bool hasDescription();
  inline  ::capnp::Text::Builder getDescription();
  inline void setDescription( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initDescription(unsigned int size);
  inline void adoptDescription(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownDescription();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Layer::Pipeline {
public:
  typedef Layer Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Layer::Property::Reader {
public:
  typedef Property Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline  ::mas::schema::soil::PropertyName getName() const;

  inline bool isF32Value() const;
  inline float getF32Value() const;

  inline bool isBValue() const;
  inline bool getBValue() const;

  inline bool isType() const;
  inline bool hasType() const;
  inline  ::capnp::Text::Reader getType() const;

  inline bool isUnset() const;
  inline  ::capnp::Void getUnset() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Layer::Property::Builder {
public:
  typedef Property Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline  ::mas::schema::soil::PropertyName getName();
  inline void setName( ::mas::schema::soil::PropertyName value);

  inline bool isF32Value();
  inline float getF32Value();
  inline void setF32Value(float value);

  inline bool isBValue();
  inline bool getBValue();
  inline void setBValue(bool value);

  inline bool isType();
  inline bool hasType();
  inline  ::capnp::Text::Builder getType();
  inline void setType( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initType(unsigned int size);
  inline void adoptType(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownType();

  inline bool isUnset();
  inline  ::capnp::Void getUnset();
  inline void setUnset( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Layer::Property::Pipeline {
public:
  typedef Property Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Query::Reader {
public:
  typedef Query Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasMandatory() const;
  inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Reader getMandatory() const;

  inline bool hasOptional() const;
  inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Reader getOptional() const;

  inline bool getOnlyRawData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Query::Builder {
public:
  typedef Query Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMandatory();
  inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Builder getMandatory();
  inline void setMandatory( ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Reader value);
  inline void setMandatory(::kj::ArrayPtr<const  ::mas::schema::soil::PropertyName> value);
  inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Builder initMandatory(unsigned int size);
  inline void adoptMandatory(::capnp::Orphan< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>> disownMandatory();

  inline bool hasOptional();
  inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Builder getOptional();
  inline void setOptional( ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Reader value);
  inline void setOptional(::kj::ArrayPtr<const  ::mas::schema::soil::PropertyName> value);
  inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Builder initOptional(unsigned int size);
  inline void adoptOptional(::capnp::Orphan< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>> disownOptional();

  inline bool getOnlyRawData();
  inline void setOnlyRawData(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Query::Pipeline {
public:
  typedef Query Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Query::Result::Reader {
public:
  typedef Result Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getFailed() const;

  inline bool hasMandatory() const;
  inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Reader getMandatory() const;

  inline bool hasOptional() const;
  inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Reader getOptional() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Query::Result::Builder {
public:
  typedef Result Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getFailed();
  inline void setFailed(bool value);

  inline bool hasMandatory();
  inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Builder getMandatory();
  inline void setMandatory( ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Reader value);
  inline void setMandatory(::kj::ArrayPtr<const  ::mas::schema::soil::PropertyName> value);
  inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Builder initMandatory(unsigned int size);
  inline void adoptMandatory(::capnp::Orphan< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>> disownMandatory();

  inline bool hasOptional();
  inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Builder getOptional();
  inline void setOptional( ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Reader value);
  inline void setOptional(::kj::ArrayPtr<const  ::mas::schema::soil::PropertyName> value);
  inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Builder initOptional(unsigned int size);
  inline void adoptOptional(::capnp::Orphan< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>> disownOptional();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Query::Result::Pipeline {
public:
  typedef Result Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ProfileData::Reader {
public:
  typedef ProfileData Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLayers() const;
  inline  ::capnp::List< ::mas::schema::soil::Layer,  ::capnp::Kind::STRUCT>::Reader getLayers() const;

  inline float getPercentageOfArea() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ProfileData::Builder {
public:
  typedef ProfileData Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLayers();
  inline  ::capnp::List< ::mas::schema::soil::Layer,  ::capnp::Kind::STRUCT>::Builder getLayers();
  inline void setLayers( ::capnp::List< ::mas::schema::soil::Layer,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::soil::Layer,  ::capnp::Kind::STRUCT>::Builder initLayers(unsigned int size);
  inline void adoptLayers(::capnp::Orphan< ::capnp::List< ::mas::schema::soil::Layer,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::Layer,  ::capnp::Kind::STRUCT>> disownLayers();

  inline float getPercentageOfArea();
  inline void setPercentageOfArea(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ProfileData::Pipeline {
public:
  typedef ProfileData Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Profile::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client,
      public virtual  ::mas::schema::persistence::Persistent::Client {
public:
  typedef Profile Calls;
  typedef Profile Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::soil::Profile::DataParams,  ::mas::schema::soil::ProfileData> dataRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::soil::Profile::GeoLocationParams,  ::mas::schema::geo::LatLonCoord> geoLocationRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Profile::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server,
      public virtual  ::mas::schema::persistence::Persistent::Server {
public:
  typedef Profile Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::soil::Profile::DataParams DataParams;
  typedef ::capnp::CallContext<DataParams,  ::mas::schema::soil::ProfileData> DataContext;
  virtual ::kj::Promise<void> data(DataContext context);
  typedef  ::mas::schema::soil::Profile::GeoLocationParams GeoLocationParams;
  typedef ::capnp::CallContext<GeoLocationParams,  ::mas::schema::geo::LatLonCoord> GeoLocationContext;
  virtual ::kj::Promise<void> geoLocation(GeoLocationContext context);

  inline  ::mas::schema::soil::Profile::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::soil::Profile>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Profile::DataParams::Reader {
public:
  typedef DataParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Profile::DataParams::Builder {
public:
  typedef DataParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Profile::DataParams::Pipeline {
public:
  typedef DataParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Profile::GeoLocationParams::Reader {
public:
  typedef GeoLocationParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Profile::GeoLocationParams::Builder {
public:
  typedef GeoLocationParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Profile::GeoLocationParams::Pipeline {
public:
  typedef GeoLocationParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Service::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client,
      public virtual  ::mas::schema::persistence::Persistent::Client {
public:
  typedef Service Calls;
  typedef Service Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::soil::Query,  ::mas::schema::soil::Query::Result> checkAvailableParametersRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::soil::Service::GetAllAvailableParametersParams,  ::mas::schema::soil::Service::GetAllAvailableParametersResults> getAllAvailableParametersRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::soil::Service::ClosestProfilesAtParams,  ::mas::schema::soil::Service::ClosestProfilesAtResults> closestProfilesAtRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::soil::Query,  ::mas::schema::soil::Service::StreamAllProfilesResults> streamAllProfilesRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Service::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server,
      public virtual  ::mas::schema::persistence::Persistent::Server {
public:
  typedef Service Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef ::capnp::CallContext< ::mas::schema::soil::Query,  ::mas::schema::soil::Query::Result> CheckAvailableParametersContext;
  virtual ::kj::Promise<void> checkAvailableParameters(CheckAvailableParametersContext context);
  typedef  ::mas::schema::soil::Service::GetAllAvailableParametersParams GetAllAvailableParametersParams;
  typedef  ::mas::schema::soil::Service::GetAllAvailableParametersResults GetAllAvailableParametersResults;
  typedef ::capnp::CallContext<GetAllAvailableParametersParams, GetAllAvailableParametersResults> GetAllAvailableParametersContext;
  virtual ::kj::Promise<void> getAllAvailableParameters(GetAllAvailableParametersContext context);
  typedef  ::mas::schema::soil::Service::ClosestProfilesAtParams ClosestProfilesAtParams;
  typedef  ::mas::schema::soil::Service::ClosestProfilesAtResults ClosestProfilesAtResults;
  typedef ::capnp::CallContext<ClosestProfilesAtParams, ClosestProfilesAtResults> ClosestProfilesAtContext;
  virtual ::kj::Promise<void> closestProfilesAt(ClosestProfilesAtContext context);
  typedef  ::mas::schema::soil::Service::StreamAllProfilesResults StreamAllProfilesResults;
  typedef ::capnp::CallContext< ::mas::schema::soil::Query, StreamAllProfilesResults> StreamAllProfilesContext;
  virtual ::kj::Promise<void> streamAllProfiles(StreamAllProfilesContext context);

  inline  ::mas::schema::soil::Service::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::soil::Service>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Service::Stream::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Stream Calls;
  typedef Stream Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::soil::Service::Stream::NextProfilesParams,  ::mas::schema::soil::Service::Stream::NextProfilesResults> nextProfilesRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Service::Stream::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Stream Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::soil::Service::Stream::NextProfilesParams NextProfilesParams;
  typedef  ::mas::schema::soil::Service::Stream::NextProfilesResults NextProfilesResults;
  typedef ::capnp::CallContext<NextProfilesParams, NextProfilesResults> NextProfilesContext;
  virtual ::kj::Promise<void> nextProfiles(NextProfilesContext context);

  inline  ::mas::schema::soil::Service::Stream::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::soil::Service::Stream>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Service::Stream::NextProfilesParams::Reader {
public:
  typedef NextProfilesParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int64_t getMaxCount() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Service::Stream::NextProfilesParams::Builder {
public:
  typedef NextProfilesParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int64_t getMaxCount();
  inline void setMaxCount( ::int64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Service::Stream::NextProfilesParams::Pipeline {
public:
  typedef NextProfilesParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Service::Stream::NextProfilesResults::Reader {
public:
  typedef NextProfilesResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasProfiles() const;
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>::Reader getProfiles() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Service::Stream::NextProfilesResults::Builder {
public:
  typedef NextProfilesResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasProfiles();
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>::Builder getProfiles();
  inline void setProfiles( ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>::Reader value);
  inline  ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>::Builder initProfiles(unsigned int size);
  inline void adoptProfiles(::capnp::Orphan< ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>> disownProfiles();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Service::Stream::NextProfilesResults::Pipeline {
public:
  typedef NextProfilesResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Service::GetAllAvailableParametersParams::Reader {
public:
  typedef GetAllAvailableParametersParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getOnlyRawData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Service::GetAllAvailableParametersParams::Builder {
public:
  typedef GetAllAvailableParametersParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getOnlyRawData();
  inline void setOnlyRawData(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Service::GetAllAvailableParametersParams::Pipeline {
public:
  typedef GetAllAvailableParametersParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Service::GetAllAvailableParametersResults::Reader {
public:
  typedef GetAllAvailableParametersResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasMandatory() const;
  inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Reader getMandatory() const;

  inline bool hasOptional() const;
  inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Reader getOptional() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Service::GetAllAvailableParametersResults::Builder {
public:
  typedef GetAllAvailableParametersResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMandatory();
  inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Builder getMandatory();
  inline void setMandatory( ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Reader value);
  inline void setMandatory(::kj::ArrayPtr<const  ::mas::schema::soil::PropertyName> value);
  inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Builder initMandatory(unsigned int size);
  inline void adoptMandatory(::capnp::Orphan< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>> disownMandatory();

  inline bool hasOptional();
  inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Builder getOptional();
  inline void setOptional( ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Reader value);
  inline void setOptional(::kj::ArrayPtr<const  ::mas::schema::soil::PropertyName> value);
  inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Builder initOptional(unsigned int size);
  inline void adoptOptional(::capnp::Orphan< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>> disownOptional();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Service::GetAllAvailableParametersResults::Pipeline {
public:
  typedef GetAllAvailableParametersResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Service::ClosestProfilesAtParams::Reader {
public:
  typedef ClosestProfilesAtParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCoord() const;
  inline  ::mas::schema::geo::LatLonCoord::Reader getCoord() const;

  inline bool hasQuery() const;
  inline  ::mas::schema::soil::Query::Reader getQuery() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Service::ClosestProfilesAtParams::Builder {
public:
  typedef ClosestProfilesAtParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCoord();
  inline  ::mas::schema::geo::LatLonCoord::Builder getCoord();
  inline void setCoord( ::mas::schema::geo::LatLonCoord::Reader value);
  inline  ::mas::schema::geo::LatLonCoord::Builder initCoord();
  inline void adoptCoord(::capnp::Orphan< ::mas::schema::geo::LatLonCoord>&& value);
  inline ::capnp::Orphan< ::mas::schema::geo::LatLonCoord> disownCoord();

  inline bool hasQuery();
  inline  ::mas::schema::soil::Query::Builder getQuery();
  inline void setQuery( ::mas::schema::soil::Query::Reader value);
  inline  ::mas::schema::soil::Query::Builder initQuery();
  inline void adoptQuery(::capnp::Orphan< ::mas::schema::soil::Query>&& value);
  inline ::capnp::Orphan< ::mas::schema::soil::Query> disownQuery();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Service::ClosestProfilesAtParams::Pipeline {
public:
  typedef ClosestProfilesAtParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::geo::LatLonCoord::Pipeline getCoord();
  inline  ::mas::schema::soil::Query::Pipeline getQuery();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Service::ClosestProfilesAtResults::Reader {
public:
  typedef ClosestProfilesAtResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasProfiles() const;
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>::Reader getProfiles() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Service::ClosestProfilesAtResults::Builder {
public:
  typedef ClosestProfilesAtResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasProfiles();
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>::Builder getProfiles();
  inline void setProfiles( ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>::Reader value);
  inline  ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>::Builder initProfiles(unsigned int size);
  inline void adoptProfiles(::capnp::Orphan< ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>> disownProfiles();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Service::ClosestProfilesAtResults::Pipeline {
public:
  typedef ClosestProfilesAtResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Service::StreamAllProfilesResults::Reader {
public:
  typedef StreamAllProfilesResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasAllProfiles() const;
#if !CAPNP_LITE
  inline  ::mas::schema::soil::Service::Stream::Client getAllProfiles() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Service::StreamAllProfilesResults::Builder {
public:
  typedef StreamAllProfilesResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasAllProfiles();
#if !CAPNP_LITE
  inline  ::mas::schema::soil::Service::Stream::Client getAllProfiles();
  inline void setAllProfiles( ::mas::schema::soil::Service::Stream::Client&& value);
  inline void setAllProfiles( ::mas::schema::soil::Service::Stream::Client& value);
  inline void adoptAllProfiles(::capnp::Orphan< ::mas::schema::soil::Service::Stream>&& value);
  inline ::capnp::Orphan< ::mas::schema::soil::Service::Stream> disownAllProfiles();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Service::StreamAllProfilesResults::Pipeline {
public:
  typedef StreamAllProfilesResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::soil::Service::Stream::Client getAllProfiles();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline bool Layer::Reader::hasProperties() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Layer::Builder::hasProperties() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::soil::Layer::Property,  ::capnp::Kind::STRUCT>::Reader Layer::Reader::getProperties() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::Layer::Property,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::soil::Layer::Property,  ::capnp::Kind::STRUCT>::Builder Layer::Builder::getProperties() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::Layer::Property,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Layer::Builder::setProperties( ::capnp::List< ::mas::schema::soil::Layer::Property,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::Layer::Property,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::soil::Layer::Property,  ::capnp::Kind::STRUCT>::Builder Layer::Builder::initProperties(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::Layer::Property,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Layer::Builder::adoptProperties(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::Layer::Property,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::Layer::Property,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::Layer::Property,  ::capnp::Kind::STRUCT>> Layer::Builder::disownProperties() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::Layer::Property,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float Layer::Reader::getSize() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Layer::Builder::getSize() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Layer::Builder::setSize(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Layer::Reader::hasDescription() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Layer::Builder::hasDescription() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Layer::Reader::getDescription() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Layer::Builder::getDescription() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Layer::Builder::setDescription( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Layer::Builder::initDescription(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Layer::Builder::adoptDescription(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Layer::Builder::disownDescription() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::mas::schema::soil::Layer::Property::Which Layer::Property::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline  ::mas::schema::soil::Layer::Property::Which Layer::Property::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::soil::PropertyName Layer::Property::Reader::getName() const {
  return _reader.getDataField< ::mas::schema::soil::PropertyName>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::soil::PropertyName Layer::Property::Builder::getName() {
  return _builder.getDataField< ::mas::schema::soil::PropertyName>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Layer::Property::Builder::setName( ::mas::schema::soil::PropertyName value) {
  _builder.setDataField< ::mas::schema::soil::PropertyName>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Layer::Property::Reader::isF32Value() const {
  return which() == Layer::Property::F32_VALUE;
}
inline bool Layer::Property::Builder::isF32Value() {
  return which() == Layer::Property::F32_VALUE;
}
inline float Layer::Property::Reader::getF32Value() const {
  KJ_IREQUIRE((which() == Layer::Property::F32_VALUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Layer::Property::Builder::getF32Value() {
  KJ_IREQUIRE((which() == Layer::Property::F32_VALUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Layer::Property::Builder::setF32Value(float value) {
  _builder.setDataField<Layer::Property::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Layer::Property::F32_VALUE);
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Layer::Property::Reader::isBValue() const {
  return which() == Layer::Property::B_VALUE;
}
inline bool Layer::Property::Builder::isBValue() {
  return which() == Layer::Property::B_VALUE;
}
inline bool Layer::Property::Reader::getBValue() const {
  KJ_IREQUIRE((which() == Layer::Property::B_VALUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS);
}

inline bool Layer::Property::Builder::getBValue() {
  KJ_IREQUIRE((which() == Layer::Property::B_VALUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS);
}
inline void Layer::Property::Builder::setBValue(bool value) {
  _builder.setDataField<Layer::Property::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Layer::Property::B_VALUE);
  _builder.setDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS, value);
}

inline bool Layer::Property::Reader::isType() const {
  return which() == Layer::Property::TYPE;
}
inline bool Layer::Property::Builder::isType() {
  return which() == Layer::Property::TYPE;
}
inline bool Layer::Property::Reader::hasType() const {
  if (which() != Layer::Property::TYPE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Layer::Property::Builder::hasType() {
  if (which() != Layer::Property::TYPE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Layer::Property::Reader::getType() const {
  KJ_IREQUIRE((which() == Layer::Property::TYPE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Layer::Property::Builder::getType() {
  KJ_IREQUIRE((which() == Layer::Property::TYPE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Layer::Property::Builder::setType( ::capnp::Text::Reader value) {
  _builder.setDataField<Layer::Property::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Layer::Property::TYPE);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Layer::Property::Builder::initType(unsigned int size) {
  _builder.setDataField<Layer::Property::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Layer::Property::TYPE);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Layer::Property::Builder::adoptType(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<Layer::Property::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Layer::Property::TYPE);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Layer::Property::Builder::disownType() {
  KJ_IREQUIRE((which() == Layer::Property::TYPE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Layer::Property::Reader::isUnset() const {
  return which() == Layer::Property::UNSET;
}
inline bool Layer::Property::Builder::isUnset() {
  return which() == Layer::Property::UNSET;
}
inline  ::capnp::Void Layer::Property::Reader::getUnset() const {
  KJ_IREQUIRE((which() == Layer::Property::UNSET),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Layer::Property::Builder::getUnset() {
  KJ_IREQUIRE((which() == Layer::Property::UNSET),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Layer::Property::Builder::setUnset( ::capnp::Void value) {
  _builder.setDataField<Layer::Property::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Layer::Property::UNSET);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Query::Reader::hasMandatory() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Query::Builder::hasMandatory() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Reader Query::Reader::getMandatory() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Builder Query::Builder::getMandatory() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Query::Builder::setMandatory( ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Query::Builder::setMandatory(::kj::ArrayPtr<const  ::mas::schema::soil::PropertyName> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Builder Query::Builder::initMandatory(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Query::Builder::adoptMandatory(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>> Query::Builder::disownMandatory() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Query::Reader::hasOptional() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Query::Builder::hasOptional() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Reader Query::Reader::getOptional() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Builder Query::Builder::getOptional() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Query::Builder::setOptional( ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void Query::Builder::setOptional(::kj::ArrayPtr<const  ::mas::schema::soil::PropertyName> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Builder Query::Builder::initOptional(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Query::Builder::adoptOptional(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>> Query::Builder::disownOptional() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Query::Reader::getOnlyRawData() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, true);
}

inline bool Query::Builder::getOnlyRawData() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, true);
}
inline void Query::Builder::setOnlyRawData(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, true);
}

inline bool Query::Result::Reader::getFailed() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Query::Result::Builder::getFailed() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Query::Result::Builder::setFailed(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Query::Result::Reader::hasMandatory() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Query::Result::Builder::hasMandatory() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Reader Query::Result::Reader::getMandatory() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Builder Query::Result::Builder::getMandatory() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Query::Result::Builder::setMandatory( ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Query::Result::Builder::setMandatory(::kj::ArrayPtr<const  ::mas::schema::soil::PropertyName> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Builder Query::Result::Builder::initMandatory(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Query::Result::Builder::adoptMandatory(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>> Query::Result::Builder::disownMandatory() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Query::Result::Reader::hasOptional() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Query::Result::Builder::hasOptional() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Reader Query::Result::Reader::getOptional() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Builder Query::Result::Builder::getOptional() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Query::Result::Builder::setOptional( ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void Query::Result::Builder::setOptional(::kj::ArrayPtr<const  ::mas::schema::soil::PropertyName> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Builder Query::Result::Builder::initOptional(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Query::Result::Builder::adoptOptional(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>> Query::Result::Builder::disownOptional() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool ProfileData::Reader::hasLayers() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ProfileData::Builder::hasLayers() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::soil::Layer,  ::capnp::Kind::STRUCT>::Reader ProfileData::Reader::getLayers() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::Layer,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::soil::Layer,  ::capnp::Kind::STRUCT>::Builder ProfileData::Builder::getLayers() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::Layer,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ProfileData::Builder::setLayers( ::capnp::List< ::mas::schema::soil::Layer,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::Layer,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::soil::Layer,  ::capnp::Kind::STRUCT>::Builder ProfileData::Builder::initLayers(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::Layer,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ProfileData::Builder::adoptLayers(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::Layer,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::Layer,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::Layer,  ::capnp::Kind::STRUCT>> ProfileData::Builder::disownLayers() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::Layer,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float ProfileData::Reader::getPercentageOfArea() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 1120403456u);
}

inline float ProfileData::Builder::getPercentageOfArea() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 1120403456u);
}
inline void ProfileData::Builder::setPercentageOfArea(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, 1120403456u);
}

#if !CAPNP_LITE
inline Profile::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Profile::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Profile::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Profile::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Profile::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::soil::Profile::Client& Profile::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::soil::Profile::Client& Profile::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
#if !CAPNP_LITE
inline Service::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Service::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Service::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Service::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Service::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::soil::Service::Client& Service::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::soil::Service::Client& Service::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
#if !CAPNP_LITE
inline Service::Stream::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Service::Stream::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Service::Stream::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Service::Stream::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Service::Stream::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::soil::Service::Stream::Client& Service::Stream::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::soil::Service::Stream::Client& Service::Stream::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline  ::int64_t Service::Stream::NextProfilesParams::Reader::getMaxCount() const {
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 100ll);
}

inline  ::int64_t Service::Stream::NextProfilesParams::Builder::getMaxCount() {
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 100ll);
}
inline void Service::Stream::NextProfilesParams::Builder::setMaxCount( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, 100ll);
}

inline bool Service::Stream::NextProfilesResults::Reader::hasProfiles() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Service::Stream::NextProfilesResults::Builder::hasProfiles() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>::Reader Service::Stream::NextProfilesResults::Reader::getProfiles() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>::Builder Service::Stream::NextProfilesResults::Builder::getProfiles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Service::Stream::NextProfilesResults::Builder::setProfiles( ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>::Builder Service::Stream::NextProfilesResults::Builder::initProfiles(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Service::Stream::NextProfilesResults::Builder::adoptProfiles(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>> Service::Stream::NextProfilesResults::Builder::disownProfiles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Service::GetAllAvailableParametersParams::Reader::getOnlyRawData() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Service::GetAllAvailableParametersParams::Builder::getOnlyRawData() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Service::GetAllAvailableParametersParams::Builder::setOnlyRawData(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Service::GetAllAvailableParametersResults::Reader::hasMandatory() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Service::GetAllAvailableParametersResults::Builder::hasMandatory() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Reader Service::GetAllAvailableParametersResults::Reader::getMandatory() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Builder Service::GetAllAvailableParametersResults::Builder::getMandatory() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Service::GetAllAvailableParametersResults::Builder::setMandatory( ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Service::GetAllAvailableParametersResults::Builder::setMandatory(::kj::ArrayPtr<const  ::mas::schema::soil::PropertyName> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Builder Service::GetAllAvailableParametersResults::Builder::initMandatory(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Service::GetAllAvailableParametersResults::Builder::adoptMandatory(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>> Service::GetAllAvailableParametersResults::Builder::disownMandatory() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Service::GetAllAvailableParametersResults::Reader::hasOptional() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Service::GetAllAvailableParametersResults::Builder::hasOptional() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Reader Service::GetAllAvailableParametersResults::Reader::getOptional() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Builder Service::GetAllAvailableParametersResults::Builder::getOptional() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Service::GetAllAvailableParametersResults::Builder::setOptional( ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void Service::GetAllAvailableParametersResults::Builder::setOptional(::kj::ArrayPtr<const  ::mas::schema::soil::PropertyName> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>::Builder Service::GetAllAvailableParametersResults::Builder::initOptional(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Service::GetAllAvailableParametersResults::Builder::adoptOptional(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>> Service::GetAllAvailableParametersResults::Builder::disownOptional() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::PropertyName,  ::capnp::Kind::ENUM>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Service::ClosestProfilesAtParams::Reader::hasCoord() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Service::ClosestProfilesAtParams::Builder::hasCoord() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::geo::LatLonCoord::Reader Service::ClosestProfilesAtParams::Reader::getCoord() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::geo::LatLonCoord::Builder Service::ClosestProfilesAtParams::Builder::getCoord() {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::geo::LatLonCoord::Pipeline Service::ClosestProfilesAtParams::Pipeline::getCoord() {
  return  ::mas::schema::geo::LatLonCoord::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Service::ClosestProfilesAtParams::Builder::setCoord( ::mas::schema::geo::LatLonCoord::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::geo::LatLonCoord::Builder Service::ClosestProfilesAtParams::Builder::initCoord() {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Service::ClosestProfilesAtParams::Builder::adoptCoord(
    ::capnp::Orphan< ::mas::schema::geo::LatLonCoord>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::geo::LatLonCoord> Service::ClosestProfilesAtParams::Builder::disownCoord() {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Service::ClosestProfilesAtParams::Reader::hasQuery() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Service::ClosestProfilesAtParams::Builder::hasQuery() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::soil::Query::Reader Service::ClosestProfilesAtParams::Reader::getQuery() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::soil::Query>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::soil::Query::Builder Service::ClosestProfilesAtParams::Builder::getQuery() {
  return ::capnp::_::PointerHelpers< ::mas::schema::soil::Query>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::soil::Query::Pipeline Service::ClosestProfilesAtParams::Pipeline::getQuery() {
  return  ::mas::schema::soil::Query::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Service::ClosestProfilesAtParams::Builder::setQuery( ::mas::schema::soil::Query::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::soil::Query>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::soil::Query::Builder Service::ClosestProfilesAtParams::Builder::initQuery() {
  return ::capnp::_::PointerHelpers< ::mas::schema::soil::Query>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Service::ClosestProfilesAtParams::Builder::adoptQuery(
    ::capnp::Orphan< ::mas::schema::soil::Query>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::soil::Query>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::soil::Query> Service::ClosestProfilesAtParams::Builder::disownQuery() {
  return ::capnp::_::PointerHelpers< ::mas::schema::soil::Query>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Service::ClosestProfilesAtResults::Reader::hasProfiles() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Service::ClosestProfilesAtResults::Builder::hasProfiles() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>::Reader Service::ClosestProfilesAtResults::Reader::getProfiles() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>::Builder Service::ClosestProfilesAtResults::Builder::getProfiles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Service::ClosestProfilesAtResults::Builder::setProfiles( ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>::Builder Service::ClosestProfilesAtResults::Builder::initProfiles(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Service::ClosestProfilesAtResults::Builder::adoptProfiles(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>> Service::ClosestProfilesAtResults::Builder::disownProfiles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::soil::Profile,  ::capnp::Kind::INTERFACE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Service::StreamAllProfilesResults::Reader::hasAllProfiles() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Service::StreamAllProfilesResults::Builder::hasAllProfiles() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::soil::Service::Stream::Client Service::StreamAllProfilesResults::Reader::getAllProfiles() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::soil::Service::Stream>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::soil::Service::Stream::Client Service::StreamAllProfilesResults::Builder::getAllProfiles() {
  return ::capnp::_::PointerHelpers< ::mas::schema::soil::Service::Stream>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::soil::Service::Stream::Client Service::StreamAllProfilesResults::Pipeline::getAllProfiles() {
  return  ::mas::schema::soil::Service::Stream::Client(_typeless.getPointerField(0).asCap());
}
inline void Service::StreamAllProfilesResults::Builder::setAllProfiles( ::mas::schema::soil::Service::Stream::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::soil::Service::Stream>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Service::StreamAllProfilesResults::Builder::setAllProfiles( ::mas::schema::soil::Service::Stream::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::soil::Service::Stream>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Service::StreamAllProfilesResults::Builder::adoptAllProfiles(
    ::capnp::Orphan< ::mas::schema::soil::Service::Stream>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::soil::Service::Stream>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::soil::Service::Stream> Service::StreamAllProfilesResults::Builder::disownAllProfiles() {
  return ::capnp::_::PointerHelpers< ::mas::schema::soil::Service::Stream>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

