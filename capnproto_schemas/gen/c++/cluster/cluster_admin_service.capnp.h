// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: cluster_admin_service.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1000002
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "common.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(f7485d56d6f20e7d);
CAPNP_DECLARE_SCHEMA(e8b1f7a192651bbe);
CAPNP_DECLARE_SCHEMA(e1b78932a9f7aea3);
CAPNP_DECLARE_SCHEMA(bba96ef3714f338f);
CAPNP_DECLARE_SCHEMA(bf24278c65f633ce);
CAPNP_DECLARE_SCHEMA(943b54ee6f4de610);
CAPNP_DECLARE_SCHEMA(e7434f81e2b1e3de);
CAPNP_DECLARE_SCHEMA(a0669b656ba6cc8e);
CAPNP_DECLARE_SCHEMA(d4bece01a7c4008f);
CAPNP_DECLARE_SCHEMA(ec42c6df28354b60);
CAPNP_DECLARE_SCHEMA(9a80efc085eae065);
CAPNP_DECLARE_SCHEMA(b147e4fbf7081bda);
CAPNP_DECLARE_SCHEMA(f849848fea5c4776);
CAPNP_DECLARE_SCHEMA(c3668a8f7946ce88);
CAPNP_DECLARE_SCHEMA(a8dfab7b88664bd4);
CAPNP_DECLARE_SCHEMA(fe35aabe121add1a);
CAPNP_DECLARE_SCHEMA(93bdb3f5b6eecd29);
CAPNP_DECLARE_SCHEMA(9b3d2c0c5054766c);
CAPNP_DECLARE_SCHEMA(e6b2589f9a250d7f);
CAPNP_DECLARE_SCHEMA(c224b7ff6089b64e);
CAPNP_DECLARE_SCHEMA(f004ae32302172c6);
CAPNP_DECLARE_SCHEMA(b4d00b302a119de9);
CAPNP_DECLARE_SCHEMA(bcd8dd8cea624cbb);
CAPNP_DECLARE_SCHEMA(c9034ba2becc2a64);
CAPNP_DECLARE_SCHEMA(d6acf080dcf2b4c8);
CAPNP_DECLARE_SCHEMA(8ba6569cca01e84f);
CAPNP_DECLARE_SCHEMA(815e89f778f1da6c);
CAPNP_DECLARE_SCHEMA(a967c8b00a278896);
CAPNP_DECLARE_SCHEMA(ddbd9a18593be0c5);
CAPNP_DECLARE_SCHEMA(fd9959998f9f0ebe);
CAPNP_DECLARE_SCHEMA(8bf81264d2f11274);
CAPNP_DECLARE_SCHEMA(f468b1dc515f841c);
CAPNP_DECLARE_SCHEMA(985d83a2e2d7e204);
CAPNP_DECLARE_SCHEMA(bcacf6dde70da193);
CAPNP_DECLARE_SCHEMA(8b5d8251cf57c316);
CAPNP_DECLARE_SCHEMA(a81053c61d4d995c);
CAPNP_DECLARE_SCHEMA(fea4c3f998b67621);
CAPNP_DECLARE_SCHEMA(baf979a1f5673019);
CAPNP_DECLARE_SCHEMA(e4b6ea2bfbc474d8);
CAPNP_DECLARE_SCHEMA(e3cf5a40e703e6da);
CAPNP_DECLARE_SCHEMA(bea41d4487c101c4);
CAPNP_DECLARE_SCHEMA(ca8fb2a4c16e5f08);
CAPNP_DECLARE_SCHEMA(d88a3f78cce2bc7d);
CAPNP_DECLARE_SCHEMA(e5cdfbf0462c5cfd);

}  // namespace schemas
}  // namespace capnp

namespace mas {
namespace schema {
namespace cluster {

struct Cluster {
  Cluster() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Unregister;
  struct AdminMaster;
  struct UserMaster;
  struct Runtime;
  struct ZmqPipelineAddresses;
  template <typename T = ::capnp::AnyPointer>
  struct ValueHolder;
  struct ModelInstanceFactory;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f7485d56d6f20e7d, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::Unregister {
  Unregister() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct UnregisterParams;
  struct UnregisterResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(e8b1f7a192651bbe)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Cluster::Unregister::UnregisterParams {
  UnregisterParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e1b78932a9f7aea3, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::Unregister::UnregisterResults {
  UnregisterResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bba96ef3714f338f, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::AdminMaster {
  AdminMaster() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct RegisterModelInstanceFactoryParams;
  struct RegisterModelInstanceFactoryResults;
  struct AvailableModelsParams;
  struct AvailableModelsResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(bf24278c65f633ce)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Cluster::AdminMaster::RegisterModelInstanceFactoryParams {
  RegisterModelInstanceFactoryParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(943b54ee6f4de610, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::AdminMaster::RegisterModelInstanceFactoryResults {
  RegisterModelInstanceFactoryResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e7434f81e2b1e3de, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::AdminMaster::AvailableModelsParams {
  AvailableModelsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a0669b656ba6cc8e, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::AdminMaster::AvailableModelsResults {
  AvailableModelsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d4bece01a7c4008f, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::UserMaster {
  UserMaster() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct AvailableModelsParams;
  struct AvailableModelsResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(ec42c6df28354b60)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Cluster::UserMaster::AvailableModelsParams {
  AvailableModelsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9a80efc085eae065, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::UserMaster::AvailableModelsResults {
  AvailableModelsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b147e4fbf7081bda, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::Runtime {
  Runtime() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct RegisterModelInstanceFactoryParams;
  struct RegisterModelInstanceFactoryResults;
  struct AvailableModelsParams;
  struct AvailableModelsResults;
  struct NumberOfCoresParams;
  struct NumberOfCoresResults;
  struct FreeNumberOfCoresParams;
  struct FreeNumberOfCoresResults;
  struct ReserveNumberOfCoresParams;
  struct ReserveNumberOfCoresResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(f849848fea5c4776)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Cluster::Runtime::RegisterModelInstanceFactoryParams {
  RegisterModelInstanceFactoryParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c3668a8f7946ce88, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::Runtime::RegisterModelInstanceFactoryResults {
  RegisterModelInstanceFactoryResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a8dfab7b88664bd4, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::Runtime::AvailableModelsParams {
  AvailableModelsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fe35aabe121add1a, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::Runtime::AvailableModelsResults {
  AvailableModelsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(93bdb3f5b6eecd29, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::Runtime::NumberOfCoresParams {
  NumberOfCoresParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9b3d2c0c5054766c, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::Runtime::NumberOfCoresResults {
  NumberOfCoresResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e6b2589f9a250d7f, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::Runtime::FreeNumberOfCoresParams {
  FreeNumberOfCoresParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c224b7ff6089b64e, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::Runtime::FreeNumberOfCoresResults {
  FreeNumberOfCoresResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f004ae32302172c6, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::Runtime::ReserveNumberOfCoresParams {
  ReserveNumberOfCoresParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b4d00b302a119de9, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::Runtime::ReserveNumberOfCoresResults {
  ReserveNumberOfCoresResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bcd8dd8cea624cbb, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::ZmqPipelineAddresses {
  ZmqPipelineAddresses() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c9034ba2becc2a64, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct Cluster::ValueHolder {
  ValueHolder() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct ValueParams;
  struct ValueResults;
  struct ReleaseParams;
  struct ReleaseResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(d6acf080dcf2b4c8)
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
  };
  #endif  // !CAPNP_LITE
};

template <typename T>
struct Cluster::ValueHolder<T>::ValueParams {
  ValueParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8ba6569cca01e84f, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct Cluster::ValueHolder<T>::ValueResults {
  ValueResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(815e89f778f1da6c, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct Cluster::ValueHolder<T>::ReleaseParams {
  ReleaseParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a967c8b00a278896, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct Cluster::ValueHolder<T>::ReleaseResults {
  ReleaseResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ddbd9a18593be0c5, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::ModelInstanceFactory {
  ModelInstanceFactory() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct NewInstanceParams;
  struct NewInstanceResults;
  struct NewInstancesParams;
  struct NewInstancesResults;
  struct NewCloudViaZmqPipelineProxiesParams;
  struct NewCloudViaZmqPipelineProxiesResults;
  struct NewCloudViaProxyParams;
  struct NewCloudViaProxyResults;
  struct ModelIdParams;
  struct ModelIdResults;
  struct RegisterModelInstanceParams;
  struct RegisterModelInstanceResults;
  struct RestoreSturdyRefParams;
  struct RestoreSturdyRefResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(fd9959998f9f0ebe)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Cluster::ModelInstanceFactory::NewInstanceParams {
  NewInstanceParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8bf81264d2f11274, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::ModelInstanceFactory::NewInstanceResults {
  NewInstanceResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f468b1dc515f841c, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::ModelInstanceFactory::NewInstancesParams {
  NewInstancesParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(985d83a2e2d7e204, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::ModelInstanceFactory::NewInstancesResults {
  NewInstancesResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bcacf6dde70da193, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::ModelInstanceFactory::NewCloudViaZmqPipelineProxiesParams {
  NewCloudViaZmqPipelineProxiesParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8b5d8251cf57c316, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::ModelInstanceFactory::NewCloudViaZmqPipelineProxiesResults {
  NewCloudViaZmqPipelineProxiesResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a81053c61d4d995c, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::ModelInstanceFactory::NewCloudViaProxyParams {
  NewCloudViaProxyParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fea4c3f998b67621, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::ModelInstanceFactory::NewCloudViaProxyResults {
  NewCloudViaProxyResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(baf979a1f5673019, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::ModelInstanceFactory::ModelIdParams {
  ModelIdParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e4b6ea2bfbc474d8, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::ModelInstanceFactory::ModelIdResults {
  ModelIdResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e3cf5a40e703e6da, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::ModelInstanceFactory::RegisterModelInstanceParams {
  RegisterModelInstanceParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bea41d4487c101c4, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::ModelInstanceFactory::RegisterModelInstanceResults {
  RegisterModelInstanceResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ca8fb2a4c16e5f08, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::ModelInstanceFactory::RestoreSturdyRefParams {
  RestoreSturdyRefParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d88a3f78cce2bc7d, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Cluster::ModelInstanceFactory::RestoreSturdyRefResults {
  RestoreSturdyRefResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e5cdfbf0462c5cfd, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Cluster::Reader {
public:
  typedef Cluster Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::Builder {
public:
  typedef Cluster Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::Pipeline {
public:
  typedef Cluster Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Cluster::Unregister::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Unregister Calls;
  typedef Unregister Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::cluster::Cluster::Unregister::UnregisterParams,  ::mas::schema::cluster::Cluster::Unregister::UnregisterResults> unregisterRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Cluster::Unregister::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Unregister Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::cluster::Cluster::Unregister::UnregisterParams UnregisterParams;
  typedef  ::mas::schema::cluster::Cluster::Unregister::UnregisterResults UnregisterResults;
  typedef ::capnp::CallContext<UnregisterParams, UnregisterResults> UnregisterContext;
  virtual ::kj::Promise<void> unregister(UnregisterContext context);

  inline  ::mas::schema::cluster::Cluster::Unregister::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::cluster::Cluster::Unregister>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Cluster::Unregister::UnregisterParams::Reader {
public:
  typedef UnregisterParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::Unregister::UnregisterParams::Builder {
public:
  typedef UnregisterParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::Unregister::UnregisterParams::Pipeline {
public:
  typedef UnregisterParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::Unregister::UnregisterResults::Reader {
public:
  typedef UnregisterResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getSuccess() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::Unregister::UnregisterResults::Builder {
public:
  typedef UnregisterResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getSuccess();
  inline void setSuccess(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::Unregister::UnregisterResults::Pipeline {
public:
  typedef UnregisterResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Cluster::AdminMaster::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client {
public:
  typedef AdminMaster Calls;
  typedef AdminMaster Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::cluster::Cluster::AdminMaster::RegisterModelInstanceFactoryParams,  ::mas::schema::cluster::Cluster::AdminMaster::RegisterModelInstanceFactoryResults> registerModelInstanceFactoryRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::cluster::Cluster::AdminMaster::AvailableModelsParams,  ::mas::schema::cluster::Cluster::AdminMaster::AvailableModelsResults> availableModelsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Cluster::AdminMaster::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server {
public:
  typedef AdminMaster Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::cluster::Cluster::AdminMaster::RegisterModelInstanceFactoryParams RegisterModelInstanceFactoryParams;
  typedef  ::mas::schema::cluster::Cluster::AdminMaster::RegisterModelInstanceFactoryResults RegisterModelInstanceFactoryResults;
  typedef ::capnp::CallContext<RegisterModelInstanceFactoryParams, RegisterModelInstanceFactoryResults> RegisterModelInstanceFactoryContext;
  virtual ::kj::Promise<void> registerModelInstanceFactory(RegisterModelInstanceFactoryContext context);
  typedef  ::mas::schema::cluster::Cluster::AdminMaster::AvailableModelsParams AvailableModelsParams;
  typedef  ::mas::schema::cluster::Cluster::AdminMaster::AvailableModelsResults AvailableModelsResults;
  typedef ::capnp::CallContext<AvailableModelsParams, AvailableModelsResults> AvailableModelsContext;
  virtual ::kj::Promise<void> availableModels(AvailableModelsContext context);

  inline  ::mas::schema::cluster::Cluster::AdminMaster::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::cluster::Cluster::AdminMaster>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Cluster::AdminMaster::RegisterModelInstanceFactoryParams::Reader {
public:
  typedef RegisterModelInstanceFactoryParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasAModelId() const;
  inline  ::capnp::Text::Reader getAModelId() const;

  inline bool hasAFactory() const;
#if !CAPNP_LITE
  inline  ::mas::schema::cluster::Cluster::ModelInstanceFactory::Client getAFactory() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::AdminMaster::RegisterModelInstanceFactoryParams::Builder {
public:
  typedef RegisterModelInstanceFactoryParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasAModelId();
  inline  ::capnp::Text::Builder getAModelId();
  inline void setAModelId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initAModelId(unsigned int size);
  inline void adoptAModelId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownAModelId();

  inline bool hasAFactory();
#if !CAPNP_LITE
  inline  ::mas::schema::cluster::Cluster::ModelInstanceFactory::Client getAFactory();
  inline void setAFactory( ::mas::schema::cluster::Cluster::ModelInstanceFactory::Client&& value);
  inline void setAFactory( ::mas::schema::cluster::Cluster::ModelInstanceFactory::Client& value);
  inline void adoptAFactory(::capnp::Orphan< ::mas::schema::cluster::Cluster::ModelInstanceFactory>&& value);
  inline ::capnp::Orphan< ::mas::schema::cluster::Cluster::ModelInstanceFactory> disownAFactory();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::AdminMaster::RegisterModelInstanceFactoryParams::Pipeline {
public:
  typedef RegisterModelInstanceFactoryParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::cluster::Cluster::ModelInstanceFactory::Client getAFactory();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::AdminMaster::RegisterModelInstanceFactoryResults::Reader {
public:
  typedef RegisterModelInstanceFactoryResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasUnregister() const;
#if !CAPNP_LITE
  inline  ::mas::schema::cluster::Cluster::Unregister::Client getUnregister() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::AdminMaster::RegisterModelInstanceFactoryResults::Builder {
public:
  typedef RegisterModelInstanceFactoryResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasUnregister();
#if !CAPNP_LITE
  inline  ::mas::schema::cluster::Cluster::Unregister::Client getUnregister();
  inline void setUnregister( ::mas::schema::cluster::Cluster::Unregister::Client&& value);
  inline void setUnregister( ::mas::schema::cluster::Cluster::Unregister::Client& value);
  inline void adoptUnregister(::capnp::Orphan< ::mas::schema::cluster::Cluster::Unregister>&& value);
  inline ::capnp::Orphan< ::mas::schema::cluster::Cluster::Unregister> disownUnregister();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::AdminMaster::RegisterModelInstanceFactoryResults::Pipeline {
public:
  typedef RegisterModelInstanceFactoryResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::cluster::Cluster::Unregister::Client getUnregister();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::AdminMaster::AvailableModelsParams::Reader {
public:
  typedef AvailableModelsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::AdminMaster::AvailableModelsParams::Builder {
public:
  typedef AvailableModelsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::AdminMaster::AvailableModelsParams::Pipeline {
public:
  typedef AvailableModelsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::AdminMaster::AvailableModelsResults::Reader {
public:
  typedef AvailableModelsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasFactories() const;
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>::Reader getFactories() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::AdminMaster::AvailableModelsResults::Builder {
public:
  typedef AvailableModelsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasFactories();
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>::Builder getFactories();
  inline void setFactories( ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>::Reader value);
  inline  ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>::Builder initFactories(unsigned int size);
  inline void adoptFactories(::capnp::Orphan< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>> disownFactories();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::AdminMaster::AvailableModelsResults::Pipeline {
public:
  typedef AvailableModelsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Cluster::UserMaster::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client {
public:
  typedef UserMaster Calls;
  typedef UserMaster Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::cluster::Cluster::UserMaster::AvailableModelsParams,  ::mas::schema::cluster::Cluster::UserMaster::AvailableModelsResults> availableModelsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Cluster::UserMaster::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server {
public:
  typedef UserMaster Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::cluster::Cluster::UserMaster::AvailableModelsParams AvailableModelsParams;
  typedef  ::mas::schema::cluster::Cluster::UserMaster::AvailableModelsResults AvailableModelsResults;
  typedef ::capnp::CallContext<AvailableModelsParams, AvailableModelsResults> AvailableModelsContext;
  virtual ::kj::Promise<void> availableModels(AvailableModelsContext context);

  inline  ::mas::schema::cluster::Cluster::UserMaster::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::cluster::Cluster::UserMaster>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Cluster::UserMaster::AvailableModelsParams::Reader {
public:
  typedef AvailableModelsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::UserMaster::AvailableModelsParams::Builder {
public:
  typedef AvailableModelsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::UserMaster::AvailableModelsParams::Pipeline {
public:
  typedef AvailableModelsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::UserMaster::AvailableModelsResults::Reader {
public:
  typedef AvailableModelsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasFactories() const;
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>::Reader getFactories() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::UserMaster::AvailableModelsResults::Builder {
public:
  typedef AvailableModelsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasFactories();
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>::Builder getFactories();
  inline void setFactories( ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>::Reader value);
  inline  ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>::Builder initFactories(unsigned int size);
  inline void adoptFactories(::capnp::Orphan< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>> disownFactories();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::UserMaster::AvailableModelsResults::Pipeline {
public:
  typedef AvailableModelsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Cluster::Runtime::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client {
public:
  typedef Runtime Calls;
  typedef Runtime Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::cluster::Cluster::Runtime::RegisterModelInstanceFactoryParams,  ::mas::schema::cluster::Cluster::Runtime::RegisterModelInstanceFactoryResults> registerModelInstanceFactoryRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::cluster::Cluster::Runtime::AvailableModelsParams,  ::mas::schema::cluster::Cluster::Runtime::AvailableModelsResults> availableModelsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::cluster::Cluster::Runtime::NumberOfCoresParams,  ::mas::schema::cluster::Cluster::Runtime::NumberOfCoresResults> numberOfCoresRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::cluster::Cluster::Runtime::FreeNumberOfCoresParams,  ::mas::schema::cluster::Cluster::Runtime::FreeNumberOfCoresResults> freeNumberOfCoresRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::cluster::Cluster::Runtime::ReserveNumberOfCoresParams,  ::mas::schema::cluster::Cluster::Runtime::ReserveNumberOfCoresResults> reserveNumberOfCoresRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Cluster::Runtime::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server {
public:
  typedef Runtime Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::cluster::Cluster::Runtime::RegisterModelInstanceFactoryParams RegisterModelInstanceFactoryParams;
  typedef  ::mas::schema::cluster::Cluster::Runtime::RegisterModelInstanceFactoryResults RegisterModelInstanceFactoryResults;
  typedef ::capnp::CallContext<RegisterModelInstanceFactoryParams, RegisterModelInstanceFactoryResults> RegisterModelInstanceFactoryContext;
  virtual ::kj::Promise<void> registerModelInstanceFactory(RegisterModelInstanceFactoryContext context);
  typedef  ::mas::schema::cluster::Cluster::Runtime::AvailableModelsParams AvailableModelsParams;
  typedef  ::mas::schema::cluster::Cluster::Runtime::AvailableModelsResults AvailableModelsResults;
  typedef ::capnp::CallContext<AvailableModelsParams, AvailableModelsResults> AvailableModelsContext;
  virtual ::kj::Promise<void> availableModels(AvailableModelsContext context);
  typedef  ::mas::schema::cluster::Cluster::Runtime::NumberOfCoresParams NumberOfCoresParams;
  typedef  ::mas::schema::cluster::Cluster::Runtime::NumberOfCoresResults NumberOfCoresResults;
  typedef ::capnp::CallContext<NumberOfCoresParams, NumberOfCoresResults> NumberOfCoresContext;
  virtual ::kj::Promise<void> numberOfCores(NumberOfCoresContext context);
  typedef  ::mas::schema::cluster::Cluster::Runtime::FreeNumberOfCoresParams FreeNumberOfCoresParams;
  typedef  ::mas::schema::cluster::Cluster::Runtime::FreeNumberOfCoresResults FreeNumberOfCoresResults;
  typedef ::capnp::CallContext<FreeNumberOfCoresParams, FreeNumberOfCoresResults> FreeNumberOfCoresContext;
  virtual ::kj::Promise<void> freeNumberOfCores(FreeNumberOfCoresContext context);
  typedef  ::mas::schema::cluster::Cluster::Runtime::ReserveNumberOfCoresParams ReserveNumberOfCoresParams;
  typedef  ::mas::schema::cluster::Cluster::Runtime::ReserveNumberOfCoresResults ReserveNumberOfCoresResults;
  typedef ::capnp::CallContext<ReserveNumberOfCoresParams, ReserveNumberOfCoresResults> ReserveNumberOfCoresContext;
  virtual ::kj::Promise<void> reserveNumberOfCores(ReserveNumberOfCoresContext context);

  inline  ::mas::schema::cluster::Cluster::Runtime::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::cluster::Cluster::Runtime>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Cluster::Runtime::RegisterModelInstanceFactoryParams::Reader {
public:
  typedef RegisterModelInstanceFactoryParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasAModelId() const;
  inline  ::capnp::Text::Reader getAModelId() const;

  inline bool hasAFactory() const;
#if !CAPNP_LITE
  inline  ::mas::schema::cluster::Cluster::ModelInstanceFactory::Client getAFactory() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::Runtime::RegisterModelInstanceFactoryParams::Builder {
public:
  typedef RegisterModelInstanceFactoryParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasAModelId();
  inline  ::capnp::Text::Builder getAModelId();
  inline void setAModelId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initAModelId(unsigned int size);
  inline void adoptAModelId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownAModelId();

  inline bool hasAFactory();
#if !CAPNP_LITE
  inline  ::mas::schema::cluster::Cluster::ModelInstanceFactory::Client getAFactory();
  inline void setAFactory( ::mas::schema::cluster::Cluster::ModelInstanceFactory::Client&& value);
  inline void setAFactory( ::mas::schema::cluster::Cluster::ModelInstanceFactory::Client& value);
  inline void adoptAFactory(::capnp::Orphan< ::mas::schema::cluster::Cluster::ModelInstanceFactory>&& value);
  inline ::capnp::Orphan< ::mas::schema::cluster::Cluster::ModelInstanceFactory> disownAFactory();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::Runtime::RegisterModelInstanceFactoryParams::Pipeline {
public:
  typedef RegisterModelInstanceFactoryParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::cluster::Cluster::ModelInstanceFactory::Client getAFactory();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::Runtime::RegisterModelInstanceFactoryResults::Reader {
public:
  typedef RegisterModelInstanceFactoryResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasUnregister() const;
#if !CAPNP_LITE
  inline  ::mas::schema::cluster::Cluster::Unregister::Client getUnregister() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::Runtime::RegisterModelInstanceFactoryResults::Builder {
public:
  typedef RegisterModelInstanceFactoryResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasUnregister();
#if !CAPNP_LITE
  inline  ::mas::schema::cluster::Cluster::Unregister::Client getUnregister();
  inline void setUnregister( ::mas::schema::cluster::Cluster::Unregister::Client&& value);
  inline void setUnregister( ::mas::schema::cluster::Cluster::Unregister::Client& value);
  inline void adoptUnregister(::capnp::Orphan< ::mas::schema::cluster::Cluster::Unregister>&& value);
  inline ::capnp::Orphan< ::mas::schema::cluster::Cluster::Unregister> disownUnregister();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::Runtime::RegisterModelInstanceFactoryResults::Pipeline {
public:
  typedef RegisterModelInstanceFactoryResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::cluster::Cluster::Unregister::Client getUnregister();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::Runtime::AvailableModelsParams::Reader {
public:
  typedef AvailableModelsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::Runtime::AvailableModelsParams::Builder {
public:
  typedef AvailableModelsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::Runtime::AvailableModelsParams::Pipeline {
public:
  typedef AvailableModelsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::Runtime::AvailableModelsResults::Reader {
public:
  typedef AvailableModelsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasFactories() const;
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>::Reader getFactories() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::Runtime::AvailableModelsResults::Builder {
public:
  typedef AvailableModelsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasFactories();
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>::Builder getFactories();
  inline void setFactories( ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>::Reader value);
  inline  ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>::Builder initFactories(unsigned int size);
  inline void adoptFactories(::capnp::Orphan< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>> disownFactories();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::Runtime::AvailableModelsResults::Pipeline {
public:
  typedef AvailableModelsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::Runtime::NumberOfCoresParams::Reader {
public:
  typedef NumberOfCoresParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::Runtime::NumberOfCoresParams::Builder {
public:
  typedef NumberOfCoresParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::Runtime::NumberOfCoresParams::Pipeline {
public:
  typedef NumberOfCoresParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::Runtime::NumberOfCoresResults::Reader {
public:
  typedef NumberOfCoresResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int16_t getCores() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::Runtime::NumberOfCoresResults::Builder {
public:
  typedef NumberOfCoresResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int16_t getCores();
  inline void setCores( ::int16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::Runtime::NumberOfCoresResults::Pipeline {
public:
  typedef NumberOfCoresResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::Runtime::FreeNumberOfCoresParams::Reader {
public:
  typedef FreeNumberOfCoresParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::Runtime::FreeNumberOfCoresParams::Builder {
public:
  typedef FreeNumberOfCoresParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::Runtime::FreeNumberOfCoresParams::Pipeline {
public:
  typedef FreeNumberOfCoresParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::Runtime::FreeNumberOfCoresResults::Reader {
public:
  typedef FreeNumberOfCoresResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int16_t getCores() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::Runtime::FreeNumberOfCoresResults::Builder {
public:
  typedef FreeNumberOfCoresResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int16_t getCores();
  inline void setCores( ::int16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::Runtime::FreeNumberOfCoresResults::Pipeline {
public:
  typedef FreeNumberOfCoresResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::Runtime::ReserveNumberOfCoresParams::Reader {
public:
  typedef ReserveNumberOfCoresParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int16_t getReserveCores() const;

  inline bool hasAModelId() const;
  inline  ::capnp::Text::Reader getAModelId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::Runtime::ReserveNumberOfCoresParams::Builder {
public:
  typedef ReserveNumberOfCoresParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int16_t getReserveCores();
  inline void setReserveCores( ::int16_t value);

  inline bool hasAModelId();
  inline  ::capnp::Text::Builder getAModelId();
  inline void setAModelId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initAModelId(unsigned int size);
  inline void adoptAModelId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownAModelId();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::Runtime::ReserveNumberOfCoresParams::Pipeline {
public:
  typedef ReserveNumberOfCoresParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::Runtime::ReserveNumberOfCoresResults::Reader {
public:
  typedef ReserveNumberOfCoresResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int16_t getReservedCores() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::Runtime::ReserveNumberOfCoresResults::Builder {
public:
  typedef ReserveNumberOfCoresResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int16_t getReservedCores();
  inline void setReservedCores( ::int16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::Runtime::ReserveNumberOfCoresResults::Pipeline {
public:
  typedef ReserveNumberOfCoresResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::ZmqPipelineAddresses::Reader {
public:
  typedef ZmqPipelineAddresses Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasInput() const;
  inline  ::capnp::Text::Reader getInput() const;

  inline bool hasOutput() const;
  inline  ::capnp::Text::Reader getOutput() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::ZmqPipelineAddresses::Builder {
public:
  typedef ZmqPipelineAddresses Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasInput();
  inline  ::capnp::Text::Builder getInput();
  inline void setInput( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initInput(unsigned int size);
  inline void adoptInput(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownInput();

  inline bool hasOutput();
  inline  ::capnp::Text::Builder getOutput();
  inline void setOutput( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initOutput(unsigned int size);
  inline void adoptOutput(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownOutput();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::ZmqPipelineAddresses::Pipeline {
public:
  typedef ZmqPipelineAddresses Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename T>
class Cluster::ValueHolder<T>::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef ValueHolder Calls;
  typedef ValueHolder Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename T2 = ::capnp::AnyPointer>
  typename ValueHolder<T2>::Client asGeneric() {
    return castAs<ValueHolder<T2>>();
  }

  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::cluster::Cluster::ValueHolder<T>::ValueParams, typename  ::mas::schema::cluster::Cluster::ValueHolder<T>::ValueResults>) valueRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::cluster::Cluster::ValueHolder<T>::ReleaseParams, typename  ::mas::schema::cluster::Cluster::ValueHolder<T>::ReleaseResults>) releaseRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

template <typename T>
class Cluster::ValueHolder<T>::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef ValueHolder Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef typename  ::mas::schema::cluster::Cluster::ValueHolder<T>::ValueParams ValueParams;
  typedef typename  ::mas::schema::cluster::Cluster::ValueHolder<T>::ValueResults ValueResults;
  typedef ::capnp::CallContext<ValueParams, ValueResults> ValueContext;
  virtual ::kj::Promise<void> value(ValueContext context);
  typedef typename  ::mas::schema::cluster::Cluster::ValueHolder<T>::ReleaseParams ReleaseParams;
  typedef typename  ::mas::schema::cluster::Cluster::ValueHolder<T>::ReleaseResults ReleaseResults;
  typedef ::capnp::CallContext<ReleaseParams, ReleaseResults> ReleaseContext;
  virtual ::kj::Promise<void> release(ReleaseContext context);

  inline typename  ::mas::schema::cluster::Cluster::ValueHolder<T>::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::cluster::Cluster::ValueHolder<T>>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename T>
class Cluster::ValueHolder<T>::ValueParams::Reader {
public:
  typedef ValueParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename ValueHolder<T2>::ValueParams::Reader asValueHolderGeneric() {
    return typename ValueHolder<T2>::ValueParams::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class Cluster::ValueHolder<T>::ValueParams::Builder {
public:
  typedef ValueParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename ValueHolder<T2>::ValueParams::Builder asValueHolderGeneric() {
    return typename ValueHolder<T2>::ValueParams::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class Cluster::ValueHolder<T>::ValueParams::Pipeline {
public:
  typedef ValueParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class Cluster::ValueHolder<T>::ValueResults::Reader {
public:
  typedef ValueResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename ValueHolder<T2>::ValueResults::Reader asValueHolderGeneric() {
    return typename ValueHolder<T2>::ValueResults::Reader(_reader);
  }

  inline bool hasVal() const;
  inline  ::capnp::ReaderFor<T> getVal() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class Cluster::ValueHolder<T>::ValueResults::Builder {
public:
  typedef ValueResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename ValueHolder<T2>::ValueResults::Builder asValueHolderGeneric() {
    return typename ValueHolder<T2>::ValueResults::Builder(_builder);
  }

  inline bool hasVal();
  inline  ::capnp::BuilderFor<T> getVal();
  inline void setVal( ::capnp::ReaderFor<T> value);
  inline  ::capnp::BuilderFor<T> initVal();
  inline  ::capnp::BuilderFor<T> initVal(unsigned int size);
  inline void adoptVal(::capnp::Orphan<T>&& value);
  inline ::capnp::Orphan<T> disownVal();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class Cluster::ValueHolder<T>::ValueResults::Pipeline {
public:
  typedef ValueResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<T> getVal();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class Cluster::ValueHolder<T>::ReleaseParams::Reader {
public:
  typedef ReleaseParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename ValueHolder<T2>::ReleaseParams::Reader asValueHolderGeneric() {
    return typename ValueHolder<T2>::ReleaseParams::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class Cluster::ValueHolder<T>::ReleaseParams::Builder {
public:
  typedef ReleaseParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename ValueHolder<T2>::ReleaseParams::Builder asValueHolderGeneric() {
    return typename ValueHolder<T2>::ReleaseParams::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class Cluster::ValueHolder<T>::ReleaseParams::Pipeline {
public:
  typedef ReleaseParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class Cluster::ValueHolder<T>::ReleaseResults::Reader {
public:
  typedef ReleaseResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename ValueHolder<T2>::ReleaseResults::Reader asValueHolderGeneric() {
    return typename ValueHolder<T2>::ReleaseResults::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class Cluster::ValueHolder<T>::ReleaseResults::Builder {
public:
  typedef ReleaseResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename ValueHolder<T2>::ReleaseResults::Builder asValueHolderGeneric() {
    return typename ValueHolder<T2>::ReleaseResults::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class Cluster::ValueHolder<T>::ReleaseResults::Pipeline {
public:
  typedef ReleaseResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Cluster::ModelInstanceFactory::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client {
public:
  typedef ModelInstanceFactory Calls;
  typedef ModelInstanceFactory Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::cluster::Cluster::ModelInstanceFactory::NewInstanceParams,  ::mas::schema::cluster::Cluster::ModelInstanceFactory::NewInstanceResults> newInstanceRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::cluster::Cluster::ModelInstanceFactory::NewInstancesParams,  ::mas::schema::cluster::Cluster::ModelInstanceFactory::NewInstancesResults> newInstancesRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::cluster::Cluster::ModelInstanceFactory::NewCloudViaZmqPipelineProxiesParams,  ::mas::schema::cluster::Cluster::ModelInstanceFactory::NewCloudViaZmqPipelineProxiesResults> newCloudViaZmqPipelineProxiesRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::cluster::Cluster::ModelInstanceFactory::NewCloudViaProxyParams,  ::mas::schema::cluster::Cluster::ModelInstanceFactory::NewCloudViaProxyResults> newCloudViaProxyRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::cluster::Cluster::ModelInstanceFactory::ModelIdParams,  ::mas::schema::cluster::Cluster::ModelInstanceFactory::ModelIdResults> modelIdRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::cluster::Cluster::ModelInstanceFactory::RegisterModelInstanceParams,  ::mas::schema::cluster::Cluster::ModelInstanceFactory::RegisterModelInstanceResults> registerModelInstanceRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::cluster::Cluster::ModelInstanceFactory::RestoreSturdyRefParams,  ::mas::schema::cluster::Cluster::ModelInstanceFactory::RestoreSturdyRefResults> restoreSturdyRefRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Cluster::ModelInstanceFactory::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server {
public:
  typedef ModelInstanceFactory Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::cluster::Cluster::ModelInstanceFactory::NewInstanceParams NewInstanceParams;
  typedef  ::mas::schema::cluster::Cluster::ModelInstanceFactory::NewInstanceResults NewInstanceResults;
  typedef ::capnp::CallContext<NewInstanceParams, NewInstanceResults> NewInstanceContext;
  virtual ::kj::Promise<void> newInstance(NewInstanceContext context);
  typedef  ::mas::schema::cluster::Cluster::ModelInstanceFactory::NewInstancesParams NewInstancesParams;
  typedef  ::mas::schema::cluster::Cluster::ModelInstanceFactory::NewInstancesResults NewInstancesResults;
  typedef ::capnp::CallContext<NewInstancesParams, NewInstancesResults> NewInstancesContext;
  virtual ::kj::Promise<void> newInstances(NewInstancesContext context);
  typedef  ::mas::schema::cluster::Cluster::ModelInstanceFactory::NewCloudViaZmqPipelineProxiesParams NewCloudViaZmqPipelineProxiesParams;
  typedef  ::mas::schema::cluster::Cluster::ModelInstanceFactory::NewCloudViaZmqPipelineProxiesResults NewCloudViaZmqPipelineProxiesResults;
  typedef ::capnp::CallContext<NewCloudViaZmqPipelineProxiesParams, NewCloudViaZmqPipelineProxiesResults> NewCloudViaZmqPipelineProxiesContext;
  virtual ::kj::Promise<void> newCloudViaZmqPipelineProxies(NewCloudViaZmqPipelineProxiesContext context);
  typedef  ::mas::schema::cluster::Cluster::ModelInstanceFactory::NewCloudViaProxyParams NewCloudViaProxyParams;
  typedef  ::mas::schema::cluster::Cluster::ModelInstanceFactory::NewCloudViaProxyResults NewCloudViaProxyResults;
  typedef ::capnp::CallContext<NewCloudViaProxyParams, NewCloudViaProxyResults> NewCloudViaProxyContext;
  virtual ::kj::Promise<void> newCloudViaProxy(NewCloudViaProxyContext context);
  typedef  ::mas::schema::cluster::Cluster::ModelInstanceFactory::ModelIdParams ModelIdParams;
  typedef  ::mas::schema::cluster::Cluster::ModelInstanceFactory::ModelIdResults ModelIdResults;
  typedef ::capnp::CallContext<ModelIdParams, ModelIdResults> ModelIdContext;
  virtual ::kj::Promise<void> modelId(ModelIdContext context);
  typedef  ::mas::schema::cluster::Cluster::ModelInstanceFactory::RegisterModelInstanceParams RegisterModelInstanceParams;
  typedef  ::mas::schema::cluster::Cluster::ModelInstanceFactory::RegisterModelInstanceResults RegisterModelInstanceResults;
  typedef ::capnp::CallContext<RegisterModelInstanceParams, RegisterModelInstanceResults> RegisterModelInstanceContext;
  virtual ::kj::Promise<void> registerModelInstance(RegisterModelInstanceContext context);
  typedef  ::mas::schema::cluster::Cluster::ModelInstanceFactory::RestoreSturdyRefParams RestoreSturdyRefParams;
  typedef  ::mas::schema::cluster::Cluster::ModelInstanceFactory::RestoreSturdyRefResults RestoreSturdyRefResults;
  typedef ::capnp::CallContext<RestoreSturdyRefParams, RestoreSturdyRefResults> RestoreSturdyRefContext;
  virtual ::kj::Promise<void> restoreSturdyRef(RestoreSturdyRefContext context);

  inline  ::mas::schema::cluster::Cluster::ModelInstanceFactory::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::cluster::Cluster::ModelInstanceFactory>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Cluster::ModelInstanceFactory::NewInstanceParams::Reader {
public:
  typedef NewInstanceParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::ModelInstanceFactory::NewInstanceParams::Builder {
public:
  typedef NewInstanceParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::ModelInstanceFactory::NewInstanceParams::Pipeline {
public:
  typedef NewInstanceParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::ModelInstanceFactory::NewInstanceResults::Reader {
public:
  typedef NewInstanceResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasInstance() const;
#if !CAPNP_LITE
  inline  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client getInstance() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::ModelInstanceFactory::NewInstanceResults::Builder {
public:
  typedef NewInstanceResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasInstance();
#if !CAPNP_LITE
  inline  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client getInstance();
  inline void setInstance( ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client&& value);
  inline void setInstance( ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client& value);
  inline void adoptInstance(::capnp::Orphan< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>>&& value);
  inline ::capnp::Orphan< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>> disownInstance();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::ModelInstanceFactory::NewInstanceResults::Pipeline {
public:
  typedef NewInstanceResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client getInstance();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::ModelInstanceFactory::NewInstancesParams::Reader {
public:
  typedef NewInstancesParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int16_t getNumberOfInstances() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::ModelInstanceFactory::NewInstancesParams::Builder {
public:
  typedef NewInstancesParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int16_t getNumberOfInstances();
  inline void setNumberOfInstances( ::int16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::ModelInstanceFactory::NewInstancesParams::Pipeline {
public:
  typedef NewInstancesParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::ModelInstanceFactory::NewInstancesResults::Reader {
public:
  typedef NewInstancesResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasInstances() const;
#if !CAPNP_LITE
  inline  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::List< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>,  ::capnp::Kind::INTERFACE>>::Client getInstances() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::ModelInstanceFactory::NewInstancesResults::Builder {
public:
  typedef NewInstancesResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasInstances();
#if !CAPNP_LITE
  inline  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::List< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>,  ::capnp::Kind::INTERFACE>>::Client getInstances();
  inline void setInstances( ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::List< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>,  ::capnp::Kind::INTERFACE>>::Client&& value);
  inline void setInstances( ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::List< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>,  ::capnp::Kind::INTERFACE>>::Client& value);
  inline void adoptInstances(::capnp::Orphan< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::List< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>,  ::capnp::Kind::INTERFACE>>>&& value);
  inline ::capnp::Orphan< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::List< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>,  ::capnp::Kind::INTERFACE>>> disownInstances();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::ModelInstanceFactory::NewInstancesResults::Pipeline {
public:
  typedef NewInstancesResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::List< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>,  ::capnp::Kind::INTERFACE>>::Client getInstances();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::ModelInstanceFactory::NewCloudViaZmqPipelineProxiesParams::Reader {
public:
  typedef NewCloudViaZmqPipelineProxiesParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int16_t getNumberOfInstances() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::ModelInstanceFactory::NewCloudViaZmqPipelineProxiesParams::Builder {
public:
  typedef NewCloudViaZmqPipelineProxiesParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int16_t getNumberOfInstances();
  inline void setNumberOfInstances( ::int16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::ModelInstanceFactory::NewCloudViaZmqPipelineProxiesParams::Pipeline {
public:
  typedef NewCloudViaZmqPipelineProxiesParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::ModelInstanceFactory::NewCloudViaZmqPipelineProxiesResults::Reader {
public:
  typedef NewCloudViaZmqPipelineProxiesResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasProxyAddresses() const;
#if !CAPNP_LITE
  inline  ::mas::schema::cluster::Cluster::ValueHolder< ::mas::schema::cluster::Cluster::ZmqPipelineAddresses>::Client getProxyAddresses() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::ModelInstanceFactory::NewCloudViaZmqPipelineProxiesResults::Builder {
public:
  typedef NewCloudViaZmqPipelineProxiesResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasProxyAddresses();
#if !CAPNP_LITE
  inline  ::mas::schema::cluster::Cluster::ValueHolder< ::mas::schema::cluster::Cluster::ZmqPipelineAddresses>::Client getProxyAddresses();
  inline void setProxyAddresses( ::mas::schema::cluster::Cluster::ValueHolder< ::mas::schema::cluster::Cluster::ZmqPipelineAddresses>::Client&& value);
  inline void setProxyAddresses( ::mas::schema::cluster::Cluster::ValueHolder< ::mas::schema::cluster::Cluster::ZmqPipelineAddresses>::Client& value);
  inline void adoptProxyAddresses(::capnp::Orphan< ::mas::schema::cluster::Cluster::ValueHolder< ::mas::schema::cluster::Cluster::ZmqPipelineAddresses>>&& value);
  inline ::capnp::Orphan< ::mas::schema::cluster::Cluster::ValueHolder< ::mas::schema::cluster::Cluster::ZmqPipelineAddresses>> disownProxyAddresses();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::ModelInstanceFactory::NewCloudViaZmqPipelineProxiesResults::Pipeline {
public:
  typedef NewCloudViaZmqPipelineProxiesResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::cluster::Cluster::ValueHolder< ::mas::schema::cluster::Cluster::ZmqPipelineAddresses>::Client getProxyAddresses();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::ModelInstanceFactory::NewCloudViaProxyParams::Reader {
public:
  typedef NewCloudViaProxyParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int16_t getNumberOfInstances() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::ModelInstanceFactory::NewCloudViaProxyParams::Builder {
public:
  typedef NewCloudViaProxyParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int16_t getNumberOfInstances();
  inline void setNumberOfInstances( ::int16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::ModelInstanceFactory::NewCloudViaProxyParams::Pipeline {
public:
  typedef NewCloudViaProxyParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::ModelInstanceFactory::NewCloudViaProxyResults::Reader {
public:
  typedef NewCloudViaProxyResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasProxy() const;
#if !CAPNP_LITE
  inline  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client getProxy() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::ModelInstanceFactory::NewCloudViaProxyResults::Builder {
public:
  typedef NewCloudViaProxyResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasProxy();
#if !CAPNP_LITE
  inline  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client getProxy();
  inline void setProxy( ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client&& value);
  inline void setProxy( ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client& value);
  inline void adoptProxy(::capnp::Orphan< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>>&& value);
  inline ::capnp::Orphan< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>> disownProxy();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::ModelInstanceFactory::NewCloudViaProxyResults::Pipeline {
public:
  typedef NewCloudViaProxyResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client getProxy();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::ModelInstanceFactory::ModelIdParams::Reader {
public:
  typedef ModelIdParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::ModelInstanceFactory::ModelIdParams::Builder {
public:
  typedef ModelIdParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::ModelInstanceFactory::ModelIdParams::Pipeline {
public:
  typedef ModelIdParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::ModelInstanceFactory::ModelIdResults::Reader {
public:
  typedef ModelIdResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasId() const;
  inline  ::capnp::Text::Reader getId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::ModelInstanceFactory::ModelIdResults::Builder {
public:
  typedef ModelIdResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasId();
  inline  ::capnp::Text::Builder getId();
  inline void setId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initId(unsigned int size);
  inline void adoptId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownId();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::ModelInstanceFactory::ModelIdResults::Pipeline {
public:
  typedef ModelIdResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::ModelInstanceFactory::RegisterModelInstanceParams::Reader {
public:
  typedef RegisterModelInstanceParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasInstance() const;
#if !CAPNP_LITE
  inline  ::capnp::Capability::Client getInstance() const;
#endif  // !CAPNP_LITE

  inline bool hasRegistrationToken() const;
  inline  ::capnp::Text::Reader getRegistrationToken() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::ModelInstanceFactory::RegisterModelInstanceParams::Builder {
public:
  typedef RegisterModelInstanceParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasInstance();
#if !CAPNP_LITE
  inline  ::capnp::Capability::Client getInstance();
  inline void setInstance( ::capnp::Capability::Client&& value);
  inline void setInstance( ::capnp::Capability::Client& value);
  inline void adoptInstance(::capnp::Orphan< ::capnp::Capability>&& value);
  inline ::capnp::Orphan< ::capnp::Capability> disownInstance();
#endif  // !CAPNP_LITE

  inline bool hasRegistrationToken();
  inline  ::capnp::Text::Builder getRegistrationToken();
  inline void setRegistrationToken( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initRegistrationToken(unsigned int size);
  inline void adoptRegistrationToken(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownRegistrationToken();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::ModelInstanceFactory::RegisterModelInstanceParams::Pipeline {
public:
  typedef RegisterModelInstanceParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::Capability::Client getInstance();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::ModelInstanceFactory::RegisterModelInstanceResults::Reader {
public:
  typedef RegisterModelInstanceResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasUnregister() const;
#if !CAPNP_LITE
  inline  ::mas::schema::cluster::Cluster::Unregister::Client getUnregister() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::ModelInstanceFactory::RegisterModelInstanceResults::Builder {
public:
  typedef RegisterModelInstanceResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasUnregister();
#if !CAPNP_LITE
  inline  ::mas::schema::cluster::Cluster::Unregister::Client getUnregister();
  inline void setUnregister( ::mas::schema::cluster::Cluster::Unregister::Client&& value);
  inline void setUnregister( ::mas::schema::cluster::Cluster::Unregister::Client& value);
  inline void adoptUnregister(::capnp::Orphan< ::mas::schema::cluster::Cluster::Unregister>&& value);
  inline ::capnp::Orphan< ::mas::schema::cluster::Cluster::Unregister> disownUnregister();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::ModelInstanceFactory::RegisterModelInstanceResults::Pipeline {
public:
  typedef RegisterModelInstanceResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::cluster::Cluster::Unregister::Client getUnregister();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::ModelInstanceFactory::RestoreSturdyRefParams::Reader {
public:
  typedef RestoreSturdyRefParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasSturdyRef() const;
  inline  ::capnp::Text::Reader getSturdyRef() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::ModelInstanceFactory::RestoreSturdyRefParams::Builder {
public:
  typedef RestoreSturdyRefParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasSturdyRef();
  inline  ::capnp::Text::Builder getSturdyRef();
  inline void setSturdyRef( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initSturdyRef(unsigned int size);
  inline void adoptSturdyRef(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownSturdyRef();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::ModelInstanceFactory::RestoreSturdyRefParams::Pipeline {
public:
  typedef RestoreSturdyRefParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Cluster::ModelInstanceFactory::RestoreSturdyRefResults::Reader {
public:
  typedef RestoreSturdyRefResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCap() const;
#if !CAPNP_LITE
  inline  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client getCap() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Cluster::ModelInstanceFactory::RestoreSturdyRefResults::Builder {
public:
  typedef RestoreSturdyRefResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCap();
#if !CAPNP_LITE
  inline  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client getCap();
  inline void setCap( ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client&& value);
  inline void setCap( ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client& value);
  inline void adoptCap(::capnp::Orphan< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>>&& value);
  inline ::capnp::Orphan< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>> disownCap();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Cluster::ModelInstanceFactory::RestoreSturdyRefResults::Pipeline {
public:
  typedef RestoreSturdyRefResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client getCap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

#if !CAPNP_LITE
inline Cluster::Unregister::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Cluster::Unregister::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Cluster::Unregister::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Cluster::Unregister::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Cluster::Unregister::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::cluster::Cluster::Unregister::Client& Cluster::Unregister::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::cluster::Cluster::Unregister::Client& Cluster::Unregister::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Cluster::Unregister::UnregisterResults::Reader::getSuccess() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Cluster::Unregister::UnregisterResults::Builder::getSuccess() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Cluster::Unregister::UnregisterResults::Builder::setSuccess(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

#if !CAPNP_LITE
inline Cluster::AdminMaster::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Cluster::AdminMaster::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Cluster::AdminMaster::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Cluster::AdminMaster::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Cluster::AdminMaster::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::cluster::Cluster::AdminMaster::Client& Cluster::AdminMaster::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::cluster::Cluster::AdminMaster::Client& Cluster::AdminMaster::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Cluster::AdminMaster::RegisterModelInstanceFactoryParams::Reader::hasAModelId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Cluster::AdminMaster::RegisterModelInstanceFactoryParams::Builder::hasAModelId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Cluster::AdminMaster::RegisterModelInstanceFactoryParams::Reader::getAModelId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Cluster::AdminMaster::RegisterModelInstanceFactoryParams::Builder::getAModelId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Cluster::AdminMaster::RegisterModelInstanceFactoryParams::Builder::setAModelId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Cluster::AdminMaster::RegisterModelInstanceFactoryParams::Builder::initAModelId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Cluster::AdminMaster::RegisterModelInstanceFactoryParams::Builder::adoptAModelId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Cluster::AdminMaster::RegisterModelInstanceFactoryParams::Builder::disownAModelId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Cluster::AdminMaster::RegisterModelInstanceFactoryParams::Reader::hasAFactory() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Cluster::AdminMaster::RegisterModelInstanceFactoryParams::Builder::hasAFactory() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::cluster::Cluster::ModelInstanceFactory::Client Cluster::AdminMaster::RegisterModelInstanceFactoryParams::Reader::getAFactory() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ModelInstanceFactory>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::cluster::Cluster::ModelInstanceFactory::Client Cluster::AdminMaster::RegisterModelInstanceFactoryParams::Builder::getAFactory() {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ModelInstanceFactory>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::cluster::Cluster::ModelInstanceFactory::Client Cluster::AdminMaster::RegisterModelInstanceFactoryParams::Pipeline::getAFactory() {
  return  ::mas::schema::cluster::Cluster::ModelInstanceFactory::Client(_typeless.getPointerField(1).asCap());
}
inline void Cluster::AdminMaster::RegisterModelInstanceFactoryParams::Builder::setAFactory( ::mas::schema::cluster::Cluster::ModelInstanceFactory::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ModelInstanceFactory>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Cluster::AdminMaster::RegisterModelInstanceFactoryParams::Builder::setAFactory( ::mas::schema::cluster::Cluster::ModelInstanceFactory::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ModelInstanceFactory>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), cap);
}
inline void Cluster::AdminMaster::RegisterModelInstanceFactoryParams::Builder::adoptAFactory(
    ::capnp::Orphan< ::mas::schema::cluster::Cluster::ModelInstanceFactory>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ModelInstanceFactory>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::cluster::Cluster::ModelInstanceFactory> Cluster::AdminMaster::RegisterModelInstanceFactoryParams::Builder::disownAFactory() {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ModelInstanceFactory>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Cluster::AdminMaster::RegisterModelInstanceFactoryResults::Reader::hasUnregister() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Cluster::AdminMaster::RegisterModelInstanceFactoryResults::Builder::hasUnregister() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::cluster::Cluster::Unregister::Client Cluster::AdminMaster::RegisterModelInstanceFactoryResults::Reader::getUnregister() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::Unregister>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::cluster::Cluster::Unregister::Client Cluster::AdminMaster::RegisterModelInstanceFactoryResults::Builder::getUnregister() {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::Unregister>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::cluster::Cluster::Unregister::Client Cluster::AdminMaster::RegisterModelInstanceFactoryResults::Pipeline::getUnregister() {
  return  ::mas::schema::cluster::Cluster::Unregister::Client(_typeless.getPointerField(0).asCap());
}
inline void Cluster::AdminMaster::RegisterModelInstanceFactoryResults::Builder::setUnregister( ::mas::schema::cluster::Cluster::Unregister::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::Unregister>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Cluster::AdminMaster::RegisterModelInstanceFactoryResults::Builder::setUnregister( ::mas::schema::cluster::Cluster::Unregister::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::Unregister>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Cluster::AdminMaster::RegisterModelInstanceFactoryResults::Builder::adoptUnregister(
    ::capnp::Orphan< ::mas::schema::cluster::Cluster::Unregister>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::Unregister>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::cluster::Cluster::Unregister> Cluster::AdminMaster::RegisterModelInstanceFactoryResults::Builder::disownUnregister() {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::Unregister>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Cluster::AdminMaster::AvailableModelsResults::Reader::hasFactories() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Cluster::AdminMaster::AvailableModelsResults::Builder::hasFactories() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>::Reader Cluster::AdminMaster::AvailableModelsResults::Reader::getFactories() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>::Builder Cluster::AdminMaster::AvailableModelsResults::Builder::getFactories() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Cluster::AdminMaster::AvailableModelsResults::Builder::setFactories( ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>::Builder Cluster::AdminMaster::AvailableModelsResults::Builder::initFactories(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Cluster::AdminMaster::AvailableModelsResults::Builder::adoptFactories(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>> Cluster::AdminMaster::AvailableModelsResults::Builder::disownFactories() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
inline Cluster::UserMaster::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Cluster::UserMaster::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Cluster::UserMaster::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Cluster::UserMaster::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Cluster::UserMaster::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::cluster::Cluster::UserMaster::Client& Cluster::UserMaster::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::cluster::Cluster::UserMaster::Client& Cluster::UserMaster::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Cluster::UserMaster::AvailableModelsResults::Reader::hasFactories() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Cluster::UserMaster::AvailableModelsResults::Builder::hasFactories() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>::Reader Cluster::UserMaster::AvailableModelsResults::Reader::getFactories() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>::Builder Cluster::UserMaster::AvailableModelsResults::Builder::getFactories() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Cluster::UserMaster::AvailableModelsResults::Builder::setFactories( ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>::Builder Cluster::UserMaster::AvailableModelsResults::Builder::initFactories(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Cluster::UserMaster::AvailableModelsResults::Builder::adoptFactories(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>> Cluster::UserMaster::AvailableModelsResults::Builder::disownFactories() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
inline Cluster::Runtime::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Cluster::Runtime::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Cluster::Runtime::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Cluster::Runtime::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Cluster::Runtime::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::cluster::Cluster::Runtime::Client& Cluster::Runtime::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::cluster::Cluster::Runtime::Client& Cluster::Runtime::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Cluster::Runtime::RegisterModelInstanceFactoryParams::Reader::hasAModelId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Cluster::Runtime::RegisterModelInstanceFactoryParams::Builder::hasAModelId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Cluster::Runtime::RegisterModelInstanceFactoryParams::Reader::getAModelId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Cluster::Runtime::RegisterModelInstanceFactoryParams::Builder::getAModelId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Cluster::Runtime::RegisterModelInstanceFactoryParams::Builder::setAModelId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Cluster::Runtime::RegisterModelInstanceFactoryParams::Builder::initAModelId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Cluster::Runtime::RegisterModelInstanceFactoryParams::Builder::adoptAModelId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Cluster::Runtime::RegisterModelInstanceFactoryParams::Builder::disownAModelId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Cluster::Runtime::RegisterModelInstanceFactoryParams::Reader::hasAFactory() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Cluster::Runtime::RegisterModelInstanceFactoryParams::Builder::hasAFactory() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::cluster::Cluster::ModelInstanceFactory::Client Cluster::Runtime::RegisterModelInstanceFactoryParams::Reader::getAFactory() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ModelInstanceFactory>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::cluster::Cluster::ModelInstanceFactory::Client Cluster::Runtime::RegisterModelInstanceFactoryParams::Builder::getAFactory() {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ModelInstanceFactory>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::cluster::Cluster::ModelInstanceFactory::Client Cluster::Runtime::RegisterModelInstanceFactoryParams::Pipeline::getAFactory() {
  return  ::mas::schema::cluster::Cluster::ModelInstanceFactory::Client(_typeless.getPointerField(1).asCap());
}
inline void Cluster::Runtime::RegisterModelInstanceFactoryParams::Builder::setAFactory( ::mas::schema::cluster::Cluster::ModelInstanceFactory::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ModelInstanceFactory>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Cluster::Runtime::RegisterModelInstanceFactoryParams::Builder::setAFactory( ::mas::schema::cluster::Cluster::ModelInstanceFactory::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ModelInstanceFactory>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), cap);
}
inline void Cluster::Runtime::RegisterModelInstanceFactoryParams::Builder::adoptAFactory(
    ::capnp::Orphan< ::mas::schema::cluster::Cluster::ModelInstanceFactory>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ModelInstanceFactory>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::cluster::Cluster::ModelInstanceFactory> Cluster::Runtime::RegisterModelInstanceFactoryParams::Builder::disownAFactory() {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ModelInstanceFactory>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Cluster::Runtime::RegisterModelInstanceFactoryResults::Reader::hasUnregister() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Cluster::Runtime::RegisterModelInstanceFactoryResults::Builder::hasUnregister() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::cluster::Cluster::Unregister::Client Cluster::Runtime::RegisterModelInstanceFactoryResults::Reader::getUnregister() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::Unregister>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::cluster::Cluster::Unregister::Client Cluster::Runtime::RegisterModelInstanceFactoryResults::Builder::getUnregister() {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::Unregister>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::cluster::Cluster::Unregister::Client Cluster::Runtime::RegisterModelInstanceFactoryResults::Pipeline::getUnregister() {
  return  ::mas::schema::cluster::Cluster::Unregister::Client(_typeless.getPointerField(0).asCap());
}
inline void Cluster::Runtime::RegisterModelInstanceFactoryResults::Builder::setUnregister( ::mas::schema::cluster::Cluster::Unregister::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::Unregister>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Cluster::Runtime::RegisterModelInstanceFactoryResults::Builder::setUnregister( ::mas::schema::cluster::Cluster::Unregister::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::Unregister>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Cluster::Runtime::RegisterModelInstanceFactoryResults::Builder::adoptUnregister(
    ::capnp::Orphan< ::mas::schema::cluster::Cluster::Unregister>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::Unregister>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::cluster::Cluster::Unregister> Cluster::Runtime::RegisterModelInstanceFactoryResults::Builder::disownUnregister() {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::Unregister>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Cluster::Runtime::AvailableModelsResults::Reader::hasFactories() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Cluster::Runtime::AvailableModelsResults::Builder::hasFactories() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>::Reader Cluster::Runtime::AvailableModelsResults::Reader::getFactories() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>::Builder Cluster::Runtime::AvailableModelsResults::Builder::getFactories() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Cluster::Runtime::AvailableModelsResults::Builder::setFactories( ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>::Builder Cluster::Runtime::AvailableModelsResults::Builder::initFactories(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Cluster::Runtime::AvailableModelsResults::Builder::adoptFactories(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>> Cluster::Runtime::AvailableModelsResults::Builder::disownFactories() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::cluster::Cluster::ModelInstanceFactory,  ::capnp::Kind::INTERFACE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline  ::int16_t Cluster::Runtime::NumberOfCoresResults::Reader::getCores() const {
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int16_t Cluster::Runtime::NumberOfCoresResults::Builder::getCores() {
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Cluster::Runtime::NumberOfCoresResults::Builder::setCores( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int16_t Cluster::Runtime::FreeNumberOfCoresResults::Reader::getCores() const {
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int16_t Cluster::Runtime::FreeNumberOfCoresResults::Builder::getCores() {
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Cluster::Runtime::FreeNumberOfCoresResults::Builder::setCores( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int16_t Cluster::Runtime::ReserveNumberOfCoresParams::Reader::getReserveCores() const {
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int16_t Cluster::Runtime::ReserveNumberOfCoresParams::Builder::getReserveCores() {
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Cluster::Runtime::ReserveNumberOfCoresParams::Builder::setReserveCores( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Cluster::Runtime::ReserveNumberOfCoresParams::Reader::hasAModelId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Cluster::Runtime::ReserveNumberOfCoresParams::Builder::hasAModelId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Cluster::Runtime::ReserveNumberOfCoresParams::Reader::getAModelId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Cluster::Runtime::ReserveNumberOfCoresParams::Builder::getAModelId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Cluster::Runtime::ReserveNumberOfCoresParams::Builder::setAModelId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Cluster::Runtime::ReserveNumberOfCoresParams::Builder::initAModelId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Cluster::Runtime::ReserveNumberOfCoresParams::Builder::adoptAModelId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Cluster::Runtime::ReserveNumberOfCoresParams::Builder::disownAModelId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int16_t Cluster::Runtime::ReserveNumberOfCoresResults::Reader::getReservedCores() const {
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int16_t Cluster::Runtime::ReserveNumberOfCoresResults::Builder::getReservedCores() {
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Cluster::Runtime::ReserveNumberOfCoresResults::Builder::setReservedCores( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Cluster::ZmqPipelineAddresses::Reader::hasInput() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Cluster::ZmqPipelineAddresses::Builder::hasInput() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Cluster::ZmqPipelineAddresses::Reader::getInput() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Cluster::ZmqPipelineAddresses::Builder::getInput() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Cluster::ZmqPipelineAddresses::Builder::setInput( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Cluster::ZmqPipelineAddresses::Builder::initInput(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Cluster::ZmqPipelineAddresses::Builder::adoptInput(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Cluster::ZmqPipelineAddresses::Builder::disownInput() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Cluster::ZmqPipelineAddresses::Reader::hasOutput() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Cluster::ZmqPipelineAddresses::Builder::hasOutput() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Cluster::ZmqPipelineAddresses::Reader::getOutput() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Cluster::ZmqPipelineAddresses::Builder::getOutput() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Cluster::ZmqPipelineAddresses::Builder::setOutput( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Cluster::ZmqPipelineAddresses::Builder::initOutput(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Cluster::ZmqPipelineAddresses::Builder::adoptOutput(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Cluster::ZmqPipelineAddresses::Builder::disownOutput() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
template <typename T>
inline Cluster::ValueHolder<T>::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
template <typename T>
inline Cluster::ValueHolder<T>::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename T>
template <typename _t, typename>
inline Cluster::ValueHolder<T>::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename T>
template <typename _t, typename>
inline Cluster::ValueHolder<T>::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
template <typename T>
inline Cluster::ValueHolder<T>::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
template <typename T>
inline typename  ::mas::schema::cluster::Cluster::ValueHolder<T>::Client& Cluster::ValueHolder<T>::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
template <typename T>
inline typename  ::mas::schema::cluster::Cluster::ValueHolder<T>::Client& Cluster::ValueHolder<T>::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
// Cluster::ValueHolder<T>::ValueParams
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
constexpr uint16_t Cluster::ValueHolder<T>::ValueParams::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t Cluster::ValueHolder<T>::ValueParams::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
constexpr ::capnp::Kind Cluster::ValueHolder<T>::ValueParams::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* Cluster::ValueHolder<T>::ValueParams::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope Cluster::ValueHolder<T>::ValueParams::_capnpPrivate::brandScopes[] = {
  { 0xd6acf080dcf2b4c8, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding Cluster::ValueHolder<T>::ValueParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema Cluster::ValueHolder<T>::ValueParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_8ba6569cca01e84f, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename T>
inline bool Cluster::ValueHolder<T>::ValueResults::Reader::hasVal() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool Cluster::ValueHolder<T>::ValueResults::Builder::hasVal() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline  ::capnp::ReaderFor<T> Cluster::ValueHolder<T>::ValueResults::Reader::getVal() const {
  return ::capnp::_::PointerHelpers<T>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline  ::capnp::BuilderFor<T> Cluster::ValueHolder<T>::ValueResults::Builder::getVal() {
  return ::capnp::_::PointerHelpers<T>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename T>
inline  ::capnp::PipelineFor<T> Cluster::ValueHolder<T>::ValueResults::Pipeline::getVal() {
  return  ::capnp::PipelineFor<T>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename T>
inline void Cluster::ValueHolder<T>::ValueResults::Builder::setVal( ::capnp::ReaderFor<T> value) {
  ::capnp::_::PointerHelpers<T>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename T>
inline  ::capnp::BuilderFor<T> Cluster::ValueHolder<T>::ValueResults::Builder::initVal() {
  return ::capnp::_::PointerHelpers<T>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline  ::capnp::BuilderFor<T> Cluster::ValueHolder<T>::ValueResults::Builder::initVal(unsigned int size) {
  return ::capnp::_::PointerHelpers<T>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename T>
inline void Cluster::ValueHolder<T>::ValueResults::Builder::adoptVal(
    ::capnp::Orphan<T>&& value) {
  ::capnp::_::PointerHelpers<T>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan<T> Cluster::ValueHolder<T>::ValueResults::Builder::disownVal() {
  return ::capnp::_::PointerHelpers<T>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// Cluster::ValueHolder<T>::ValueResults
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
constexpr uint16_t Cluster::ValueHolder<T>::ValueResults::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t Cluster::ValueHolder<T>::ValueResults::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
constexpr ::capnp::Kind Cluster::ValueHolder<T>::ValueResults::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* Cluster::ValueHolder<T>::ValueResults::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope Cluster::ValueHolder<T>::ValueResults::_capnpPrivate::brandScopes[] = {
  { 0xd6acf080dcf2b4c8, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding Cluster::ValueHolder<T>::ValueResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema Cluster::ValueHolder<T>::ValueResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_815e89f778f1da6c, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Cluster::ValueHolder<T>::ReleaseParams
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
constexpr uint16_t Cluster::ValueHolder<T>::ReleaseParams::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t Cluster::ValueHolder<T>::ReleaseParams::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
constexpr ::capnp::Kind Cluster::ValueHolder<T>::ReleaseParams::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* Cluster::ValueHolder<T>::ReleaseParams::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope Cluster::ValueHolder<T>::ReleaseParams::_capnpPrivate::brandScopes[] = {
  { 0xd6acf080dcf2b4c8, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding Cluster::ValueHolder<T>::ReleaseParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema Cluster::ValueHolder<T>::ReleaseParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_a967c8b00a278896, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Cluster::ValueHolder<T>::ReleaseResults
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
constexpr uint16_t Cluster::ValueHolder<T>::ReleaseResults::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t Cluster::ValueHolder<T>::ReleaseResults::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
constexpr ::capnp::Kind Cluster::ValueHolder<T>::ReleaseResults::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* Cluster::ValueHolder<T>::ReleaseResults::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope Cluster::ValueHolder<T>::ReleaseResults::_capnpPrivate::brandScopes[] = {
  { 0xd6acf080dcf2b4c8, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding Cluster::ValueHolder<T>::ReleaseResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema Cluster::ValueHolder<T>::ReleaseResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_ddbd9a18593be0c5, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename T>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::cluster::Cluster::ValueHolder<T>::ValueParams, typename  ::mas::schema::cluster::Cluster::ValueHolder<T>::ValueResults>)
Cluster::ValueHolder<T>::Client::valueRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::cluster::Cluster::ValueHolder<T>::ValueParams, typename  ::mas::schema::cluster::Cluster::ValueHolder<T>::ValueResults>(
      0xd6acf080dcf2b4c8ull, 0, sizeHint, {false});
}
template <typename T>
::kj::Promise<void> Cluster::ValueHolder<T>::Server::value(ValueContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "cluster_admin_service.capnp:Cluster.ValueHolder", "value",
      0xd6acf080dcf2b4c8ull, 0);
}
template <typename T>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::cluster::Cluster::ValueHolder<T>::ReleaseParams, typename  ::mas::schema::cluster::Cluster::ValueHolder<T>::ReleaseResults>)
Cluster::ValueHolder<T>::Client::releaseRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::cluster::Cluster::ValueHolder<T>::ReleaseParams, typename  ::mas::schema::cluster::Cluster::ValueHolder<T>::ReleaseResults>(
      0xd6acf080dcf2b4c8ull, 1, sizeHint, {true});
}
template <typename T>
::kj::Promise<void> Cluster::ValueHolder<T>::Server::release(ReleaseContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "cluster_admin_service.capnp:Cluster.ValueHolder", "release",
      0xd6acf080dcf2b4c8ull, 1);
}
template <typename T>
::capnp::Capability::Server::DispatchCallResult Cluster::ValueHolder<T>::Server::dispatchCall(
    uint64_t interfaceId, uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (interfaceId) {
    case 0xd6acf080dcf2b4c8ull:
      return dispatchCallInternal(methodId, context);
    default:
      return internalUnimplemented("cluster_admin_service.capnp:Cluster.ValueHolder", interfaceId);
  }
}
template <typename T>
::capnp::Capability::Server::DispatchCallResult Cluster::ValueHolder<T>::Server::dispatchCallInternal(
    uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (methodId) {
    case 0:
      return {
        value(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::cluster::Cluster::ValueHolder<T>::ValueParams, typename  ::mas::schema::cluster::Cluster::ValueHolder<T>::ValueResults>(context)),
        false,
        false
      };
    case 1:
      return {
        release(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::cluster::Cluster::ValueHolder<T>::ReleaseParams, typename  ::mas::schema::cluster::Cluster::ValueHolder<T>::ReleaseResults>(context)),
        false,
        false
      };
    default:
      (void)context;
      return ::capnp::Capability::Server::internalUnimplemented(
          "cluster_admin_service.capnp:Cluster.ValueHolder",
          0xd6acf080dcf2b4c8ull, methodId);
  }
}
#endif  // !CAPNP_LITE

// Cluster::ValueHolder<T>
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
constexpr ::capnp::Kind Cluster::ValueHolder<T>::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* Cluster::ValueHolder<T>::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope Cluster::ValueHolder<T>::_capnpPrivate::brandScopes[] = {
  { 0xd6acf080dcf2b4c8, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding Cluster::ValueHolder<T>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Dependency Cluster::ValueHolder<T>::_capnpPrivate::brandDependencies[] = {
  { 33554432,  ::mas::schema::cluster::Cluster::ValueHolder<T>::ValueParams::_capnpPrivate::brand() },
  { 33554433,  ::mas::schema::cluster::Cluster::ValueHolder<T>::ReleaseParams::_capnpPrivate::brand() },
  { 50331648,  ::mas::schema::cluster::Cluster::ValueHolder<T>::ValueResults::_capnpPrivate::brand() },
  { 50331649,  ::mas::schema::cluster::Cluster::ValueHolder<T>::ReleaseResults::_capnpPrivate::brand() },
};
template <typename T>
const ::capnp::_::RawBrandedSchema Cluster::ValueHolder<T>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_d6acf080dcf2b4c8, brandScopes, brandDependencies,
  1, 4, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
inline Cluster::ModelInstanceFactory::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Cluster::ModelInstanceFactory::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Cluster::ModelInstanceFactory::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Cluster::ModelInstanceFactory::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Cluster::ModelInstanceFactory::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::cluster::Cluster::ModelInstanceFactory::Client& Cluster::ModelInstanceFactory::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::cluster::Cluster::ModelInstanceFactory::Client& Cluster::ModelInstanceFactory::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Cluster::ModelInstanceFactory::NewInstanceResults::Reader::hasInstance() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Cluster::ModelInstanceFactory::NewInstanceResults::Builder::hasInstance() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client Cluster::ModelInstanceFactory::NewInstanceResults::Reader::getInstance() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client Cluster::ModelInstanceFactory::NewInstanceResults::Builder::getInstance() {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client Cluster::ModelInstanceFactory::NewInstanceResults::Pipeline::getInstance() {
  return  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client(_typeless.getPointerField(0).asCap());
}
inline void Cluster::ModelInstanceFactory::NewInstanceResults::Builder::setInstance( ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Cluster::ModelInstanceFactory::NewInstanceResults::Builder::setInstance( ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Cluster::ModelInstanceFactory::NewInstanceResults::Builder::adoptInstance(
    ::capnp::Orphan< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>> Cluster::ModelInstanceFactory::NewInstanceResults::Builder::disownInstance() {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline  ::int16_t Cluster::ModelInstanceFactory::NewInstancesParams::Reader::getNumberOfInstances() const {
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int16_t Cluster::ModelInstanceFactory::NewInstancesParams::Builder::getNumberOfInstances() {
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Cluster::ModelInstanceFactory::NewInstancesParams::Builder::setNumberOfInstances( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Cluster::ModelInstanceFactory::NewInstancesResults::Reader::hasInstances() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Cluster::ModelInstanceFactory::NewInstancesResults::Builder::hasInstances() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::List< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>,  ::capnp::Kind::INTERFACE>>::Client Cluster::ModelInstanceFactory::NewInstancesResults::Reader::getInstances() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::List< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>,  ::capnp::Kind::INTERFACE>>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::List< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>,  ::capnp::Kind::INTERFACE>>::Client Cluster::ModelInstanceFactory::NewInstancesResults::Builder::getInstances() {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::List< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>,  ::capnp::Kind::INTERFACE>>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::List< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>,  ::capnp::Kind::INTERFACE>>::Client Cluster::ModelInstanceFactory::NewInstancesResults::Pipeline::getInstances() {
  return  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::List< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>,  ::capnp::Kind::INTERFACE>>::Client(_typeless.getPointerField(0).asCap());
}
inline void Cluster::ModelInstanceFactory::NewInstancesResults::Builder::setInstances( ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::List< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>,  ::capnp::Kind::INTERFACE>>::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::List< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>,  ::capnp::Kind::INTERFACE>>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Cluster::ModelInstanceFactory::NewInstancesResults::Builder::setInstances( ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::List< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>,  ::capnp::Kind::INTERFACE>>::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::List< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>,  ::capnp::Kind::INTERFACE>>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Cluster::ModelInstanceFactory::NewInstancesResults::Builder::adoptInstances(
    ::capnp::Orphan< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::List< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>,  ::capnp::Kind::INTERFACE>>>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::List< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>,  ::capnp::Kind::INTERFACE>>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::List< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>,  ::capnp::Kind::INTERFACE>>> Cluster::ModelInstanceFactory::NewInstancesResults::Builder::disownInstances() {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::List< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>,  ::capnp::Kind::INTERFACE>>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline  ::int16_t Cluster::ModelInstanceFactory::NewCloudViaZmqPipelineProxiesParams::Reader::getNumberOfInstances() const {
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int16_t Cluster::ModelInstanceFactory::NewCloudViaZmqPipelineProxiesParams::Builder::getNumberOfInstances() {
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Cluster::ModelInstanceFactory::NewCloudViaZmqPipelineProxiesParams::Builder::setNumberOfInstances( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Cluster::ModelInstanceFactory::NewCloudViaZmqPipelineProxiesResults::Reader::hasProxyAddresses() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Cluster::ModelInstanceFactory::NewCloudViaZmqPipelineProxiesResults::Builder::hasProxyAddresses() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::cluster::Cluster::ValueHolder< ::mas::schema::cluster::Cluster::ZmqPipelineAddresses>::Client Cluster::ModelInstanceFactory::NewCloudViaZmqPipelineProxiesResults::Reader::getProxyAddresses() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::mas::schema::cluster::Cluster::ZmqPipelineAddresses>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::cluster::Cluster::ValueHolder< ::mas::schema::cluster::Cluster::ZmqPipelineAddresses>::Client Cluster::ModelInstanceFactory::NewCloudViaZmqPipelineProxiesResults::Builder::getProxyAddresses() {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::mas::schema::cluster::Cluster::ZmqPipelineAddresses>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::cluster::Cluster::ValueHolder< ::mas::schema::cluster::Cluster::ZmqPipelineAddresses>::Client Cluster::ModelInstanceFactory::NewCloudViaZmqPipelineProxiesResults::Pipeline::getProxyAddresses() {
  return  ::mas::schema::cluster::Cluster::ValueHolder< ::mas::schema::cluster::Cluster::ZmqPipelineAddresses>::Client(_typeless.getPointerField(0).asCap());
}
inline void Cluster::ModelInstanceFactory::NewCloudViaZmqPipelineProxiesResults::Builder::setProxyAddresses( ::mas::schema::cluster::Cluster::ValueHolder< ::mas::schema::cluster::Cluster::ZmqPipelineAddresses>::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::mas::schema::cluster::Cluster::ZmqPipelineAddresses>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Cluster::ModelInstanceFactory::NewCloudViaZmqPipelineProxiesResults::Builder::setProxyAddresses( ::mas::schema::cluster::Cluster::ValueHolder< ::mas::schema::cluster::Cluster::ZmqPipelineAddresses>::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::mas::schema::cluster::Cluster::ZmqPipelineAddresses>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Cluster::ModelInstanceFactory::NewCloudViaZmqPipelineProxiesResults::Builder::adoptProxyAddresses(
    ::capnp::Orphan< ::mas::schema::cluster::Cluster::ValueHolder< ::mas::schema::cluster::Cluster::ZmqPipelineAddresses>>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::mas::schema::cluster::Cluster::ZmqPipelineAddresses>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::cluster::Cluster::ValueHolder< ::mas::schema::cluster::Cluster::ZmqPipelineAddresses>> Cluster::ModelInstanceFactory::NewCloudViaZmqPipelineProxiesResults::Builder::disownProxyAddresses() {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::mas::schema::cluster::Cluster::ZmqPipelineAddresses>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline  ::int16_t Cluster::ModelInstanceFactory::NewCloudViaProxyParams::Reader::getNumberOfInstances() const {
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int16_t Cluster::ModelInstanceFactory::NewCloudViaProxyParams::Builder::getNumberOfInstances() {
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Cluster::ModelInstanceFactory::NewCloudViaProxyParams::Builder::setNumberOfInstances( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Cluster::ModelInstanceFactory::NewCloudViaProxyResults::Reader::hasProxy() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Cluster::ModelInstanceFactory::NewCloudViaProxyResults::Builder::hasProxy() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client Cluster::ModelInstanceFactory::NewCloudViaProxyResults::Reader::getProxy() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client Cluster::ModelInstanceFactory::NewCloudViaProxyResults::Builder::getProxy() {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client Cluster::ModelInstanceFactory::NewCloudViaProxyResults::Pipeline::getProxy() {
  return  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client(_typeless.getPointerField(0).asCap());
}
inline void Cluster::ModelInstanceFactory::NewCloudViaProxyResults::Builder::setProxy( ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Cluster::ModelInstanceFactory::NewCloudViaProxyResults::Builder::setProxy( ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Cluster::ModelInstanceFactory::NewCloudViaProxyResults::Builder::adoptProxy(
    ::capnp::Orphan< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>> Cluster::ModelInstanceFactory::NewCloudViaProxyResults::Builder::disownProxy() {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Cluster::ModelInstanceFactory::ModelIdResults::Reader::hasId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Cluster::ModelInstanceFactory::ModelIdResults::Builder::hasId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Cluster::ModelInstanceFactory::ModelIdResults::Reader::getId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Cluster::ModelInstanceFactory::ModelIdResults::Builder::getId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Cluster::ModelInstanceFactory::ModelIdResults::Builder::setId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Cluster::ModelInstanceFactory::ModelIdResults::Builder::initId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Cluster::ModelInstanceFactory::ModelIdResults::Builder::adoptId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Cluster::ModelInstanceFactory::ModelIdResults::Builder::disownId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Cluster::ModelInstanceFactory::RegisterModelInstanceParams::Reader::hasInstance() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Cluster::ModelInstanceFactory::RegisterModelInstanceParams::Builder::hasInstance() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnp::Capability::Client Cluster::ModelInstanceFactory::RegisterModelInstanceParams::Reader::getInstance() const {
  return ::capnp::_::PointerHelpers< ::capnp::Capability>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Capability::Client Cluster::ModelInstanceFactory::RegisterModelInstanceParams::Builder::getInstance() {
  return ::capnp::_::PointerHelpers< ::capnp::Capability>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Capability::Client Cluster::ModelInstanceFactory::RegisterModelInstanceParams::Pipeline::getInstance() {
  return  ::capnp::Capability::Client(_typeless.getPointerField(0).asCap());
}
inline void Cluster::ModelInstanceFactory::RegisterModelInstanceParams::Builder::setInstance( ::capnp::Capability::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnp::Capability>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Cluster::ModelInstanceFactory::RegisterModelInstanceParams::Builder::setInstance( ::capnp::Capability::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnp::Capability>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Cluster::ModelInstanceFactory::RegisterModelInstanceParams::Builder::adoptInstance(
    ::capnp::Orphan< ::capnp::Capability>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Capability>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Capability> Cluster::ModelInstanceFactory::RegisterModelInstanceParams::Builder::disownInstance() {
  return ::capnp::_::PointerHelpers< ::capnp::Capability>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Cluster::ModelInstanceFactory::RegisterModelInstanceParams::Reader::hasRegistrationToken() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Cluster::ModelInstanceFactory::RegisterModelInstanceParams::Builder::hasRegistrationToken() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Cluster::ModelInstanceFactory::RegisterModelInstanceParams::Reader::getRegistrationToken() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_bea41d4487c101c4 + 57);
}
inline  ::capnp::Text::Builder Cluster::ModelInstanceFactory::RegisterModelInstanceParams::Builder::getRegistrationToken() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS),
        ::capnp::schemas::bp_bea41d4487c101c4 + 57);
}
inline void Cluster::ModelInstanceFactory::RegisterModelInstanceParams::Builder::setRegistrationToken( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Cluster::ModelInstanceFactory::RegisterModelInstanceParams::Builder::initRegistrationToken(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Cluster::ModelInstanceFactory::RegisterModelInstanceParams::Builder::adoptRegistrationToken(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Cluster::ModelInstanceFactory::RegisterModelInstanceParams::Builder::disownRegistrationToken() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Cluster::ModelInstanceFactory::RegisterModelInstanceResults::Reader::hasUnregister() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Cluster::ModelInstanceFactory::RegisterModelInstanceResults::Builder::hasUnregister() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::cluster::Cluster::Unregister::Client Cluster::ModelInstanceFactory::RegisterModelInstanceResults::Reader::getUnregister() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::Unregister>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::cluster::Cluster::Unregister::Client Cluster::ModelInstanceFactory::RegisterModelInstanceResults::Builder::getUnregister() {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::Unregister>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::cluster::Cluster::Unregister::Client Cluster::ModelInstanceFactory::RegisterModelInstanceResults::Pipeline::getUnregister() {
  return  ::mas::schema::cluster::Cluster::Unregister::Client(_typeless.getPointerField(0).asCap());
}
inline void Cluster::ModelInstanceFactory::RegisterModelInstanceResults::Builder::setUnregister( ::mas::schema::cluster::Cluster::Unregister::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::Unregister>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Cluster::ModelInstanceFactory::RegisterModelInstanceResults::Builder::setUnregister( ::mas::schema::cluster::Cluster::Unregister::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::Unregister>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Cluster::ModelInstanceFactory::RegisterModelInstanceResults::Builder::adoptUnregister(
    ::capnp::Orphan< ::mas::schema::cluster::Cluster::Unregister>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::Unregister>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::cluster::Cluster::Unregister> Cluster::ModelInstanceFactory::RegisterModelInstanceResults::Builder::disownUnregister() {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::Unregister>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Cluster::ModelInstanceFactory::RestoreSturdyRefParams::Reader::hasSturdyRef() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Cluster::ModelInstanceFactory::RestoreSturdyRefParams::Builder::hasSturdyRef() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Cluster::ModelInstanceFactory::RestoreSturdyRefParams::Reader::getSturdyRef() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Cluster::ModelInstanceFactory::RestoreSturdyRefParams::Builder::getSturdyRef() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Cluster::ModelInstanceFactory::RestoreSturdyRefParams::Builder::setSturdyRef( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Cluster::ModelInstanceFactory::RestoreSturdyRefParams::Builder::initSturdyRef(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Cluster::ModelInstanceFactory::RestoreSturdyRefParams::Builder::adoptSturdyRef(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Cluster::ModelInstanceFactory::RestoreSturdyRefParams::Builder::disownSturdyRef() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Cluster::ModelInstanceFactory::RestoreSturdyRefResults::Reader::hasCap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Cluster::ModelInstanceFactory::RestoreSturdyRefResults::Builder::hasCap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client Cluster::ModelInstanceFactory::RestoreSturdyRefResults::Reader::getCap() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client Cluster::ModelInstanceFactory::RestoreSturdyRefResults::Builder::getCap() {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client Cluster::ModelInstanceFactory::RestoreSturdyRefResults::Pipeline::getCap() {
  return  ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client(_typeless.getPointerField(0).asCap());
}
inline void Cluster::ModelInstanceFactory::RestoreSturdyRefResults::Builder::setCap( ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Cluster::ModelInstanceFactory::RestoreSturdyRefResults::Builder::setCap( ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Cluster::ModelInstanceFactory::RestoreSturdyRefResults::Builder::adoptCap(
    ::capnp::Orphan< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>> Cluster::ModelInstanceFactory::RestoreSturdyRefResults::Builder::disownCap() {
  return ::capnp::_::PointerHelpers< ::mas::schema::cluster::Cluster::ValueHolder< ::capnp::AnyPointer>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

