// Code generated by capnpc-go. DO NOT EDIT.

package test

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	context "context"
	math "math"
)

type S struct{ capnp.Struct }

// S_TypeID is the unique identifier for the type S.
const S_TypeID = 0xd227ef68de0bc647

func NewS(s *capnp.Segment) (S, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return S{st}, err
}

func NewRootS(s *capnp.Segment) (S, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return S{st}, err
}

func ReadRootS(msg *capnp.Message) (S, error) {
	root, err := msg.Root()
	return S{root.Struct()}, err
}

func (s S) String() string {
	str, _ := text.Marshal(0xd227ef68de0bc647, s.Struct)
	return str
}

func (s S) C() X {
	p, _ := s.Struct.Ptr(0)
	return X{Client: p.Interface().Client()}
}

func (s S) HasC() bool {
	return s.Struct.HasPtr(0)
}

func (s S) SetC(v X) error {
	if !v.Client.IsValid() {
		return s.Struct.SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(v.Client))
	return s.Struct.SetPtr(0, in.ToPtr())
}

// S_List is a list of S.
type S_List struct{ capnp.List }

// NewS creates a new list of S.
func NewS_List(s *capnp.Segment, sz int32) (S_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return S_List{l}, err
}

func (s S_List) At(i int) S { return S{s.List.Struct(i)} }

func (s S_List) Set(i int, v S) error { return s.List.SetStruct(i, v.Struct) }

func (s S_List) String() string {
	str, _ := text.MarshalList(0xd227ef68de0bc647, s.List)
	return str
}

// S_Future is a wrapper for a S promised by a client call.
type S_Future struct{ *capnp.Future }

func (p S_Future) Struct() (S, error) {
	s, err := p.Future.Struct()
	return S{s}, err
}

func (p S_Future) C() X {
	return X{Client: p.Future.Field(0, nil).Client()}
}

type X struct{ Client *capnp.Client }

// X_TypeID is the unique identifier for the type X.
const X_TypeID = 0xdcf28e81fa4de615

func (c X) M(ctx context.Context, params func(X_m_Params) error) (X_m_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xdcf28e81fa4de615,
			MethodID:      0,
			InterfaceName: "x.capnp:X",
			MethodName:    "m",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 8, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(X_m_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return X_m_Results_Future{Future: ans.Future()}, release
}

func (c X) AddRef() X {
	return X{
		Client: c.Client.AddRef(),
	}
}

func (c X) Release() {
	c.Client.Release()
}

// A X_Server is a X with a local implementation.
type X_Server interface {
	M(context.Context, X_m) error
}

// X_NewServer creates a new Server from an implementation of X_Server.
func X_NewServer(s X_Server, policy *server.Policy) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(X_Methods(nil, s), s, c, policy)
}

// X_ServerToClient creates a new Client from an implementation of X_Server.
// The caller is responsible for calling Release on the returned Client.
func X_ServerToClient(s X_Server, policy *server.Policy) X {
	return X{Client: capnp.NewClient(X_NewServer(s, policy))}
}

// X_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func X_Methods(methods []server.Method, s X_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xdcf28e81fa4de615,
			MethodID:      0,
			InterfaceName: "x.capnp:X",
			MethodName:    "m",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.M(ctx, X_m{call})
		},
	})

	return methods
}

// X_m holds the state for a server call to X.m.
// See server.Call for documentation.
type X_m struct {
	*server.Call
}

// Args returns the call's arguments.
func (c X_m) Args() X_m_Params {
	return X_m_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c X_m) AllocResults() (X_m_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return X_m_Results{Struct: r}, err
}

type X_m_Params struct{ capnp.Struct }

// X_m_Params_TypeID is the unique identifier for the type X_m_Params.
const X_m_Params_TypeID = 0xc68563695ada2a40

func NewX_m_Params(s *capnp.Segment) (X_m_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return X_m_Params{st}, err
}

func NewRootX_m_Params(s *capnp.Segment) (X_m_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return X_m_Params{st}, err
}

func ReadRootX_m_Params(msg *capnp.Message) (X_m_Params, error) {
	root, err := msg.Root()
	return X_m_Params{root.Struct()}, err
}

func (s X_m_Params) String() string {
	str, _ := text.Marshal(0xc68563695ada2a40, s.Struct)
	return str
}

func (s X_m_Params) I() int64 {
	return int64(s.Struct.Uint64(0))
}

func (s X_m_Params) SetI(v int64) {
	s.Struct.SetUint64(0, uint64(v))
}

// X_m_Params_List is a list of X_m_Params.
type X_m_Params_List struct{ capnp.List }

// NewX_m_Params creates a new list of X_m_Params.
func NewX_m_Params_List(s *capnp.Segment, sz int32) (X_m_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return X_m_Params_List{l}, err
}

func (s X_m_Params_List) At(i int) X_m_Params { return X_m_Params{s.List.Struct(i)} }

func (s X_m_Params_List) Set(i int, v X_m_Params) error { return s.List.SetStruct(i, v.Struct) }

func (s X_m_Params_List) String() string {
	str, _ := text.MarshalList(0xc68563695ada2a40, s.List)
	return str
}

// X_m_Params_Future is a wrapper for a X_m_Params promised by a client call.
type X_m_Params_Future struct{ *capnp.Future }

func (p X_m_Params_Future) Struct() (X_m_Params, error) {
	s, err := p.Future.Struct()
	return X_m_Params{s}, err
}

type X_m_Results struct{ capnp.Struct }

// X_m_Results_TypeID is the unique identifier for the type X_m_Results.
const X_m_Results_TypeID = 0x86aae6bcee1a970d

func NewX_m_Results(s *capnp.Segment) (X_m_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return X_m_Results{st}, err
}

func NewRootX_m_Results(s *capnp.Segment) (X_m_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return X_m_Results{st}, err
}

func ReadRootX_m_Results(msg *capnp.Message) (X_m_Results, error) {
	root, err := msg.Root()
	return X_m_Results{root.Struct()}, err
}

func (s X_m_Results) String() string {
	str, _ := text.Marshal(0x86aae6bcee1a970d, s.Struct)
	return str
}

func (s X_m_Results) T() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s X_m_Results) HasT() bool {
	return s.Struct.HasPtr(0)
}

func (s X_m_Results) TBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s X_m_Results) SetT(v string) error {
	return s.Struct.SetText(0, v)
}

// X_m_Results_List is a list of X_m_Results.
type X_m_Results_List struct{ capnp.List }

// NewX_m_Results creates a new list of X_m_Results.
func NewX_m_Results_List(s *capnp.Segment, sz int32) (X_m_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return X_m_Results_List{l}, err
}

func (s X_m_Results_List) At(i int) X_m_Results { return X_m_Results{s.List.Struct(i)} }

func (s X_m_Results_List) Set(i int, v X_m_Results) error { return s.List.SetStruct(i, v.Struct) }

func (s X_m_Results_List) String() string {
	str, _ := text.MarshalList(0x86aae6bcee1a970d, s.List)
	return str
}

// X_m_Results_Future is a wrapper for a X_m_Results promised by a client call.
type X_m_Results_Future struct{ *capnp.Future }

func (p X_m_Results_Future) Struct() (X_m_Results, error) {
	s, err := p.Future.Struct()
	return X_m_Results{s}, err
}

type Y struct{ Client *capnp.Client }

// Y_TypeID is the unique identifier for the type Y.
const Y_TypeID = 0xac121e5aa82ca6bd

func (c Y) M(ctx context.Context, params func(Y_m_Params) error) (Y_m_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xac121e5aa82ca6bd,
			MethodID:      0,
			InterfaceName: "x.capnp:Y",
			MethodName:    "m",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Y_m_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return Y_m_Results_Future{Future: ans.Future()}, release
}

func (c Y) AddRef() Y {
	return Y{
		Client: c.Client.AddRef(),
	}
}

func (c Y) Release() {
	c.Client.Release()
}

// A Y_Server is a Y with a local implementation.
type Y_Server interface {
	M(context.Context, Y_m) error
}

// Y_NewServer creates a new Server from an implementation of Y_Server.
func Y_NewServer(s Y_Server, policy *server.Policy) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Y_Methods(nil, s), s, c, policy)
}

// Y_ServerToClient creates a new Client from an implementation of Y_Server.
// The caller is responsible for calling Release on the returned Client.
func Y_ServerToClient(s Y_Server, policy *server.Policy) Y {
	return Y{Client: capnp.NewClient(Y_NewServer(s, policy))}
}

// Y_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Y_Methods(methods []server.Method, s Y_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xac121e5aa82ca6bd,
			MethodID:      0,
			InterfaceName: "x.capnp:Y",
			MethodName:    "m",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.M(ctx, Y_m{call})
		},
	})

	return methods
}

// Y_m holds the state for a server call to Y.m.
// See server.Call for documentation.
type Y_m struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Y_m) Args() Y_m_Params {
	return Y_m_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c Y_m) AllocResults() (Y_m_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Y_m_Results{Struct: r}, err
}

type Y_m_Params struct{ capnp.Struct }

// Y_m_Params_TypeID is the unique identifier for the type Y_m_Params.
const Y_m_Params_TypeID = 0xc102bb9ca7ace092

func NewY_m_Params(s *capnp.Segment) (Y_m_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Y_m_Params{st}, err
}

func NewRootY_m_Params(s *capnp.Segment) (Y_m_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Y_m_Params{st}, err
}

func ReadRootY_m_Params(msg *capnp.Message) (Y_m_Params, error) {
	root, err := msg.Root()
	return Y_m_Params{root.Struct()}, err
}

func (s Y_m_Params) String() string {
	str, _ := text.Marshal(0xc102bb9ca7ace092, s.Struct)
	return str
}

func (s Y_m_Params) Hello() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Y_m_Params) HasHello() bool {
	return s.Struct.HasPtr(0)
}

func (s Y_m_Params) HelloBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Y_m_Params) SetHello(v string) error {
	return s.Struct.SetText(0, v)
}

// Y_m_Params_List is a list of Y_m_Params.
type Y_m_Params_List struct{ capnp.List }

// NewY_m_Params creates a new list of Y_m_Params.
func NewY_m_Params_List(s *capnp.Segment, sz int32) (Y_m_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return Y_m_Params_List{l}, err
}

func (s Y_m_Params_List) At(i int) Y_m_Params { return Y_m_Params{s.List.Struct(i)} }

func (s Y_m_Params_List) Set(i int, v Y_m_Params) error { return s.List.SetStruct(i, v.Struct) }

func (s Y_m_Params_List) String() string {
	str, _ := text.MarshalList(0xc102bb9ca7ace092, s.List)
	return str
}

// Y_m_Params_Future is a wrapper for a Y_m_Params promised by a client call.
type Y_m_Params_Future struct{ *capnp.Future }

func (p Y_m_Params_Future) Struct() (Y_m_Params, error) {
	s, err := p.Future.Struct()
	return Y_m_Params{s}, err
}

type Y_m_Results struct{ capnp.Struct }

// Y_m_Results_TypeID is the unique identifier for the type Y_m_Results.
const Y_m_Results_TypeID = 0xdcf58b9bef546812

func NewY_m_Results(s *capnp.Segment) (Y_m_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Y_m_Results{st}, err
}

func NewRootY_m_Results(s *capnp.Segment) (Y_m_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Y_m_Results{st}, err
}

func ReadRootY_m_Results(msg *capnp.Message) (Y_m_Results, error) {
	root, err := msg.Root()
	return Y_m_Results{root.Struct()}, err
}

func (s Y_m_Results) String() string {
	str, _ := text.Marshal(0xdcf58b9bef546812, s.Struct)
	return str
}

// Y_m_Results_List is a list of Y_m_Results.
type Y_m_Results_List struct{ capnp.List }

// NewY_m_Results creates a new list of Y_m_Results.
func NewY_m_Results_List(s *capnp.Segment, sz int32) (Y_m_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return Y_m_Results_List{l}, err
}

func (s Y_m_Results_List) At(i int) Y_m_Results { return Y_m_Results{s.List.Struct(i)} }

func (s Y_m_Results_List) Set(i int, v Y_m_Results) error { return s.List.SetStruct(i, v.Struct) }

func (s Y_m_Results_List) String() string {
	str, _ := text.MarshalList(0xdcf58b9bef546812, s.List)
	return str
}

// Y_m_Results_Future is a wrapper for a Y_m_Results promised by a client call.
type Y_m_Results_Future struct{ *capnp.Future }

func (p Y_m_Results_Future) Struct() (Y_m_Results, error) {
	s, err := p.Future.Struct()
	return Y_m_Results{s}, err
}

type A struct{ Client *capnp.Client }

// A_TypeID is the unique identifier for the type A.
const A_TypeID = 0xbab68c252196561b

func (c A) M(ctx context.Context, params func(A_m_Params) error) (A_m_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xbab68c252196561b,
			MethodID:      0,
			InterfaceName: "x.capnp:A",
			MethodName:    "m",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 8, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(A_m_Params{Struct: s}) }
	}
	ans, release := c.Client.SendCall(ctx, s)
	return A_m_Results_Future{Future: ans.Future()}, release
}

func (c A) AddRef() A {
	return A{
		Client: c.Client.AddRef(),
	}
}

func (c A) Release() {
	c.Client.Release()
}

// A A_Server is a A with a local implementation.
type A_Server interface {
	M(context.Context, A_m) error
}

// A_NewServer creates a new Server from an implementation of A_Server.
func A_NewServer(s A_Server, policy *server.Policy) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(A_Methods(nil, s), s, c, policy)
}

// A_ServerToClient creates a new Client from an implementation of A_Server.
// The caller is responsible for calling Release on the returned Client.
func A_ServerToClient(s A_Server, policy *server.Policy) A {
	return A{Client: capnp.NewClient(A_NewServer(s, policy))}
}

// A_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func A_Methods(methods []server.Method, s A_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xbab68c252196561b,
			MethodID:      0,
			InterfaceName: "x.capnp:A",
			MethodName:    "m",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.M(ctx, A_m{call})
		},
	})

	return methods
}

// A_m holds the state for a server call to A.m.
// See server.Call for documentation.
type A_m struct {
	*server.Call
}

// Args returns the call's arguments.
func (c A_m) Args() A_m_Params {
	return A_m_Params{Struct: c.Call.Args()}
}

// AllocResults allocates the results struct.
func (c A_m) AllocResults() (A_m_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return A_m_Results{Struct: r}, err
}

type A_m_Params struct{ capnp.Struct }

// A_m_Params_TypeID is the unique identifier for the type A_m_Params.
const A_m_Params_TypeID = 0x8be7edcd35d4c706

func NewA_m_Params(s *capnp.Segment) (A_m_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return A_m_Params{st}, err
}

func NewRootA_m_Params(s *capnp.Segment) (A_m_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return A_m_Params{st}, err
}

func ReadRootA_m_Params(msg *capnp.Message) (A_m_Params, error) {
	root, err := msg.Root()
	return A_m_Params{root.Struct()}, err
}

func (s A_m_Params) String() string {
	str, _ := text.Marshal(0x8be7edcd35d4c706, s.Struct)
	return str
}

func (s A_m_Params) N() int64 {
	return int64(s.Struct.Uint64(0))
}

func (s A_m_Params) SetN(v int64) {
	s.Struct.SetUint64(0, uint64(v))
}

// A_m_Params_List is a list of A_m_Params.
type A_m_Params_List struct{ capnp.List }

// NewA_m_Params creates a new list of A_m_Params.
func NewA_m_Params_List(s *capnp.Segment, sz int32) (A_m_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return A_m_Params_List{l}, err
}

func (s A_m_Params_List) At(i int) A_m_Params { return A_m_Params{s.List.Struct(i)} }

func (s A_m_Params_List) Set(i int, v A_m_Params) error { return s.List.SetStruct(i, v.Struct) }

func (s A_m_Params_List) String() string {
	str, _ := text.MarshalList(0x8be7edcd35d4c706, s.List)
	return str
}

// A_m_Params_Future is a wrapper for a A_m_Params promised by a client call.
type A_m_Params_Future struct{ *capnp.Future }

func (p A_m_Params_Future) Struct() (A_m_Params, error) {
	s, err := p.Future.Struct()
	return A_m_Params{s}, err
}

type A_m_Results struct{ capnp.Struct }

// A_m_Results_TypeID is the unique identifier for the type A_m_Results.
const A_m_Results_TypeID = 0xc0e8eed87688cb46

func NewA_m_Results(s *capnp.Segment) (A_m_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return A_m_Results{st}, err
}

func NewRootA_m_Results(s *capnp.Segment) (A_m_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return A_m_Results{st}, err
}

func ReadRootA_m_Results(msg *capnp.Message) (A_m_Results, error) {
	root, err := msg.Root()
	return A_m_Results{root.Struct()}, err
}

func (s A_m_Results) String() string {
	str, _ := text.Marshal(0xc0e8eed87688cb46, s.Struct)
	return str
}

func (s A_m_Results) R() float64 {
	return math.Float64frombits(s.Struct.Uint64(0))
}

func (s A_m_Results) SetR(v float64) {
	s.Struct.SetUint64(0, math.Float64bits(v))
}

// A_m_Results_List is a list of A_m_Results.
type A_m_Results_List struct{ capnp.List }

// NewA_m_Results creates a new list of A_m_Results.
func NewA_m_Results_List(s *capnp.Segment, sz int32) (A_m_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return A_m_Results_List{l}, err
}

func (s A_m_Results_List) At(i int) A_m_Results { return A_m_Results{s.List.Struct(i)} }

func (s A_m_Results_List) Set(i int, v A_m_Results) error { return s.List.SetStruct(i, v.Struct) }

func (s A_m_Results_List) String() string {
	str, _ := text.MarshalList(0xc0e8eed87688cb46, s.List)
	return str
}

// A_m_Results_Future is a wrapper for a A_m_Results promised by a client call.
type A_m_Results_Future struct{ *capnp.Future }

func (p A_m_Results_Future) Struct() (A_m_Results, error) {
	s, err := p.Future.Struct()
	return A_m_Results{s}, err
}

const schema_ffd06af2f026177b = "x\xda2p`t`2d\xbd\xce\xc2\xc0\x10h\xc1" +
	"\xca\xf6\x9fw\xba\xd4\xbb=\xcfV\xb51\x08r12" +
	"0\xb02\xb230\x08\x072-b`\x14\x0ed\xb2" +
	"g`\xfc\xcfv\xfc\x8a\xe9\xd9\xb7\xcf\xbb\x19\x02\xb9\x18" +
	"\x19\x19\x18X@\xf2\x85L\xb3\x18\x18\x85\x0b\xc1\xf2{" +
	"\x97\xe9\xac\x88\x92\x13Z\xc3 \xc8\xc1\xfc\xbfZ\\\xed" +
	"\xc3\xa7\xac\x0b\xff\x19\x18\x18\x85'2\x05\x09Oe\x02" +
	")\x9f\xc8\xe4.\xbc\x13\xc4\xfa/\x1d6MQ\xb5g" +
	"\xdb.\x0c\xc5\x0b\x99\x82\x84\x97\x82\x15/dr\x17>" +
	"\x09V\xecv\xba\xa3\xec\xc6\xbb\x17\x07\x90m\xde\x08v" +
	"\xd9F\xb0\xcd\x93\x1e\xacY>g7\xd3Ad\x97_" +
	"\x04\xbb\xec\"X\xdeA\xebVTfr\xeb1d\xfd" +
	"\x1f\xc1\xf2\x1f\xc1\xf2\xee\xc7\xb8\xefe\xbcW\xbf\xc4 " +
	"\xc8\xc1\x88p\x0c\xc4\x1cA\xe6 aQf\x08\x0b\xa4" +
	"V\xf4\x99\xef\xaf\xc6\xbeOw0\x1cn\xc8\x1c$l" +
	"\x0aVh\xc8\xec.\x1c\x09b\xfd\x17\xca\x08y?\xbb" +
	"\xfb\xeb\x1d\x88\xc3\xc0\xf6:2/b0\xf8_\xa1\x97" +
	"\x9cX\x90W`\xc5\x18\xa1\x97\xab\x12\x94Z\\\xca\x9e" +
	"SR\x1c\xc8\xc2\xcc\xc2\xc0\xc0\xc2\xc8\xc0 \xc8+\xc4" +
	"\xc0\x10\xc8\xc1\xcc\x18(\xc2\xc4\xc8X\xc2\xc8\xc3\xc0\xc4" +
	"\xc8\xc3\xc0\x88\xd0\xe6\xa8\x97\xab\x12\x90X\x94\xc8\x9c\x8b" +
	"SW\x1e#+\x03\x13#+\x92.\x06\xc6\xc8\x00F" +
	"\xc6@\x16fV\x06\x06x\x981\xc2\xdc(((\xc4" +
	"\xc0$\xc8\xca\xce\x98\xeb\xc0\x18\xc0\x88\xac\xcb\x11\xa1\x0b" +
	"\x96\x06\x18aQ\x82K\x17\xd8\x85\x84<V\xc4\xc8\xcd" +
	"\xc0\xc4\xc8\x8d\xec\xb1H\xec\x1e3B\xe8\x92\xcfH\xcd" +
	"\xc9\xc9\xc7\x0c\x92\x08\xc2A\x92\x89%H\x82!\x9e\xc3" +
	"\xaa>\x99Q\x10\x11\xdf\x0c\x8c\x8c\x82(:#\x10\xc1" +
	"\x02K`\x8c\xb0<\x843X\"\x91\x82\x05\x10\x00\x00" +
	"\xff\xff\xfe\x02\xe1\x03"

func init() {
	schemas.Register(schema_ffd06af2f026177b,
		0x86aae6bcee1a970d,
		0x8be7edcd35d4c706,
		0xac121e5aa82ca6bd,
		0xbab68c252196561b,
		0xc0e8eed87688cb46,
		0xc102bb9ca7ace092,
		0xc68563695ada2a40,
		0xd227ef68de0bc647,
		0xdcf28e81fa4de615,
		0xdcf58b9bef546812)
}
