// Code generated by capnpc-go. DO NOT EDIT.

package persistence

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	context "context"
	fmt "fmt"
	common "github.com/zalf-rpm/mas-infrastructure/capnproto_schemas/gen/go/common"
	strconv "strconv"
)

type VatId capnp.Struct

// VatId_TypeID is the unique identifier for the type VatId.
const VatId_TypeID = 0xe10a5d74d58bd18d

func NewVatId(s *capnp.Segment) (VatId, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 32, PointerCount: 0})
	return VatId(st), err
}

func NewRootVatId(s *capnp.Segment) (VatId, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 32, PointerCount: 0})
	return VatId(st), err
}

func ReadRootVatId(msg *capnp.Message) (VatId, error) {
	root, err := msg.Root()
	return VatId(root.Struct()), err
}

func (s VatId) String() string {
	str, _ := text.Marshal(0xe10a5d74d58bd18d, capnp.Struct(s))
	return str
}

func (s VatId) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (VatId) DecodeFromPtr(p capnp.Ptr) VatId {
	return VatId(capnp.Struct{}.DecodeFromPtr(p))
}

func (s VatId) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s VatId) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s VatId) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s VatId) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s VatId) PublicKey0() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s VatId) SetPublicKey0(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s VatId) PublicKey1() uint64 {
	return capnp.Struct(s).Uint64(8)
}

func (s VatId) SetPublicKey1(v uint64) {
	capnp.Struct(s).SetUint64(8, v)
}

func (s VatId) PublicKey2() uint64 {
	return capnp.Struct(s).Uint64(16)
}

func (s VatId) SetPublicKey2(v uint64) {
	capnp.Struct(s).SetUint64(16, v)
}

func (s VatId) PublicKey3() uint64 {
	return capnp.Struct(s).Uint64(24)
}

func (s VatId) SetPublicKey3(v uint64) {
	capnp.Struct(s).SetUint64(24, v)
}

// VatId_List is a list of VatId.
type VatId_List = capnp.StructList[VatId]

// NewVatId creates a new list of VatId.
func NewVatId_List(s *capnp.Segment, sz int32) (VatId_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 32, PointerCount: 0}, sz)
	return capnp.StructList[VatId](l), err
}

// VatId_Future is a wrapper for a VatId promised by a client call.
type VatId_Future struct{ *capnp.Future }

func (f VatId_Future) Struct() (VatId, error) {
	p, err := f.Future.Ptr()
	return VatId(p.Struct()), err
}

type Address capnp.Struct
type Address_ip6 Address
type Address_Which uint16

const (
	Address_Which_ip6  Address_Which = 0
	Address_Which_host Address_Which = 1
)

func (w Address_Which) String() string {
	const s = "ip6host"
	switch w {
	case Address_Which_ip6:
		return s[0:3]
	case Address_Which_host:
		return s[3:7]

	}
	return "Address_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Address_TypeID is the unique identifier for the type Address.
const Address_TypeID = 0xfb47810671a05b0d

func NewAddress(s *capnp.Segment) (Address, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1})
	return Address(st), err
}

func NewRootAddress(s *capnp.Segment) (Address, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1})
	return Address(st), err
}

func ReadRootAddress(msg *capnp.Message) (Address, error) {
	root, err := msg.Root()
	return Address(root.Struct()), err
}

func (s Address) String() string {
	str, _ := text.Marshal(0xfb47810671a05b0d, capnp.Struct(s))
	return str
}

func (s Address) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Address) DecodeFromPtr(p capnp.Ptr) Address {
	return Address(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Address) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Address) Which() Address_Which {
	return Address_Which(capnp.Struct(s).Uint16(18))
}
func (s Address) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Address) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Address) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Address) Ip6() Address_ip6 { return Address_ip6(s) }

func (s Address) SetIp6() {
	capnp.Struct(s).SetUint16(18, 0)
}

func (s Address_ip6) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Address_ip6) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Address_ip6) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Address_ip6) Lower64() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s Address_ip6) SetLower64(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s Address_ip6) Upper64() uint64 {
	return capnp.Struct(s).Uint64(8)
}

func (s Address_ip6) SetUpper64(v uint64) {
	capnp.Struct(s).SetUint64(8, v)
}

func (s Address) Host() (string, error) {
	if capnp.Struct(s).Uint16(18) != 1 {
		panic("Which() != host")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Address) HasHost() bool {
	if capnp.Struct(s).Uint16(18) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Address) HostBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Address) SetHost(v string) error {
	capnp.Struct(s).SetUint16(18, 1)
	return capnp.Struct(s).SetText(0, v)
}

func (s Address) Port() uint16 {
	return capnp.Struct(s).Uint16(16)
}

func (s Address) SetPort(v uint16) {
	capnp.Struct(s).SetUint16(16, v)
}

// Address_List is a list of Address.
type Address_List = capnp.StructList[Address]

// NewAddress creates a new list of Address.
func NewAddress_List(s *capnp.Segment, sz int32) (Address_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1}, sz)
	return capnp.StructList[Address](l), err
}

// Address_Future is a wrapper for a Address promised by a client call.
type Address_Future struct{ *capnp.Future }

func (f Address_Future) Struct() (Address, error) {
	p, err := f.Future.Ptr()
	return Address(p.Struct()), err
}
func (p Address_Future) Ip6() Address_ip6_Future { return Address_ip6_Future{p.Future} }

// Address_ip6_Future is a wrapper for a Address_ip6 promised by a client call.
type Address_ip6_Future struct{ *capnp.Future }

func (f Address_ip6_Future) Struct() (Address_ip6, error) {
	p, err := f.Future.Ptr()
	return Address_ip6(p.Struct()), err
}

type VatPath capnp.Struct

// VatPath_TypeID is the unique identifier for the type VatPath.
const VatPath_TypeID = 0xd9eccdf2dbc48087

func NewVatPath(s *capnp.Segment) (VatPath, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return VatPath(st), err
}

func NewRootVatPath(s *capnp.Segment) (VatPath, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return VatPath(st), err
}

func ReadRootVatPath(msg *capnp.Message) (VatPath, error) {
	root, err := msg.Root()
	return VatPath(root.Struct()), err
}

func (s VatPath) String() string {
	str, _ := text.Marshal(0xd9eccdf2dbc48087, capnp.Struct(s))
	return str
}

func (s VatPath) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (VatPath) DecodeFromPtr(p capnp.Ptr) VatPath {
	return VatPath(capnp.Struct{}.DecodeFromPtr(p))
}

func (s VatPath) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s VatPath) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s VatPath) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s VatPath) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s VatPath) Id() (VatId, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return VatId(p.Struct()), err
}

func (s VatPath) HasId() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s VatPath) SetId(v VatId) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewId sets the id field to a newly
// allocated VatId struct, preferring placement in s's segment.
func (s VatPath) NewId() (VatId, error) {
	ss, err := NewVatId(capnp.Struct(s).Segment())
	if err != nil {
		return VatId{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s VatPath) Address() (Address, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Address(p.Struct()), err
}

func (s VatPath) HasAddress() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s VatPath) SetAddress(v Address) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewAddress sets the address field to a newly
// allocated Address struct, preferring placement in s's segment.
func (s VatPath) NewAddress() (Address, error) {
	ss, err := NewAddress(capnp.Struct(s).Segment())
	if err != nil {
		return Address{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

// VatPath_List is a list of VatPath.
type VatPath_List = capnp.StructList[VatPath]

// NewVatPath creates a new list of VatPath.
func NewVatPath_List(s *capnp.Segment, sz int32) (VatPath_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[VatPath](l), err
}

// VatPath_Future is a wrapper for a VatPath promised by a client call.
type VatPath_Future struct{ *capnp.Future }

func (f VatPath_Future) Struct() (VatPath, error) {
	p, err := f.Future.Ptr()
	return VatPath(p.Struct()), err
}
func (p VatPath_Future) Id() VatId_Future {
	return VatId_Future{Future: p.Future.Field(0, nil)}
}
func (p VatPath_Future) Address() Address_Future {
	return Address_Future{Future: p.Future.Field(1, nil)}
}

type SturdyRef capnp.Struct
type SturdyRef_Which uint16

const (
	SturdyRef_Which_transient SturdyRef_Which = 0
	SturdyRef_Which_stored    SturdyRef_Which = 1
)

func (w SturdyRef_Which) String() string {
	const s = "transientstored"
	switch w {
	case SturdyRef_Which_transient:
		return s[0:9]
	case SturdyRef_Which_stored:
		return s[9:15]

	}
	return "SturdyRef_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// SturdyRef_TypeID is the unique identifier for the type SturdyRef.
const SturdyRef_TypeID = 0x886d68271d83de4d

func NewSturdyRef(s *capnp.Segment) (SturdyRef, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return SturdyRef(st), err
}

func NewRootSturdyRef(s *capnp.Segment) (SturdyRef, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return SturdyRef(st), err
}

func ReadRootSturdyRef(msg *capnp.Message) (SturdyRef, error) {
	root, err := msg.Root()
	return SturdyRef(root.Struct()), err
}

func (s SturdyRef) String() string {
	str, _ := text.Marshal(0x886d68271d83de4d, capnp.Struct(s))
	return str
}

func (s SturdyRef) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (SturdyRef) DecodeFromPtr(p capnp.Ptr) SturdyRef {
	return SturdyRef(capnp.Struct{}.DecodeFromPtr(p))
}

func (s SturdyRef) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s SturdyRef) Which() SturdyRef_Which {
	return SturdyRef_Which(capnp.Struct(s).Uint16(0))
}
func (s SturdyRef) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s SturdyRef) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s SturdyRef) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s SturdyRef) Transient() (SturdyRef_Transient, error) {
	if capnp.Struct(s).Uint16(0) != 0 {
		panic("Which() != transient")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return SturdyRef_Transient(p.Struct()), err
}

func (s SturdyRef) HasTransient() bool {
	if capnp.Struct(s).Uint16(0) != 0 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s SturdyRef) SetTransient(v SturdyRef_Transient) error {
	capnp.Struct(s).SetUint16(0, 0)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewTransient sets the transient field to a newly
// allocated SturdyRef_Transient struct, preferring placement in s's segment.
func (s SturdyRef) NewTransient() (SturdyRef_Transient, error) {
	capnp.Struct(s).SetUint16(0, 0)
	ss, err := NewSturdyRef_Transient(capnp.Struct(s).Segment())
	if err != nil {
		return SturdyRef_Transient{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s SturdyRef) Stored() (SturdyRef_Stored, error) {
	if capnp.Struct(s).Uint16(0) != 1 {
		panic("Which() != stored")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return SturdyRef_Stored(p.Struct()), err
}

func (s SturdyRef) HasStored() bool {
	if capnp.Struct(s).Uint16(0) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s SturdyRef) SetStored(v SturdyRef_Stored) error {
	capnp.Struct(s).SetUint16(0, 1)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewStored sets the stored field to a newly
// allocated SturdyRef_Stored struct, preferring placement in s's segment.
func (s SturdyRef) NewStored() (SturdyRef_Stored, error) {
	capnp.Struct(s).SetUint16(0, 1)
	ss, err := NewSturdyRef_Stored(capnp.Struct(s).Segment())
	if err != nil {
		return SturdyRef_Stored{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// SturdyRef_List is a list of SturdyRef.
type SturdyRef_List = capnp.StructList[SturdyRef]

// NewSturdyRef creates a new list of SturdyRef.
func NewSturdyRef_List(s *capnp.Segment, sz int32) (SturdyRef_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[SturdyRef](l), err
}

// SturdyRef_Future is a wrapper for a SturdyRef promised by a client call.
type SturdyRef_Future struct{ *capnp.Future }

func (f SturdyRef_Future) Struct() (SturdyRef, error) {
	p, err := f.Future.Ptr()
	return SturdyRef(p.Struct()), err
}
func (p SturdyRef_Future) Transient() SturdyRef_Transient_Future {
	return SturdyRef_Transient_Future{Future: p.Future.Field(0, nil)}
}
func (p SturdyRef_Future) Stored() SturdyRef_Stored_Future {
	return SturdyRef_Stored_Future{Future: p.Future.Field(0, nil)}
}

type SturdyRef_Owner capnp.Struct

// SturdyRef_Owner_TypeID is the unique identifier for the type SturdyRef_Owner.
const SturdyRef_Owner_TypeID = 0xfdd799ed60c87723

func NewSturdyRef_Owner(s *capnp.Segment) (SturdyRef_Owner, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return SturdyRef_Owner(st), err
}

func NewRootSturdyRef_Owner(s *capnp.Segment) (SturdyRef_Owner, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return SturdyRef_Owner(st), err
}

func ReadRootSturdyRef_Owner(msg *capnp.Message) (SturdyRef_Owner, error) {
	root, err := msg.Root()
	return SturdyRef_Owner(root.Struct()), err
}

func (s SturdyRef_Owner) String() string {
	str, _ := text.Marshal(0xfdd799ed60c87723, capnp.Struct(s))
	return str
}

func (s SturdyRef_Owner) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (SturdyRef_Owner) DecodeFromPtr(p capnp.Ptr) SturdyRef_Owner {
	return SturdyRef_Owner(capnp.Struct{}.DecodeFromPtr(p))
}

func (s SturdyRef_Owner) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s SturdyRef_Owner) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s SturdyRef_Owner) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s SturdyRef_Owner) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s SturdyRef_Owner) Guid() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s SturdyRef_Owner) HasGuid() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s SturdyRef_Owner) GuidBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s SturdyRef_Owner) SetGuid(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// SturdyRef_Owner_List is a list of SturdyRef_Owner.
type SturdyRef_Owner_List = capnp.StructList[SturdyRef_Owner]

// NewSturdyRef_Owner creates a new list of SturdyRef_Owner.
func NewSturdyRef_Owner_List(s *capnp.Segment, sz int32) (SturdyRef_Owner_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[SturdyRef_Owner](l), err
}

// SturdyRef_Owner_Future is a wrapper for a SturdyRef_Owner promised by a client call.
type SturdyRef_Owner_Future struct{ *capnp.Future }

func (f SturdyRef_Owner_Future) Struct() (SturdyRef_Owner, error) {
	p, err := f.Future.Ptr()
	return SturdyRef_Owner(p.Struct()), err
}

type SturdyRef_Transient capnp.Struct

// SturdyRef_Transient_TypeID is the unique identifier for the type SturdyRef_Transient.
const SturdyRef_Transient_TypeID = 0xa42bd461f2a8a3c8

func NewSturdyRef_Transient(s *capnp.Segment) (SturdyRef_Transient, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return SturdyRef_Transient(st), err
}

func NewRootSturdyRef_Transient(s *capnp.Segment) (SturdyRef_Transient, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return SturdyRef_Transient(st), err
}

func ReadRootSturdyRef_Transient(msg *capnp.Message) (SturdyRef_Transient, error) {
	root, err := msg.Root()
	return SturdyRef_Transient(root.Struct()), err
}

func (s SturdyRef_Transient) String() string {
	str, _ := text.Marshal(0xa42bd461f2a8a3c8, capnp.Struct(s))
	return str
}

func (s SturdyRef_Transient) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (SturdyRef_Transient) DecodeFromPtr(p capnp.Ptr) SturdyRef_Transient {
	return SturdyRef_Transient(capnp.Struct{}.DecodeFromPtr(p))
}

func (s SturdyRef_Transient) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s SturdyRef_Transient) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s SturdyRef_Transient) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s SturdyRef_Transient) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s SturdyRef_Transient) Vat() (VatPath, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return VatPath(p.Struct()), err
}

func (s SturdyRef_Transient) HasVat() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s SturdyRef_Transient) SetVat(v VatPath) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewVat sets the vat field to a newly
// allocated VatPath struct, preferring placement in s's segment.
func (s SturdyRef_Transient) NewVat() (VatPath, error) {
	ss, err := NewVatPath(capnp.Struct(s).Segment())
	if err != nil {
		return VatPath{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s SturdyRef_Transient) LocalRef() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(1)
}

func (s SturdyRef_Transient) HasLocalRef() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s SturdyRef_Transient) SetLocalRef(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(1, v)
}

// SturdyRef_Transient_List is a list of SturdyRef_Transient.
type SturdyRef_Transient_List = capnp.StructList[SturdyRef_Transient]

// NewSturdyRef_Transient creates a new list of SturdyRef_Transient.
func NewSturdyRef_Transient_List(s *capnp.Segment, sz int32) (SturdyRef_Transient_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[SturdyRef_Transient](l), err
}

// SturdyRef_Transient_Future is a wrapper for a SturdyRef_Transient promised by a client call.
type SturdyRef_Transient_Future struct{ *capnp.Future }

func (f SturdyRef_Transient_Future) Struct() (SturdyRef_Transient, error) {
	p, err := f.Future.Ptr()
	return SturdyRef_Transient(p.Struct()), err
}
func (p SturdyRef_Transient_Future) Vat() VatPath_Future {
	return VatPath_Future{Future: p.Future.Field(0, nil)}
}
func (p SturdyRef_Transient_Future) LocalRef() *capnp.Future {
	return p.Future.Field(1, nil)
}

type SturdyRef_Stored capnp.Struct

// SturdyRef_Stored_TypeID is the unique identifier for the type SturdyRef_Stored.
const SturdyRef_Stored_TypeID = 0xcbe679a401315eb8

func NewSturdyRef_Stored(s *capnp.Segment) (SturdyRef_Stored, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 32, PointerCount: 0})
	return SturdyRef_Stored(st), err
}

func NewRootSturdyRef_Stored(s *capnp.Segment) (SturdyRef_Stored, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 32, PointerCount: 0})
	return SturdyRef_Stored(st), err
}

func ReadRootSturdyRef_Stored(msg *capnp.Message) (SturdyRef_Stored, error) {
	root, err := msg.Root()
	return SturdyRef_Stored(root.Struct()), err
}

func (s SturdyRef_Stored) String() string {
	str, _ := text.Marshal(0xcbe679a401315eb8, capnp.Struct(s))
	return str
}

func (s SturdyRef_Stored) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (SturdyRef_Stored) DecodeFromPtr(p capnp.Ptr) SturdyRef_Stored {
	return SturdyRef_Stored(capnp.Struct{}.DecodeFromPtr(p))
}

func (s SturdyRef_Stored) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s SturdyRef_Stored) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s SturdyRef_Stored) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s SturdyRef_Stored) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s SturdyRef_Stored) Key0() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s SturdyRef_Stored) SetKey0(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s SturdyRef_Stored) Key1() uint64 {
	return capnp.Struct(s).Uint64(8)
}

func (s SturdyRef_Stored) SetKey1(v uint64) {
	capnp.Struct(s).SetUint64(8, v)
}

func (s SturdyRef_Stored) Key2() uint64 {
	return capnp.Struct(s).Uint64(16)
}

func (s SturdyRef_Stored) SetKey2(v uint64) {
	capnp.Struct(s).SetUint64(16, v)
}

func (s SturdyRef_Stored) Key3() uint64 {
	return capnp.Struct(s).Uint64(24)
}

func (s SturdyRef_Stored) SetKey3(v uint64) {
	capnp.Struct(s).SetUint64(24, v)
}

// SturdyRef_Stored_List is a list of SturdyRef_Stored.
type SturdyRef_Stored_List = capnp.StructList[SturdyRef_Stored]

// NewSturdyRef_Stored creates a new list of SturdyRef_Stored.
func NewSturdyRef_Stored_List(s *capnp.Segment, sz int32) (SturdyRef_Stored_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 32, PointerCount: 0}, sz)
	return capnp.StructList[SturdyRef_Stored](l), err
}

// SturdyRef_Stored_Future is a wrapper for a SturdyRef_Stored promised by a client call.
type SturdyRef_Stored_Future struct{ *capnp.Future }

func (f SturdyRef_Stored_Future) Struct() (SturdyRef_Stored, error) {
	p, err := f.Future.Ptr()
	return SturdyRef_Stored(p.Struct()), err
}

type Persistent capnp.Client

// Persistent_TypeID is the unique identifier for the type Persistent.
const Persistent_TypeID = 0xc1a7daa0dc36cb65

func (c Persistent) Save(ctx context.Context, params func(Persistent_SaveParams) error) (Persistent_SaveResults_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xc1a7daa0dc36cb65,
			MethodID:      0,
			InterfaceName: "persistence.capnp:Persistent",
			MethodName:    "save",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Persistent_SaveParams(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Persistent_SaveResults_Future{Future: ans.Future()}, release
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Persistent) String() string {
	return fmt.Sprintf("%T(%v)", c, capnp.Client(c))
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Persistent) AddRef() Persistent {
	return Persistent(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Persistent) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Persistent) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Persistent) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Persistent) DecodeFromPtr(p capnp.Ptr) Persistent {
	return Persistent(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Persistent) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Persistent) IsSame(other Persistent) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Persistent) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Persistent) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
} // A Persistent_Server is a Persistent with a local implementation.
type Persistent_Server interface {
	Save(context.Context, Persistent_save) error
}

// Persistent_NewServer creates a new Server from an implementation of Persistent_Server.
func Persistent_NewServer(s Persistent_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Persistent_Methods(nil, s), s, c)
}

// Persistent_ServerToClient creates a new Client from an implementation of Persistent_Server.
// The caller is responsible for calling Release on the returned Client.
func Persistent_ServerToClient(s Persistent_Server) Persistent {
	return Persistent(capnp.NewClient(Persistent_NewServer(s)))
}

// Persistent_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Persistent_Methods(methods []server.Method, s Persistent_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xc1a7daa0dc36cb65,
			MethodID:      0,
			InterfaceName: "persistence.capnp:Persistent",
			MethodName:    "save",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Save(ctx, Persistent_save{call})
		},
	})

	return methods
}

// Persistent_save holds the state for a server call to Persistent.save.
// See server.Call for documentation.
type Persistent_save struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Persistent_save) Args() Persistent_SaveParams {
	return Persistent_SaveParams(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Persistent_save) AllocResults() (Persistent_SaveResults, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Persistent_SaveResults(r), err
}

// Persistent_List is a list of Persistent.
type Persistent_List = capnp.CapList[Persistent]

// NewPersistent creates a new list of Persistent.
func NewPersistent_List(s *capnp.Segment, sz int32) (Persistent_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Persistent](l), err
}

type Persistent_SaveParams capnp.Struct

// Persistent_SaveParams_TypeID is the unique identifier for the type Persistent_SaveParams.
const Persistent_SaveParams_TypeID = 0xd5e0aac4225e0343

func NewPersistent_SaveParams(s *capnp.Segment) (Persistent_SaveParams, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Persistent_SaveParams(st), err
}

func NewRootPersistent_SaveParams(s *capnp.Segment) (Persistent_SaveParams, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Persistent_SaveParams(st), err
}

func ReadRootPersistent_SaveParams(msg *capnp.Message) (Persistent_SaveParams, error) {
	root, err := msg.Root()
	return Persistent_SaveParams(root.Struct()), err
}

func (s Persistent_SaveParams) String() string {
	str, _ := text.Marshal(0xd5e0aac4225e0343, capnp.Struct(s))
	return str
}

func (s Persistent_SaveParams) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Persistent_SaveParams) DecodeFromPtr(p capnp.Ptr) Persistent_SaveParams {
	return Persistent_SaveParams(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Persistent_SaveParams) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Persistent_SaveParams) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Persistent_SaveParams) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Persistent_SaveParams) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Persistent_SaveParams) SealFor() (SturdyRef_Owner, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return SturdyRef_Owner(p.Struct()), err
}

func (s Persistent_SaveParams) HasSealFor() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Persistent_SaveParams) SetSealFor(v SturdyRef_Owner) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewSealFor sets the sealFor field to a newly
// allocated SturdyRef_Owner struct, preferring placement in s's segment.
func (s Persistent_SaveParams) NewSealFor() (SturdyRef_Owner, error) {
	ss, err := NewSturdyRef_Owner(capnp.Struct(s).Segment())
	if err != nil {
		return SturdyRef_Owner{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Persistent_SaveParams_List is a list of Persistent_SaveParams.
type Persistent_SaveParams_List = capnp.StructList[Persistent_SaveParams]

// NewPersistent_SaveParams creates a new list of Persistent_SaveParams.
func NewPersistent_SaveParams_List(s *capnp.Segment, sz int32) (Persistent_SaveParams_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Persistent_SaveParams](l), err
}

// Persistent_SaveParams_Future is a wrapper for a Persistent_SaveParams promised by a client call.
type Persistent_SaveParams_Future struct{ *capnp.Future }

func (f Persistent_SaveParams_Future) Struct() (Persistent_SaveParams, error) {
	p, err := f.Future.Ptr()
	return Persistent_SaveParams(p.Struct()), err
}
func (p Persistent_SaveParams_Future) SealFor() SturdyRef_Owner_Future {
	return SturdyRef_Owner_Future{Future: p.Future.Field(0, nil)}
}

type Persistent_SaveResults capnp.Struct

// Persistent_SaveResults_TypeID is the unique identifier for the type Persistent_SaveResults.
const Persistent_SaveResults_TypeID = 0xdc5bd1ef982cec13

func NewPersistent_SaveResults(s *capnp.Segment) (Persistent_SaveResults, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Persistent_SaveResults(st), err
}

func NewRootPersistent_SaveResults(s *capnp.Segment) (Persistent_SaveResults, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Persistent_SaveResults(st), err
}

func ReadRootPersistent_SaveResults(msg *capnp.Message) (Persistent_SaveResults, error) {
	root, err := msg.Root()
	return Persistent_SaveResults(root.Struct()), err
}

func (s Persistent_SaveResults) String() string {
	str, _ := text.Marshal(0xdc5bd1ef982cec13, capnp.Struct(s))
	return str
}

func (s Persistent_SaveResults) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Persistent_SaveResults) DecodeFromPtr(p capnp.Ptr) Persistent_SaveResults {
	return Persistent_SaveResults(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Persistent_SaveResults) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Persistent_SaveResults) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Persistent_SaveResults) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Persistent_SaveResults) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Persistent_SaveResults) SturdyRef() (SturdyRef, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return SturdyRef(p.Struct()), err
}

func (s Persistent_SaveResults) HasSturdyRef() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Persistent_SaveResults) SetSturdyRef(v SturdyRef) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewSturdyRef sets the sturdyRef field to a newly
// allocated SturdyRef struct, preferring placement in s's segment.
func (s Persistent_SaveResults) NewSturdyRef() (SturdyRef, error) {
	ss, err := NewSturdyRef(capnp.Struct(s).Segment())
	if err != nil {
		return SturdyRef{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Persistent_SaveResults) UnsaveSR() (SturdyRef, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return SturdyRef(p.Struct()), err
}

func (s Persistent_SaveResults) HasUnsaveSR() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Persistent_SaveResults) SetUnsaveSR(v SturdyRef) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewUnsaveSR sets the unsaveSR field to a newly
// allocated SturdyRef struct, preferring placement in s's segment.
func (s Persistent_SaveResults) NewUnsaveSR() (SturdyRef, error) {
	ss, err := NewSturdyRef(capnp.Struct(s).Segment())
	if err != nil {
		return SturdyRef{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Persistent_SaveResults_List is a list of Persistent_SaveResults.
type Persistent_SaveResults_List = capnp.StructList[Persistent_SaveResults]

// NewPersistent_SaveResults creates a new list of Persistent_SaveResults.
func NewPersistent_SaveResults_List(s *capnp.Segment, sz int32) (Persistent_SaveResults_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Persistent_SaveResults](l), err
}

// Persistent_SaveResults_Future is a wrapper for a Persistent_SaveResults promised by a client call.
type Persistent_SaveResults_Future struct{ *capnp.Future }

func (f Persistent_SaveResults_Future) Struct() (Persistent_SaveResults, error) {
	p, err := f.Future.Ptr()
	return Persistent_SaveResults(p.Struct()), err
}
func (p Persistent_SaveResults_Future) SturdyRef() SturdyRef_Future {
	return SturdyRef_Future{Future: p.Future.Field(0, nil)}
}
func (p Persistent_SaveResults_Future) UnsaveSR() SturdyRef_Future {
	return SturdyRef_Future{Future: p.Future.Field(1, nil)}
}

type Persistent_ReleaseSturdyRef capnp.Client

// Persistent_ReleaseSturdyRef_TypeID is the unique identifier for the type Persistent_ReleaseSturdyRef.
const Persistent_ReleaseSturdyRef_TypeID = 0x8f700f81169f2e52

func (c Persistent_ReleaseSturdyRef) ReleaseSR(ctx context.Context, params func(Persistent_ReleaseSturdyRef_releaseSR_Params) error) (Persistent_ReleaseSturdyRef_releaseSR_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x8f700f81169f2e52,
			MethodID:      0,
			InterfaceName: "persistence.capnp:Persistent.ReleaseSturdyRef",
			MethodName:    "release",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Persistent_ReleaseSturdyRef_releaseSR_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Persistent_ReleaseSturdyRef_releaseSR_Results_Future{Future: ans.Future()}, release
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Persistent_ReleaseSturdyRef) String() string {
	return fmt.Sprintf("%T(%v)", c, capnp.Client(c))
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Persistent_ReleaseSturdyRef) AddRef() Persistent_ReleaseSturdyRef {
	return Persistent_ReleaseSturdyRef(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Persistent_ReleaseSturdyRef) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Persistent_ReleaseSturdyRef) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Persistent_ReleaseSturdyRef) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Persistent_ReleaseSturdyRef) DecodeFromPtr(p capnp.Ptr) Persistent_ReleaseSturdyRef {
	return Persistent_ReleaseSturdyRef(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Persistent_ReleaseSturdyRef) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Persistent_ReleaseSturdyRef) IsSame(other Persistent_ReleaseSturdyRef) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Persistent_ReleaseSturdyRef) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Persistent_ReleaseSturdyRef) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
} // A Persistent_ReleaseSturdyRef_Server is a Persistent_ReleaseSturdyRef with a local implementation.
type Persistent_ReleaseSturdyRef_Server interface {
	ReleaseSR(context.Context, Persistent_ReleaseSturdyRef_releaseSR) error
}

// Persistent_ReleaseSturdyRef_NewServer creates a new Server from an implementation of Persistent_ReleaseSturdyRef_Server.
func Persistent_ReleaseSturdyRef_NewServer(s Persistent_ReleaseSturdyRef_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Persistent_ReleaseSturdyRef_Methods(nil, s), s, c)
}

// Persistent_ReleaseSturdyRef_ServerToClient creates a new Client from an implementation of Persistent_ReleaseSturdyRef_Server.
// The caller is responsible for calling Release on the returned Client.
func Persistent_ReleaseSturdyRef_ServerToClient(s Persistent_ReleaseSturdyRef_Server) Persistent_ReleaseSturdyRef {
	return Persistent_ReleaseSturdyRef(capnp.NewClient(Persistent_ReleaseSturdyRef_NewServer(s)))
}

// Persistent_ReleaseSturdyRef_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Persistent_ReleaseSturdyRef_Methods(methods []server.Method, s Persistent_ReleaseSturdyRef_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x8f700f81169f2e52,
			MethodID:      0,
			InterfaceName: "persistence.capnp:Persistent.ReleaseSturdyRef",
			MethodName:    "release",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.ReleaseSR(ctx, Persistent_ReleaseSturdyRef_releaseSR{call})
		},
	})

	return methods
}

// Persistent_ReleaseSturdyRef_releaseSR holds the state for a server call to Persistent_ReleaseSturdyRef.releaseSR.
// See server.Call for documentation.
type Persistent_ReleaseSturdyRef_releaseSR struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Persistent_ReleaseSturdyRef_releaseSR) Args() Persistent_ReleaseSturdyRef_releaseSR_Params {
	return Persistent_ReleaseSturdyRef_releaseSR_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Persistent_ReleaseSturdyRef_releaseSR) AllocResults() (Persistent_ReleaseSturdyRef_releaseSR_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Persistent_ReleaseSturdyRef_releaseSR_Results(r), err
}

// Persistent_ReleaseSturdyRef_List is a list of Persistent_ReleaseSturdyRef.
type Persistent_ReleaseSturdyRef_List = capnp.CapList[Persistent_ReleaseSturdyRef]

// NewPersistent_ReleaseSturdyRef creates a new list of Persistent_ReleaseSturdyRef.
func NewPersistent_ReleaseSturdyRef_List(s *capnp.Segment, sz int32) (Persistent_ReleaseSturdyRef_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Persistent_ReleaseSturdyRef](l), err
}

type Persistent_ReleaseSturdyRef_releaseSR_Params capnp.Struct

// Persistent_ReleaseSturdyRef_releaseSR_Params_TypeID is the unique identifier for the type Persistent_ReleaseSturdyRef_releaseSR_Params.
const Persistent_ReleaseSturdyRef_releaseSR_Params_TypeID = 0xa4db8c20d9807c15

func NewPersistent_ReleaseSturdyRef_releaseSR_Params(s *capnp.Segment) (Persistent_ReleaseSturdyRef_releaseSR_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Persistent_ReleaseSturdyRef_releaseSR_Params(st), err
}

func NewRootPersistent_ReleaseSturdyRef_releaseSR_Params(s *capnp.Segment) (Persistent_ReleaseSturdyRef_releaseSR_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Persistent_ReleaseSturdyRef_releaseSR_Params(st), err
}

func ReadRootPersistent_ReleaseSturdyRef_releaseSR_Params(msg *capnp.Message) (Persistent_ReleaseSturdyRef_releaseSR_Params, error) {
	root, err := msg.Root()
	return Persistent_ReleaseSturdyRef_releaseSR_Params(root.Struct()), err
}

func (s Persistent_ReleaseSturdyRef_releaseSR_Params) String() string {
	str, _ := text.Marshal(0xa4db8c20d9807c15, capnp.Struct(s))
	return str
}

func (s Persistent_ReleaseSturdyRef_releaseSR_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Persistent_ReleaseSturdyRef_releaseSR_Params) DecodeFromPtr(p capnp.Ptr) Persistent_ReleaseSturdyRef_releaseSR_Params {
	return Persistent_ReleaseSturdyRef_releaseSR_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Persistent_ReleaseSturdyRef_releaseSR_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Persistent_ReleaseSturdyRef_releaseSR_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Persistent_ReleaseSturdyRef_releaseSR_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Persistent_ReleaseSturdyRef_releaseSR_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Persistent_ReleaseSturdyRef_releaseSR_Params_List is a list of Persistent_ReleaseSturdyRef_releaseSR_Params.
type Persistent_ReleaseSturdyRef_releaseSR_Params_List = capnp.StructList[Persistent_ReleaseSturdyRef_releaseSR_Params]

// NewPersistent_ReleaseSturdyRef_releaseSR_Params creates a new list of Persistent_ReleaseSturdyRef_releaseSR_Params.
func NewPersistent_ReleaseSturdyRef_releaseSR_Params_List(s *capnp.Segment, sz int32) (Persistent_ReleaseSturdyRef_releaseSR_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Persistent_ReleaseSturdyRef_releaseSR_Params](l), err
}

// Persistent_ReleaseSturdyRef_releaseSR_Params_Future is a wrapper for a Persistent_ReleaseSturdyRef_releaseSR_Params promised by a client call.
type Persistent_ReleaseSturdyRef_releaseSR_Params_Future struct{ *capnp.Future }

func (f Persistent_ReleaseSturdyRef_releaseSR_Params_Future) Struct() (Persistent_ReleaseSturdyRef_releaseSR_Params, error) {
	p, err := f.Future.Ptr()
	return Persistent_ReleaseSturdyRef_releaseSR_Params(p.Struct()), err
}

type Persistent_ReleaseSturdyRef_releaseSR_Results capnp.Struct

// Persistent_ReleaseSturdyRef_releaseSR_Results_TypeID is the unique identifier for the type Persistent_ReleaseSturdyRef_releaseSR_Results.
const Persistent_ReleaseSturdyRef_releaseSR_Results_TypeID = 0x932d6ee32410e853

func NewPersistent_ReleaseSturdyRef_releaseSR_Results(s *capnp.Segment) (Persistent_ReleaseSturdyRef_releaseSR_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Persistent_ReleaseSturdyRef_releaseSR_Results(st), err
}

func NewRootPersistent_ReleaseSturdyRef_releaseSR_Results(s *capnp.Segment) (Persistent_ReleaseSturdyRef_releaseSR_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Persistent_ReleaseSturdyRef_releaseSR_Results(st), err
}

func ReadRootPersistent_ReleaseSturdyRef_releaseSR_Results(msg *capnp.Message) (Persistent_ReleaseSturdyRef_releaseSR_Results, error) {
	root, err := msg.Root()
	return Persistent_ReleaseSturdyRef_releaseSR_Results(root.Struct()), err
}

func (s Persistent_ReleaseSturdyRef_releaseSR_Results) String() string {
	str, _ := text.Marshal(0x932d6ee32410e853, capnp.Struct(s))
	return str
}

func (s Persistent_ReleaseSturdyRef_releaseSR_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Persistent_ReleaseSturdyRef_releaseSR_Results) DecodeFromPtr(p capnp.Ptr) Persistent_ReleaseSturdyRef_releaseSR_Results {
	return Persistent_ReleaseSturdyRef_releaseSR_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Persistent_ReleaseSturdyRef_releaseSR_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Persistent_ReleaseSturdyRef_releaseSR_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Persistent_ReleaseSturdyRef_releaseSR_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Persistent_ReleaseSturdyRef_releaseSR_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Persistent_ReleaseSturdyRef_releaseSR_Results) Success() bool {
	return capnp.Struct(s).Bit(0)
}

func (s Persistent_ReleaseSturdyRef_releaseSR_Results) SetSuccess(v bool) {
	capnp.Struct(s).SetBit(0, v)
}

// Persistent_ReleaseSturdyRef_releaseSR_Results_List is a list of Persistent_ReleaseSturdyRef_releaseSR_Results.
type Persistent_ReleaseSturdyRef_releaseSR_Results_List = capnp.StructList[Persistent_ReleaseSturdyRef_releaseSR_Results]

// NewPersistent_ReleaseSturdyRef_releaseSR_Results creates a new list of Persistent_ReleaseSturdyRef_releaseSR_Results.
func NewPersistent_ReleaseSturdyRef_releaseSR_Results_List(s *capnp.Segment, sz int32) (Persistent_ReleaseSturdyRef_releaseSR_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[Persistent_ReleaseSturdyRef_releaseSR_Results](l), err
}

// Persistent_ReleaseSturdyRef_releaseSR_Results_Future is a wrapper for a Persistent_ReleaseSturdyRef_releaseSR_Results promised by a client call.
type Persistent_ReleaseSturdyRef_releaseSR_Results_Future struct{ *capnp.Future }

func (f Persistent_ReleaseSturdyRef_releaseSR_Results_Future) Struct() (Persistent_ReleaseSturdyRef_releaseSR_Results, error) {
	p, err := f.Future.Ptr()
	return Persistent_ReleaseSturdyRef_releaseSR_Results(p.Struct()), err
}

type Restorer capnp.Client

// Restorer_TypeID is the unique identifier for the type Restorer.
const Restorer_TypeID = 0x9fb6218427d92e3c

func (c Restorer) Restore(ctx context.Context, params func(Restorer_RestoreParams) error) (Restorer_restore_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x9fb6218427d92e3c,
			MethodID:      0,
			InterfaceName: "persistence.capnp:Restorer",
			MethodName:    "restore",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 2}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Restorer_RestoreParams(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Restorer_restore_Results_Future{Future: ans.Future()}, release
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Restorer) String() string {
	return fmt.Sprintf("%T(%v)", c, capnp.Client(c))
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Restorer) AddRef() Restorer {
	return Restorer(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Restorer) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Restorer) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Restorer) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Restorer) DecodeFromPtr(p capnp.Ptr) Restorer {
	return Restorer(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Restorer) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Restorer) IsSame(other Restorer) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Restorer) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Restorer) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
} // A Restorer_Server is a Restorer with a local implementation.
type Restorer_Server interface {
	Restore(context.Context, Restorer_restore) error
}

// Restorer_NewServer creates a new Server from an implementation of Restorer_Server.
func Restorer_NewServer(s Restorer_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Restorer_Methods(nil, s), s, c)
}

// Restorer_ServerToClient creates a new Client from an implementation of Restorer_Server.
// The caller is responsible for calling Release on the returned Client.
func Restorer_ServerToClient(s Restorer_Server) Restorer {
	return Restorer(capnp.NewClient(Restorer_NewServer(s)))
}

// Restorer_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Restorer_Methods(methods []server.Method, s Restorer_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x9fb6218427d92e3c,
			MethodID:      0,
			InterfaceName: "persistence.capnp:Restorer",
			MethodName:    "restore",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Restore(ctx, Restorer_restore{call})
		},
	})

	return methods
}

// Restorer_restore holds the state for a server call to Restorer.restore.
// See server.Call for documentation.
type Restorer_restore struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Restorer_restore) Args() Restorer_RestoreParams {
	return Restorer_RestoreParams(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Restorer_restore) AllocResults() (Restorer_restore_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Restorer_restore_Results(r), err
}

// Restorer_List is a list of Restorer.
type Restorer_List = capnp.CapList[Restorer]

// NewRestorer creates a new list of Restorer.
func NewRestorer_List(s *capnp.Segment, sz int32) (Restorer_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Restorer](l), err
}

type Restorer_RestoreParams capnp.Struct

// Restorer_RestoreParams_TypeID is the unique identifier for the type Restorer_RestoreParams.
const Restorer_RestoreParams_TypeID = 0xc541e5764a37d73a

func NewRestorer_RestoreParams(s *capnp.Segment) (Restorer_RestoreParams, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Restorer_RestoreParams(st), err
}

func NewRootRestorer_RestoreParams(s *capnp.Segment) (Restorer_RestoreParams, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Restorer_RestoreParams(st), err
}

func ReadRootRestorer_RestoreParams(msg *capnp.Message) (Restorer_RestoreParams, error) {
	root, err := msg.Root()
	return Restorer_RestoreParams(root.Struct()), err
}

func (s Restorer_RestoreParams) String() string {
	str, _ := text.Marshal(0xc541e5764a37d73a, capnp.Struct(s))
	return str
}

func (s Restorer_RestoreParams) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Restorer_RestoreParams) DecodeFromPtr(p capnp.Ptr) Restorer_RestoreParams {
	return Restorer_RestoreParams(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Restorer_RestoreParams) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Restorer_RestoreParams) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Restorer_RestoreParams) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Restorer_RestoreParams) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Restorer_RestoreParams) LocalRef() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(0)
}

func (s Restorer_RestoreParams) HasLocalRef() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Restorer_RestoreParams) SetLocalRef(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(0, v)
}
func (s Restorer_RestoreParams) SealedFor() (SturdyRef_Owner, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return SturdyRef_Owner(p.Struct()), err
}

func (s Restorer_RestoreParams) HasSealedFor() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Restorer_RestoreParams) SetSealedFor(v SturdyRef_Owner) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewSealedFor sets the sealedFor field to a newly
// allocated SturdyRef_Owner struct, preferring placement in s's segment.
func (s Restorer_RestoreParams) NewSealedFor() (SturdyRef_Owner, error) {
	ss, err := NewSturdyRef_Owner(capnp.Struct(s).Segment())
	if err != nil {
		return SturdyRef_Owner{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Restorer_RestoreParams_List is a list of Restorer_RestoreParams.
type Restorer_RestoreParams_List = capnp.StructList[Restorer_RestoreParams]

// NewRestorer_RestoreParams creates a new list of Restorer_RestoreParams.
func NewRestorer_RestoreParams_List(s *capnp.Segment, sz int32) (Restorer_RestoreParams_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Restorer_RestoreParams](l), err
}

// Restorer_RestoreParams_Future is a wrapper for a Restorer_RestoreParams promised by a client call.
type Restorer_RestoreParams_Future struct{ *capnp.Future }

func (f Restorer_RestoreParams_Future) Struct() (Restorer_RestoreParams, error) {
	p, err := f.Future.Ptr()
	return Restorer_RestoreParams(p.Struct()), err
}
func (p Restorer_RestoreParams_Future) LocalRef() *capnp.Future {
	return p.Future.Field(0, nil)
}
func (p Restorer_RestoreParams_Future) SealedFor() SturdyRef_Owner_Future {
	return SturdyRef_Owner_Future{Future: p.Future.Field(1, nil)}
}

type Restorer_restore_Results capnp.Struct

// Restorer_restore_Results_TypeID is the unique identifier for the type Restorer_restore_Results.
const Restorer_restore_Results_TypeID = 0xda966d1d252e4d25

func NewRestorer_restore_Results(s *capnp.Segment) (Restorer_restore_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Restorer_restore_Results(st), err
}

func NewRootRestorer_restore_Results(s *capnp.Segment) (Restorer_restore_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Restorer_restore_Results(st), err
}

func ReadRootRestorer_restore_Results(msg *capnp.Message) (Restorer_restore_Results, error) {
	root, err := msg.Root()
	return Restorer_restore_Results(root.Struct()), err
}

func (s Restorer_restore_Results) String() string {
	str, _ := text.Marshal(0xda966d1d252e4d25, capnp.Struct(s))
	return str
}

func (s Restorer_restore_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Restorer_restore_Results) DecodeFromPtr(p capnp.Ptr) Restorer_restore_Results {
	return Restorer_restore_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Restorer_restore_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Restorer_restore_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Restorer_restore_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Restorer_restore_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Restorer_restore_Results) Cap() capnp.Client {
	p, _ := capnp.Struct(s).Ptr(0)
	return p.Interface().Client()
}

func (s Restorer_restore_Results) HasCap() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Restorer_restore_Results) SetCap(c capnp.Client) error {
	if !c.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(c))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// Restorer_restore_Results_List is a list of Restorer_restore_Results.
type Restorer_restore_Results_List = capnp.StructList[Restorer_restore_Results]

// NewRestorer_restore_Results creates a new list of Restorer_restore_Results.
func NewRestorer_restore_Results_List(s *capnp.Segment, sz int32) (Restorer_restore_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Restorer_restore_Results](l), err
}

// Restorer_restore_Results_Future is a wrapper for a Restorer_restore_Results promised by a client call.
type Restorer_restore_Results_Future struct{ *capnp.Future }

func (f Restorer_restore_Results_Future) Struct() (Restorer_restore_Results, error) {
	p, err := f.Future.Ptr()
	return Restorer_restore_Results(p.Struct()), err
}
func (p Restorer_restore_Results_Future) Cap() capnp.Client {
	return p.Future.Field(0, nil).Client()
}

type HostPortResolver capnp.Client

// HostPortResolver_TypeID is the unique identifier for the type HostPortResolver.
const HostPortResolver_TypeID = 0xaa8d91fab6d01d9f

func (c HostPortResolver) ResolveIdent(ctx context.Context, params func(HostPortResolver_ResolveIdent_Params) error) (HostPortResolver_ResolveIdent_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xaa8d91fab6d01d9f,
			MethodID:      0,
			InterfaceName: "persistence.capnp:HostPortResolver",
			MethodName:    "resolve",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(HostPortResolver_ResolveIdent_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return HostPortResolver_ResolveIdent_Results_Future{Future: ans.Future()}, release
}
func (c HostPortResolver) Info(ctx context.Context, params func(common.Identifiable_info_Params) error) (common.IdInformation_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xb2afd1cb599c48d5,
			MethodID:      0,
			InterfaceName: "common.capnp:Identifiable",
			MethodName:    "info",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(common.Identifiable_info_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return common.IdInformation_Future{Future: ans.Future()}, release
}
func (c HostPortResolver) Restore(ctx context.Context, params func(Restorer_RestoreParams) error) (Restorer_restore_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x9fb6218427d92e3c,
			MethodID:      0,
			InterfaceName: "persistence.capnp:Restorer",
			MethodName:    "restore",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 2}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Restorer_RestoreParams(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Restorer_restore_Results_Future{Future: ans.Future()}, release
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c HostPortResolver) String() string {
	return fmt.Sprintf("%T(%v)", c, capnp.Client(c))
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c HostPortResolver) AddRef() HostPortResolver {
	return HostPortResolver(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c HostPortResolver) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c HostPortResolver) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c HostPortResolver) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (HostPortResolver) DecodeFromPtr(p capnp.Ptr) HostPortResolver {
	return HostPortResolver(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c HostPortResolver) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c HostPortResolver) IsSame(other HostPortResolver) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c HostPortResolver) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c HostPortResolver) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
} // A HostPortResolver_Server is a HostPortResolver with a local implementation.
type HostPortResolver_Server interface {
	ResolveIdent(context.Context, HostPortResolver_ResolveIdent) error

	Info(context.Context, common.Identifiable_info) error

	Restore(context.Context, Restorer_restore) error
}

// HostPortResolver_NewServer creates a new Server from an implementation of HostPortResolver_Server.
func HostPortResolver_NewServer(s HostPortResolver_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(HostPortResolver_Methods(nil, s), s, c)
}

// HostPortResolver_ServerToClient creates a new Client from an implementation of HostPortResolver_Server.
// The caller is responsible for calling Release on the returned Client.
func HostPortResolver_ServerToClient(s HostPortResolver_Server) HostPortResolver {
	return HostPortResolver(capnp.NewClient(HostPortResolver_NewServer(s)))
}

// HostPortResolver_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func HostPortResolver_Methods(methods []server.Method, s HostPortResolver_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 3)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xaa8d91fab6d01d9f,
			MethodID:      0,
			InterfaceName: "persistence.capnp:HostPortResolver",
			MethodName:    "resolve",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.ResolveIdent(ctx, HostPortResolver_ResolveIdent{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xb2afd1cb599c48d5,
			MethodID:      0,
			InterfaceName: "common.capnp:Identifiable",
			MethodName:    "info",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Info(ctx, common.Identifiable_info{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x9fb6218427d92e3c,
			MethodID:      0,
			InterfaceName: "persistence.capnp:Restorer",
			MethodName:    "restore",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Restore(ctx, Restorer_restore{call})
		},
	})

	return methods
}

// HostPortResolver_ResolveIdent holds the state for a server call to HostPortResolver.ResolveIdent.
// See server.Call for documentation.
type HostPortResolver_ResolveIdent struct {
	*server.Call
}

// Args returns the call's arguments.
func (c HostPortResolver_ResolveIdent) Args() HostPortResolver_ResolveIdent_Params {
	return HostPortResolver_ResolveIdent_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c HostPortResolver_ResolveIdent) AllocResults() (HostPortResolver_ResolveIdent_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return HostPortResolver_ResolveIdent_Results(r), err
}

// HostPortResolver_List is a list of HostPortResolver.
type HostPortResolver_List = capnp.CapList[HostPortResolver]

// NewHostPortResolver creates a new list of HostPortResolver.
func NewHostPortResolver_List(s *capnp.Segment, sz int32) (HostPortResolver_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[HostPortResolver](l), err
}

type HostPortResolver_Registrar capnp.Client

// HostPortResolver_Registrar_TypeID is the unique identifier for the type HostPortResolver_Registrar.
const HostPortResolver_Registrar_TypeID = 0xb0caf775704690b2

func (c HostPortResolver_Registrar) Register(ctx context.Context, params func(HostPortResolver_Registrar_register_Params) error) (HostPortResolver_Registrar_register_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xb0caf775704690b2,
			MethodID:      0,
			InterfaceName: "persistence.capnp:HostPortResolver.Registrar",
			MethodName:    "register",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 8, PointerCount: 3}
		s.PlaceArgs = func(s capnp.Struct) error { return params(HostPortResolver_Registrar_register_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return HostPortResolver_Registrar_register_Results_Future{Future: ans.Future()}, release
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c HostPortResolver_Registrar) String() string {
	return fmt.Sprintf("%T(%v)", c, capnp.Client(c))
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c HostPortResolver_Registrar) AddRef() HostPortResolver_Registrar {
	return HostPortResolver_Registrar(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c HostPortResolver_Registrar) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c HostPortResolver_Registrar) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c HostPortResolver_Registrar) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (HostPortResolver_Registrar) DecodeFromPtr(p capnp.Ptr) HostPortResolver_Registrar {
	return HostPortResolver_Registrar(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c HostPortResolver_Registrar) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c HostPortResolver_Registrar) IsSame(other HostPortResolver_Registrar) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c HostPortResolver_Registrar) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c HostPortResolver_Registrar) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
} // A HostPortResolver_Registrar_Server is a HostPortResolver_Registrar with a local implementation.
type HostPortResolver_Registrar_Server interface {
	Register(context.Context, HostPortResolver_Registrar_register) error
}

// HostPortResolver_Registrar_NewServer creates a new Server from an implementation of HostPortResolver_Registrar_Server.
func HostPortResolver_Registrar_NewServer(s HostPortResolver_Registrar_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(HostPortResolver_Registrar_Methods(nil, s), s, c)
}

// HostPortResolver_Registrar_ServerToClient creates a new Client from an implementation of HostPortResolver_Registrar_Server.
// The caller is responsible for calling Release on the returned Client.
func HostPortResolver_Registrar_ServerToClient(s HostPortResolver_Registrar_Server) HostPortResolver_Registrar {
	return HostPortResolver_Registrar(capnp.NewClient(HostPortResolver_Registrar_NewServer(s)))
}

// HostPortResolver_Registrar_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func HostPortResolver_Registrar_Methods(methods []server.Method, s HostPortResolver_Registrar_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xb0caf775704690b2,
			MethodID:      0,
			InterfaceName: "persistence.capnp:HostPortResolver.Registrar",
			MethodName:    "register",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Register(ctx, HostPortResolver_Registrar_register{call})
		},
	})

	return methods
}

// HostPortResolver_Registrar_register holds the state for a server call to HostPortResolver_Registrar.register.
// See server.Call for documentation.
type HostPortResolver_Registrar_register struct {
	*server.Call
}

// Args returns the call's arguments.
func (c HostPortResolver_Registrar_register) Args() HostPortResolver_Registrar_register_Params {
	return HostPortResolver_Registrar_register_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c HostPortResolver_Registrar_register) AllocResults() (HostPortResolver_Registrar_register_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return HostPortResolver_Registrar_register_Results(r), err
}

// HostPortResolver_Registrar_List is a list of HostPortResolver_Registrar.
type HostPortResolver_Registrar_List = capnp.CapList[HostPortResolver_Registrar]

// NewHostPortResolver_Registrar creates a new list of HostPortResolver_Registrar.
func NewHostPortResolver_Registrar_List(s *capnp.Segment, sz int32) (HostPortResolver_Registrar_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[HostPortResolver_Registrar](l), err
}

type HostPortResolver_Registrar_Heartbeat capnp.Client

// HostPortResolver_Registrar_Heartbeat_TypeID is the unique identifier for the type HostPortResolver_Registrar_Heartbeat.
const HostPortResolver_Registrar_Heartbeat_TypeID = 0x87de92d2d68df26f

func (c HostPortResolver_Registrar_Heartbeat) Beat(ctx context.Context, params func(HostPortResolver_Registrar_Heartbeat_beat_Params) error) (HostPortResolver_Registrar_Heartbeat_beat_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x87de92d2d68df26f,
			MethodID:      0,
			InterfaceName: "persistence.capnp:HostPortResolver.Registrar.Heartbeat",
			MethodName:    "beat",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(HostPortResolver_Registrar_Heartbeat_beat_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return HostPortResolver_Registrar_Heartbeat_beat_Results_Future{Future: ans.Future()}, release
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c HostPortResolver_Registrar_Heartbeat) String() string {
	return fmt.Sprintf("%T(%v)", c, capnp.Client(c))
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c HostPortResolver_Registrar_Heartbeat) AddRef() HostPortResolver_Registrar_Heartbeat {
	return HostPortResolver_Registrar_Heartbeat(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c HostPortResolver_Registrar_Heartbeat) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c HostPortResolver_Registrar_Heartbeat) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c HostPortResolver_Registrar_Heartbeat) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (HostPortResolver_Registrar_Heartbeat) DecodeFromPtr(p capnp.Ptr) HostPortResolver_Registrar_Heartbeat {
	return HostPortResolver_Registrar_Heartbeat(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c HostPortResolver_Registrar_Heartbeat) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c HostPortResolver_Registrar_Heartbeat) IsSame(other HostPortResolver_Registrar_Heartbeat) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c HostPortResolver_Registrar_Heartbeat) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c HostPortResolver_Registrar_Heartbeat) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
} // A HostPortResolver_Registrar_Heartbeat_Server is a HostPortResolver_Registrar_Heartbeat with a local implementation.
type HostPortResolver_Registrar_Heartbeat_Server interface {
	Beat(context.Context, HostPortResolver_Registrar_Heartbeat_beat) error
}

// HostPortResolver_Registrar_Heartbeat_NewServer creates a new Server from an implementation of HostPortResolver_Registrar_Heartbeat_Server.
func HostPortResolver_Registrar_Heartbeat_NewServer(s HostPortResolver_Registrar_Heartbeat_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(HostPortResolver_Registrar_Heartbeat_Methods(nil, s), s, c)
}

// HostPortResolver_Registrar_Heartbeat_ServerToClient creates a new Client from an implementation of HostPortResolver_Registrar_Heartbeat_Server.
// The caller is responsible for calling Release on the returned Client.
func HostPortResolver_Registrar_Heartbeat_ServerToClient(s HostPortResolver_Registrar_Heartbeat_Server) HostPortResolver_Registrar_Heartbeat {
	return HostPortResolver_Registrar_Heartbeat(capnp.NewClient(HostPortResolver_Registrar_Heartbeat_NewServer(s)))
}

// HostPortResolver_Registrar_Heartbeat_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func HostPortResolver_Registrar_Heartbeat_Methods(methods []server.Method, s HostPortResolver_Registrar_Heartbeat_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x87de92d2d68df26f,
			MethodID:      0,
			InterfaceName: "persistence.capnp:HostPortResolver.Registrar.Heartbeat",
			MethodName:    "beat",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Beat(ctx, HostPortResolver_Registrar_Heartbeat_beat{call})
		},
	})

	return methods
}

// HostPortResolver_Registrar_Heartbeat_beat holds the state for a server call to HostPortResolver_Registrar_Heartbeat.beat.
// See server.Call for documentation.
type HostPortResolver_Registrar_Heartbeat_beat struct {
	*server.Call
}

// Args returns the call's arguments.
func (c HostPortResolver_Registrar_Heartbeat_beat) Args() HostPortResolver_Registrar_Heartbeat_beat_Params {
	return HostPortResolver_Registrar_Heartbeat_beat_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c HostPortResolver_Registrar_Heartbeat_beat) AllocResults() (HostPortResolver_Registrar_Heartbeat_beat_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return HostPortResolver_Registrar_Heartbeat_beat_Results(r), err
}

// HostPortResolver_Registrar_Heartbeat_List is a list of HostPortResolver_Registrar_Heartbeat.
type HostPortResolver_Registrar_Heartbeat_List = capnp.CapList[HostPortResolver_Registrar_Heartbeat]

// NewHostPortResolver_Registrar_Heartbeat creates a new list of HostPortResolver_Registrar_Heartbeat.
func NewHostPortResolver_Registrar_Heartbeat_List(s *capnp.Segment, sz int32) (HostPortResolver_Registrar_Heartbeat_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[HostPortResolver_Registrar_Heartbeat](l), err
}

type HostPortResolver_Registrar_Heartbeat_beat_Params capnp.Struct

// HostPortResolver_Registrar_Heartbeat_beat_Params_TypeID is the unique identifier for the type HostPortResolver_Registrar_Heartbeat_beat_Params.
const HostPortResolver_Registrar_Heartbeat_beat_Params_TypeID = 0xebff70497e0ba555

func NewHostPortResolver_Registrar_Heartbeat_beat_Params(s *capnp.Segment) (HostPortResolver_Registrar_Heartbeat_beat_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return HostPortResolver_Registrar_Heartbeat_beat_Params(st), err
}

func NewRootHostPortResolver_Registrar_Heartbeat_beat_Params(s *capnp.Segment) (HostPortResolver_Registrar_Heartbeat_beat_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return HostPortResolver_Registrar_Heartbeat_beat_Params(st), err
}

func ReadRootHostPortResolver_Registrar_Heartbeat_beat_Params(msg *capnp.Message) (HostPortResolver_Registrar_Heartbeat_beat_Params, error) {
	root, err := msg.Root()
	return HostPortResolver_Registrar_Heartbeat_beat_Params(root.Struct()), err
}

func (s HostPortResolver_Registrar_Heartbeat_beat_Params) String() string {
	str, _ := text.Marshal(0xebff70497e0ba555, capnp.Struct(s))
	return str
}

func (s HostPortResolver_Registrar_Heartbeat_beat_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (HostPortResolver_Registrar_Heartbeat_beat_Params) DecodeFromPtr(p capnp.Ptr) HostPortResolver_Registrar_Heartbeat_beat_Params {
	return HostPortResolver_Registrar_Heartbeat_beat_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s HostPortResolver_Registrar_Heartbeat_beat_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s HostPortResolver_Registrar_Heartbeat_beat_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s HostPortResolver_Registrar_Heartbeat_beat_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s HostPortResolver_Registrar_Heartbeat_beat_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// HostPortResolver_Registrar_Heartbeat_beat_Params_List is a list of HostPortResolver_Registrar_Heartbeat_beat_Params.
type HostPortResolver_Registrar_Heartbeat_beat_Params_List = capnp.StructList[HostPortResolver_Registrar_Heartbeat_beat_Params]

// NewHostPortResolver_Registrar_Heartbeat_beat_Params creates a new list of HostPortResolver_Registrar_Heartbeat_beat_Params.
func NewHostPortResolver_Registrar_Heartbeat_beat_Params_List(s *capnp.Segment, sz int32) (HostPortResolver_Registrar_Heartbeat_beat_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[HostPortResolver_Registrar_Heartbeat_beat_Params](l), err
}

// HostPortResolver_Registrar_Heartbeat_beat_Params_Future is a wrapper for a HostPortResolver_Registrar_Heartbeat_beat_Params promised by a client call.
type HostPortResolver_Registrar_Heartbeat_beat_Params_Future struct{ *capnp.Future }

func (f HostPortResolver_Registrar_Heartbeat_beat_Params_Future) Struct() (HostPortResolver_Registrar_Heartbeat_beat_Params, error) {
	p, err := f.Future.Ptr()
	return HostPortResolver_Registrar_Heartbeat_beat_Params(p.Struct()), err
}

type HostPortResolver_Registrar_Heartbeat_beat_Results capnp.Struct

// HostPortResolver_Registrar_Heartbeat_beat_Results_TypeID is the unique identifier for the type HostPortResolver_Registrar_Heartbeat_beat_Results.
const HostPortResolver_Registrar_Heartbeat_beat_Results_TypeID = 0x9510c22fa544a65e

func NewHostPortResolver_Registrar_Heartbeat_beat_Results(s *capnp.Segment) (HostPortResolver_Registrar_Heartbeat_beat_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return HostPortResolver_Registrar_Heartbeat_beat_Results(st), err
}

func NewRootHostPortResolver_Registrar_Heartbeat_beat_Results(s *capnp.Segment) (HostPortResolver_Registrar_Heartbeat_beat_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return HostPortResolver_Registrar_Heartbeat_beat_Results(st), err
}

func ReadRootHostPortResolver_Registrar_Heartbeat_beat_Results(msg *capnp.Message) (HostPortResolver_Registrar_Heartbeat_beat_Results, error) {
	root, err := msg.Root()
	return HostPortResolver_Registrar_Heartbeat_beat_Results(root.Struct()), err
}

func (s HostPortResolver_Registrar_Heartbeat_beat_Results) String() string {
	str, _ := text.Marshal(0x9510c22fa544a65e, capnp.Struct(s))
	return str
}

func (s HostPortResolver_Registrar_Heartbeat_beat_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (HostPortResolver_Registrar_Heartbeat_beat_Results) DecodeFromPtr(p capnp.Ptr) HostPortResolver_Registrar_Heartbeat_beat_Results {
	return HostPortResolver_Registrar_Heartbeat_beat_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s HostPortResolver_Registrar_Heartbeat_beat_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s HostPortResolver_Registrar_Heartbeat_beat_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s HostPortResolver_Registrar_Heartbeat_beat_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s HostPortResolver_Registrar_Heartbeat_beat_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// HostPortResolver_Registrar_Heartbeat_beat_Results_List is a list of HostPortResolver_Registrar_Heartbeat_beat_Results.
type HostPortResolver_Registrar_Heartbeat_beat_Results_List = capnp.StructList[HostPortResolver_Registrar_Heartbeat_beat_Results]

// NewHostPortResolver_Registrar_Heartbeat_beat_Results creates a new list of HostPortResolver_Registrar_Heartbeat_beat_Results.
func NewHostPortResolver_Registrar_Heartbeat_beat_Results_List(s *capnp.Segment, sz int32) (HostPortResolver_Registrar_Heartbeat_beat_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[HostPortResolver_Registrar_Heartbeat_beat_Results](l), err
}

// HostPortResolver_Registrar_Heartbeat_beat_Results_Future is a wrapper for a HostPortResolver_Registrar_Heartbeat_beat_Results promised by a client call.
type HostPortResolver_Registrar_Heartbeat_beat_Results_Future struct{ *capnp.Future }

func (f HostPortResolver_Registrar_Heartbeat_beat_Results_Future) Struct() (HostPortResolver_Registrar_Heartbeat_beat_Results, error) {
	p, err := f.Future.Ptr()
	return HostPortResolver_Registrar_Heartbeat_beat_Results(p.Struct()), err
}

type HostPortResolver_Registrar_register_Params capnp.Struct

// HostPortResolver_Registrar_register_Params_TypeID is the unique identifier for the type HostPortResolver_Registrar_register_Params.
const HostPortResolver_Registrar_register_Params_TypeID = 0xb5f200df6e0373e6

func NewHostPortResolver_Registrar_register_Params(s *capnp.Segment) (HostPortResolver_Registrar_register_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3})
	return HostPortResolver_Registrar_register_Params(st), err
}

func NewRootHostPortResolver_Registrar_register_Params(s *capnp.Segment) (HostPortResolver_Registrar_register_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3})
	return HostPortResolver_Registrar_register_Params(st), err
}

func ReadRootHostPortResolver_Registrar_register_Params(msg *capnp.Message) (HostPortResolver_Registrar_register_Params, error) {
	root, err := msg.Root()
	return HostPortResolver_Registrar_register_Params(root.Struct()), err
}

func (s HostPortResolver_Registrar_register_Params) String() string {
	str, _ := text.Marshal(0xb5f200df6e0373e6, capnp.Struct(s))
	return str
}

func (s HostPortResolver_Registrar_register_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (HostPortResolver_Registrar_register_Params) DecodeFromPtr(p capnp.Ptr) HostPortResolver_Registrar_register_Params {
	return HostPortResolver_Registrar_register_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s HostPortResolver_Registrar_register_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s HostPortResolver_Registrar_register_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s HostPortResolver_Registrar_register_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s HostPortResolver_Registrar_register_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s HostPortResolver_Registrar_register_Params) Base64VatId() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s HostPortResolver_Registrar_register_Params) HasBase64VatId() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s HostPortResolver_Registrar_register_Params) Base64VatIdBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s HostPortResolver_Registrar_register_Params) SetBase64VatId(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s HostPortResolver_Registrar_register_Params) Host() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s HostPortResolver_Registrar_register_Params) HasHost() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s HostPortResolver_Registrar_register_Params) HostBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s HostPortResolver_Registrar_register_Params) SetHost(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s HostPortResolver_Registrar_register_Params) Port() uint16 {
	return capnp.Struct(s).Uint16(0)
}

func (s HostPortResolver_Registrar_register_Params) SetPort(v uint16) {
	capnp.Struct(s).SetUint16(0, v)
}

func (s HostPortResolver_Registrar_register_Params) Alias() (string, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.Text(), err
}

func (s HostPortResolver_Registrar_register_Params) HasAlias() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s HostPortResolver_Registrar_register_Params) AliasBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.TextBytes(), err
}

func (s HostPortResolver_Registrar_register_Params) SetAlias(v string) error {
	return capnp.Struct(s).SetText(2, v)
}

// HostPortResolver_Registrar_register_Params_List is a list of HostPortResolver_Registrar_register_Params.
type HostPortResolver_Registrar_register_Params_List = capnp.StructList[HostPortResolver_Registrar_register_Params]

// NewHostPortResolver_Registrar_register_Params creates a new list of HostPortResolver_Registrar_register_Params.
func NewHostPortResolver_Registrar_register_Params_List(s *capnp.Segment, sz int32) (HostPortResolver_Registrar_register_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3}, sz)
	return capnp.StructList[HostPortResolver_Registrar_register_Params](l), err
}

// HostPortResolver_Registrar_register_Params_Future is a wrapper for a HostPortResolver_Registrar_register_Params promised by a client call.
type HostPortResolver_Registrar_register_Params_Future struct{ *capnp.Future }

func (f HostPortResolver_Registrar_register_Params_Future) Struct() (HostPortResolver_Registrar_register_Params, error) {
	p, err := f.Future.Ptr()
	return HostPortResolver_Registrar_register_Params(p.Struct()), err
}

type HostPortResolver_Registrar_register_Results capnp.Struct

// HostPortResolver_Registrar_register_Results_TypeID is the unique identifier for the type HostPortResolver_Registrar_register_Results.
const HostPortResolver_Registrar_register_Results_TypeID = 0xfafc816633f98bb9

func NewHostPortResolver_Registrar_register_Results(s *capnp.Segment) (HostPortResolver_Registrar_register_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return HostPortResolver_Registrar_register_Results(st), err
}

func NewRootHostPortResolver_Registrar_register_Results(s *capnp.Segment) (HostPortResolver_Registrar_register_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return HostPortResolver_Registrar_register_Results(st), err
}

func ReadRootHostPortResolver_Registrar_register_Results(msg *capnp.Message) (HostPortResolver_Registrar_register_Results, error) {
	root, err := msg.Root()
	return HostPortResolver_Registrar_register_Results(root.Struct()), err
}

func (s HostPortResolver_Registrar_register_Results) String() string {
	str, _ := text.Marshal(0xfafc816633f98bb9, capnp.Struct(s))
	return str
}

func (s HostPortResolver_Registrar_register_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (HostPortResolver_Registrar_register_Results) DecodeFromPtr(p capnp.Ptr) HostPortResolver_Registrar_register_Results {
	return HostPortResolver_Registrar_register_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s HostPortResolver_Registrar_register_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s HostPortResolver_Registrar_register_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s HostPortResolver_Registrar_register_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s HostPortResolver_Registrar_register_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s HostPortResolver_Registrar_register_Results) Heartbeat() HostPortResolver_Registrar_Heartbeat {
	p, _ := capnp.Struct(s).Ptr(0)
	return HostPortResolver_Registrar_Heartbeat(p.Interface().Client())
}

func (s HostPortResolver_Registrar_register_Results) HasHeartbeat() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s HostPortResolver_Registrar_register_Results) SetHeartbeat(v HostPortResolver_Registrar_Heartbeat) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

func (s HostPortResolver_Registrar_register_Results) SecsHeartbeatInterval() uint32 {
	return capnp.Struct(s).Uint32(0)
}

func (s HostPortResolver_Registrar_register_Results) SetSecsHeartbeatInterval(v uint32) {
	capnp.Struct(s).SetUint32(0, v)
}

// HostPortResolver_Registrar_register_Results_List is a list of HostPortResolver_Registrar_register_Results.
type HostPortResolver_Registrar_register_Results_List = capnp.StructList[HostPortResolver_Registrar_register_Results]

// NewHostPortResolver_Registrar_register_Results creates a new list of HostPortResolver_Registrar_register_Results.
func NewHostPortResolver_Registrar_register_Results_List(s *capnp.Segment, sz int32) (HostPortResolver_Registrar_register_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[HostPortResolver_Registrar_register_Results](l), err
}

// HostPortResolver_Registrar_register_Results_Future is a wrapper for a HostPortResolver_Registrar_register_Results promised by a client call.
type HostPortResolver_Registrar_register_Results_Future struct{ *capnp.Future }

func (f HostPortResolver_Registrar_register_Results_Future) Struct() (HostPortResolver_Registrar_register_Results, error) {
	p, err := f.Future.Ptr()
	return HostPortResolver_Registrar_register_Results(p.Struct()), err
}
func (p HostPortResolver_Registrar_register_Results_Future) Heartbeat() HostPortResolver_Registrar_Heartbeat {
	return HostPortResolver_Registrar_Heartbeat(p.Future.Field(0, nil).Client())
}

type HostPortResolver_ResolveIdent_Params capnp.Struct

// HostPortResolver_ResolveIdent_Params_TypeID is the unique identifier for the type HostPortResolver_ResolveIdent_Params.
const HostPortResolver_ResolveIdent_Params_TypeID = 0xe6f8966f0f2cbb33

func NewHostPortResolver_ResolveIdent_Params(s *capnp.Segment) (HostPortResolver_ResolveIdent_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HostPortResolver_ResolveIdent_Params(st), err
}

func NewRootHostPortResolver_ResolveIdent_Params(s *capnp.Segment) (HostPortResolver_ResolveIdent_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return HostPortResolver_ResolveIdent_Params(st), err
}

func ReadRootHostPortResolver_ResolveIdent_Params(msg *capnp.Message) (HostPortResolver_ResolveIdent_Params, error) {
	root, err := msg.Root()
	return HostPortResolver_ResolveIdent_Params(root.Struct()), err
}

func (s HostPortResolver_ResolveIdent_Params) String() string {
	str, _ := text.Marshal(0xe6f8966f0f2cbb33, capnp.Struct(s))
	return str
}

func (s HostPortResolver_ResolveIdent_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (HostPortResolver_ResolveIdent_Params) DecodeFromPtr(p capnp.Ptr) HostPortResolver_ResolveIdent_Params {
	return HostPortResolver_ResolveIdent_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s HostPortResolver_ResolveIdent_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s HostPortResolver_ResolveIdent_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s HostPortResolver_ResolveIdent_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s HostPortResolver_ResolveIdent_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s HostPortResolver_ResolveIdent_Params) Id() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s HostPortResolver_ResolveIdent_Params) HasId() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s HostPortResolver_ResolveIdent_Params) IdBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s HostPortResolver_ResolveIdent_Params) SetId(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// HostPortResolver_ResolveIdent_Params_List is a list of HostPortResolver_ResolveIdent_Params.
type HostPortResolver_ResolveIdent_Params_List = capnp.StructList[HostPortResolver_ResolveIdent_Params]

// NewHostPortResolver_ResolveIdent_Params creates a new list of HostPortResolver_ResolveIdent_Params.
func NewHostPortResolver_ResolveIdent_Params_List(s *capnp.Segment, sz int32) (HostPortResolver_ResolveIdent_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[HostPortResolver_ResolveIdent_Params](l), err
}

// HostPortResolver_ResolveIdent_Params_Future is a wrapper for a HostPortResolver_ResolveIdent_Params promised by a client call.
type HostPortResolver_ResolveIdent_Params_Future struct{ *capnp.Future }

func (f HostPortResolver_ResolveIdent_Params_Future) Struct() (HostPortResolver_ResolveIdent_Params, error) {
	p, err := f.Future.Ptr()
	return HostPortResolver_ResolveIdent_Params(p.Struct()), err
}

type HostPortResolver_ResolveIdent_Results capnp.Struct

// HostPortResolver_ResolveIdent_Results_TypeID is the unique identifier for the type HostPortResolver_ResolveIdent_Results.
const HostPortResolver_ResolveIdent_Results_TypeID = 0xfc185f518d220b8c

func NewHostPortResolver_ResolveIdent_Results(s *capnp.Segment) (HostPortResolver_ResolveIdent_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return HostPortResolver_ResolveIdent_Results(st), err
}

func NewRootHostPortResolver_ResolveIdent_Results(s *capnp.Segment) (HostPortResolver_ResolveIdent_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return HostPortResolver_ResolveIdent_Results(st), err
}

func ReadRootHostPortResolver_ResolveIdent_Results(msg *capnp.Message) (HostPortResolver_ResolveIdent_Results, error) {
	root, err := msg.Root()
	return HostPortResolver_ResolveIdent_Results(root.Struct()), err
}

func (s HostPortResolver_ResolveIdent_Results) String() string {
	str, _ := text.Marshal(0xfc185f518d220b8c, capnp.Struct(s))
	return str
}

func (s HostPortResolver_ResolveIdent_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (HostPortResolver_ResolveIdent_Results) DecodeFromPtr(p capnp.Ptr) HostPortResolver_ResolveIdent_Results {
	return HostPortResolver_ResolveIdent_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s HostPortResolver_ResolveIdent_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s HostPortResolver_ResolveIdent_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s HostPortResolver_ResolveIdent_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s HostPortResolver_ResolveIdent_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s HostPortResolver_ResolveIdent_Results) Host() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s HostPortResolver_ResolveIdent_Results) HasHost() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s HostPortResolver_ResolveIdent_Results) HostBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s HostPortResolver_ResolveIdent_Results) SetHost(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s HostPortResolver_ResolveIdent_Results) Port() uint16 {
	return capnp.Struct(s).Uint16(0)
}

func (s HostPortResolver_ResolveIdent_Results) SetPort(v uint16) {
	capnp.Struct(s).SetUint16(0, v)
}

// HostPortResolver_ResolveIdent_Results_List is a list of HostPortResolver_ResolveIdent_Results.
type HostPortResolver_ResolveIdent_Results_List = capnp.StructList[HostPortResolver_ResolveIdent_Results]

// NewHostPortResolver_ResolveIdent_Results creates a new list of HostPortResolver_ResolveIdent_Results.
func NewHostPortResolver_ResolveIdent_Results_List(s *capnp.Segment, sz int32) (HostPortResolver_ResolveIdent_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[HostPortResolver_ResolveIdent_Results](l), err
}

// HostPortResolver_ResolveIdent_Results_Future is a wrapper for a HostPortResolver_ResolveIdent_Results promised by a client call.
type HostPortResolver_ResolveIdent_Results_Future struct{ *capnp.Future }

func (f HostPortResolver_ResolveIdent_Results_Future) Struct() (HostPortResolver_ResolveIdent_Results, error) {
	p, err := f.Future.Ptr()
	return HostPortResolver_ResolveIdent_Results(p.Struct()), err
}

const schema_855efed3475f6b26 = "x\xda\x9c\x97}l[W\x15\xc0\xcfy\xf7\xc5\xcfN" +
	"\xec8\xd77e(,2\xa4)\x1d\xa1\xf1\x9a\xa4M" +
	"\xa1\xda\x94&\x90\xa6\x09\x9a\xc8}a\x93\xda\xd1\xae/" +
	"\xf1\xcd\xe2\xcd\xb1\xdd\xf7\x9e\xd3\x05Md\x15\x9b\xc6>" +
	"\xa2\xb1\x01\x13EH\xddD\x0bl\xd24Vi\x13\x85" +
	"?P\xab!\x0d\xaaJ\xb4P\xa6t\xd3\xc6\x87Z\xd0" +
	"\xd8\x84\x88\x84`c\xf4\xa1\xfb\xec\xf7a\xd7\xcd\xb6\xfe" +
	"\x13\xe5\xddw\xde\xf9\xfc\x9ds\xae7_Vw\xa8}" +
	"\x89_\xc6A\xe1\xdfi\x8a8\xc5\xd5\xe5?\x9c{\xe2" +
	"\x8d\x07\x81\xf6\x12\xe7\xf8\xb7v\x96\xca\xff\xfe\xcdO\x01" +
	"p`4\xf2sd{#\x1a\x00\xdb\x1d\x19c\x87\xe4" +
	"\x7f\xce-o|\xa3s\xe3\xdc\xfc7\x81\xa7\x10\x9dO" +
	"\xdf}\xc7\xd8\xef.\xef{\x00FQS\x00X.\xf2" +
	"gV\x8el\x03`\x87#\x07\x01\x1d=s\xe4c\x87" +
	"\x92\xa5\xc7\x80v\x12G\x9c\x1e|\xfd\xa9\x0b?>)" +
	"u\xbf\x1b1\x91%4\xa9;\xa6\x8d\xb1\xdd\xf2?'" +
	"\xf7\xf0C7\xa8{\x8f?\x06\xbc\x03\x89\x93\xb8\xfd\xa9" +
	"\x03\x91Cc\xff\x85u\xa8!\x00\x1b\xd6V\x01\xd9\xa8" +
	"&\xf5N\xfd\xad\xad\xfb/\x85\xdeo\x03\xcf \x02\xa8" +
	"\x1a\xc0\xc0\xd3\xda*\x02\xb2\x17\xb5!@g\xdf\x8f\xbe" +
	"x\xec\xc6Sm\xdf\x05\xba\xcd{\x7f^\xebR@u" +
	"n\xca\xacl\xbc\xffS/\x1d\x01\x9a\"\x81\xff\x80\xec" +
	"\x8cv\x81\xadh\xd7\x01\xb0\x8b\xda\x18KD\xa5G\xaf" +
	"\xfc\xf0'\xab\xc6\xef?{\x14\xe8\xf5\x18\x84\xde\xa4H" +
	"}\xff\xd2\xfa\x915I1\x86Q\xe9\xd4\xba{\xef[" +
	"\xf9\xe4\xa3\xaf\x1d\x05\x9a\xf1l\x1a\xd1\xb7\x10T\xe7H" +
	"\xe7o_z\xef\xf1\xe5g\xebm\x0e\xdc\x1a\xed@&" +
	"\xa2\xd2\xe8\x81\xe8\x18;\x19\xdd\x08\x10\xd4\x80\xae'\xc1" +
	"\xa7\x80\x03'\xa2w!;\xe3J\xafD\xc7XSL" +
	"\x03x\xf3\x92E\x0ao\xae\xbe\xc8{e\"\x9a\x88\xb4" +
	"\xfa\x8e\xb4\x8a\x0cc\x7f\x05\x0c\xb2^\x1f\xefJ\xec-" +
	"v1&k\xb5\xaey\x8c\xdd\xdc,\xe3\xdd\xfe\xea\xb6" +
	"\x89\x85\x8b\xc3\xbf\x02\xfa\x09\x0c2U\x89wC\xf3\x04" +
	"\xb2\xcfK1\xb6\xb5Y\xc6\xfb\xb3}}xt\xf1\xd2" +
	"i\xe0\xd7\xa3\x1ad\xc7\x0d\xfcps\x07\xb2g\\\xe1" +
	"c\xcd\xd2\x8d/\x90}]/?\xfb\xc7\xf3@;C" +
	">5\xa1\x14^l\x19A\xf6P\x8b\x14~\xa0EV" +
	"\xef\xc1\xfb^~m\xf5\xcc\xdb+@S!\xc6\\7" +
	"\xd8\xb1\x96s\xec\x05W\xf6\xb9\x16\xe9\xc5\x86[2\x1b" +
	":\xe7\x9f\xbc ]\x86\xaa\xc2X|\x8fL\xc0\xba\xb8" +
	"T\xc6\xde\xde\xf4\xbd\x7f\x9c\xbd\xfd\xf5:\xcbnL[" +
	"\xe3\x13\xc8\xc6\xe3R\xdbh\\j[>\xfb\xc8y{" +
	"o\xf3\x9f$\xdej`Z\xc6\xc4\x9e\x89\x9fb/\xb8" +
	"\xb2\xcf\xc5eH\x03\xbf\xd8\x94,>\xf9\x9fK@\xd7" +
	"\xfb\x96\x1fO<!-?\x9d\x90\x96o=\xd6\xf2\xf5" +
	"\xf1\x92\xf3\xf7\x10\x84'\x13\x1d\x12\xc2\x13\x8f\xbc;0" +
	"{\xe8\xfd\xf7\xa0Z6\xf7\xdb\x13\x09\x17\xe03\x09\xe9" +
	"\x88O?O!\xa9\xed3\x8c\xb1\xad\xad\xe7\xd8p\xab" +
	"t\xe5\xe6\xd6\xe7\x01\x9dG[\xba\x96\xf9\x1d\x1f\x7f\x1f" +
	"\xf8\xfa\x90\xbe\xd6\xefK}\xbfn\x95\xfa\xd6\x1f|e" +
	"\xff;\x87_\xfd_\x1d\xc9\xae\xe0\x86d\x0a\xd9\xd6\xa4" +
	"T\xd7\x97\x1c\x82\xaf9%aZ9\xcb\x16M\x85\x19" +
	"\x91\x991J\x85\xd2\xf6]E\xcb\x9e,\x9a\xb6.\xac" +
	"b~A\x98\x19]\xdc\x99\xb3l\xd303\xbb\x841" +
	"d\xda\xd3\xc2\xb0'\x11\xb9J\x9a\x00\xfc\xd0\xd1kD" +
	"J{@\xa1MZR\xca\xed\xc0ID\xdf\x8a\x12X" +
	"\x99\xb2\xcbfvQ\xd3\xc5,\x8fc\xd8i\xda\x1f\xea" +
	"\xc5\x84\x1e\xb0G\x13\xdb\xd3_>X\x10\xa6\xf3\x15\xd3" +
	"(X9Q\x00\xb4\x87\xa6\xec\xa2)\xb2<J\xd4\xb8" +
	"\xe3\xa8\x08@?\xa3\x03\xf0\x1b\x08\xf2-\x0a&\xf0\xb2" +
	"\xd3.\xf3D\xfb\xb6\x03\xf0M\x04\xf9\xe7\x14t\xec@" +
	"\x01\xb6\x05\xe6\x00\xb1\x0dp\xc8rUb[`\xba\xf2" +
	"\xc2\x0fC\x0d\xc2\x98\xac\x1e\x15\xec\x8c.\xf2\xc2\xb0\x84" +
	"\x0c,\x9d]\xd4\xc5l\x90#o^\xa07\xcd(\x1d" +
	"\xa14\x0dH{\xb5%\xb3\xf2\x1dWQq\xfe\xb9|" +
	"\xe3u\xa9\xfd'N\x01W\x15\x1cnG\x8c\x03P\xd4" +
	"\x9d\xaa\xcc\x14\xa0\x0ep\xd5\x9c\x0eg\xb3\xa6\xb0\xd2V" +
	"&W\x1a\x94\x19\x01\xa8$d\x04\x80w\x13\xe4\x9b\x15" +
	"\xa4\x88\x95|\xf4\x8e\x04YZ\xca\x17\x0f\x0asp\x0b" +
	"\xc6@\xc1\x18\xe0R\xb9T\x0a?\xfb\xb6\"\x1f\x14\xb8" +
	"\x1bw\xa6\xeam\xb7.\xd2V9o[\\\xf5}I" +
	"H\xb3Q\x82\xbc]\xc1%\xab<3#,\x0b\x11\x14" +
	"\xc4\x90\x19\xed\xc3\xc2Xa1#\xfft\xeb\xc2*k" +
	"y\xdbj\x94\x18]\xc8\x9a\x12ar\x1514\xfa\xd0" +
	"t*\xaf\xc4$\xa4\x0d\xd3\x98\xb7\xaa\x05\xf3D\xd0\x9b" +
	"9\x94\x8e\xb8P/\x99\x15\xf9\xda\x1a\x90z\xaee\x16" +
	"$\xa5iI\x99\xdb,\xa1rt5*\xc7D\x80\xa7" +
	"\xb6`H,\xfd\xd1X\xa5/_\x9c1\xf2\xba\x98\x05" +
	"\x00L\x81\x82\xa9k/\xcc\xa4\x91\x94\xc16\xf2\xbf6" +
	"\xe1^\xca\x82E\x85\xba\xe3\x95\x00\xd0\xac\xa6\xcb\x9b\x8f" +
	"\xe8M\xa7Z\xbe\xdd\xd2\xad\xc1\xf7]N\xb5\xbc\xe3\x90" +
	"\xcc\x8a\x82-\x11\xe7QD\xe7\xfc\xae\x1f\xec>}\xf6" +
	"\xf9\xe3\x00\x10\xec(\x80F\x8d\xd8\x18\x94\xa4$\xc5\x8d" +
	" \xb8\xfb\xa0\xeex\xe8\x00\xda\x95\x08\xbc\xdd\x1a\x8ck" +
	"J'@\xa11\xcd1\xddh\x85\x09\xf5\x8d\x17\xf9P" +
	"\x94z\x9f{9\xe7m>\x08\xc64\x00\xdfO\x90\xe7" +
	"C \xe4z\x00x\x96 /)\x88J;*\x00t" +
	"^\x9e\xcd\x11\xe4\xb6\x82\x94(\xedH\x00\xe8\x81~\x00" +
	"\x9e'\xc8\xefQ\xd0\x996,1\xb8\xe56\x034{" +
	"<\x8bqP0\x0e\x98\x9c+Z\xb6\xffP*\x9a6" +
	"j\xa0\xa0\x06\x986\xf29\xc3\xf2^5\xea\x98\x0aE" +
	"I\x89\x91;\x9f\x83\xa5N\xf7\x84\xf6,\x9d\x0e]\xfc" +
	"\xe8\xc3\xce\x94\xb1 &\x0d\xd3\x002o\xb9\x0f\xb2+" +
	"\xc1mK\x0fF\xf4h\x04\xa8\xd2\xe3\xe9FO\xaf\xbf" +
	"A,c\xa1\xae\xd3\xd4\xfa\xa6v\x93]ia\xb7\x81" +
	"\x01\xea\xbam\"\x98s~\x92\xfb\xe4\x8a\xd8L\x90\xdf" +
	"\xa44\xee+K\x18y\x91\xddY\x044\xb1-XN" +
	"u{\xa0a\xdbO\xb9\x93&+\xbd\x08\x95ZV\xf0" +
	"\xab\x04\xf9\\\xc8\x0b\xd1\x13\xaa\xbfR\xadu\xb8\xfe\x94" +
	"\x90J\xad\xc3\x00$\xef\x16\x8b\x9b\xbd\xc9,\x1f\xfa\xc2" +
	"\x0f\xfd\xe1\x87\x81+\x06x\xe3\xcd\xe5Um\xde\x82\xca" +
	"\xcej<\xad\x85\x91\xdfY\\+\x1f!~n3\xec" +
	"I\xc3\xc6\xb9\xbabt|\xc0&\"9\xb9w\xfd\xab" +
	"YE\xff\x92\xe1\xee5\x0b\xdb\x82\xbb\xd2\xd57\xb2\x8f" +
	"EuR\xbb\x8b!Oj\xb7PW\x10\x976c\x94" +
	"0\xa5\x12\xc0\x9a\x89z\xf5L\xb9\xfa\xec+A\xd3\x1b" +
	"\x816\x11\x02\xcd\xaa2\x028\x8bm\xc1\xcd\xac\x1aJ" +
	"\xb9 i\x9f\xd2%\x86W\xbem\x9c\xe2\xf1,\xd4q" +
	"\xb6\xa7\xd1H\xd9\x13\x1a\x1f\x1eg\x07\xe4a\x89 \xbf" +
	"7\xc4\xd9\xa2<\xbc\x87 \xbf_A\xa7T\x9e\xce\xe7" +
	"f\xbe$\x80\x04\xbc\x85\x0f\xfb\x1a\x1d\xf67:\xbc\x92" +
	"\xc3\xb5\xae\x9b\xd5}\xd1\xed\x12\x895e\xeb\x08\xca&" +
	"I\xa9\x9f_\xd7to\x90fHh\x17~\xc4\xb1\xee" +
	"\xdfq\x1a\x93\xe0\x83p\x1c\x80o!\xc8w(\xe8\xcc" +
	"\x05\xeb\x07i\xb0\x99\x00\x91\xba\xb3g\xc6\x92>\xa2\xeb" +
	"\xe4x\xc1N\x0bs\xc1\xc8c\x14\x14\x8c\xc2\x1a\x17?" +
	"\xb4$\x0cq\xf7&\x8c\x18\xfc\xc6\xa6\xa3]\xa0P%" +
	"Z)|oO\xfd\xf5XV\xbe\xaf't\xff\xc8\x95" +
	"\x06k\xd6E\xcd\"\xf9H5\xf4{/\x94\x9d\x9e`" +
	"\x06\xf8# \xe4\xd3\xd5\xb7\xd6\xdasW\xfe4@\xb3" +
	"n~\xf5\x04\xc0$\xef,\x07\xc8\xfc?\x00\x00\xff\xff" +
	"|\xa6\xd2|"

func init() {
	schemas.Register(schema_855efed3475f6b26,
		0x87de92d2d68df26f,
		0x886d68271d83de4d,
		0x8f700f81169f2e52,
		0x8fb25d0428898a69,
		0x932d6ee32410e853,
		0x9510c22fa544a65e,
		0x9fb6218427d92e3c,
		0xa42bd461f2a8a3c8,
		0xa4db8c20d9807c15,
		0xaa8d91fab6d01d9f,
		0xb0caf775704690b2,
		0xb5f200df6e0373e6,
		0xc1a7daa0dc36cb65,
		0xc541e5764a37d73a,
		0xcbe679a401315eb8,
		0xd5e0aac4225e0343,
		0xd9eccdf2dbc48087,
		0xda966d1d252e4d25,
		0xdc5bd1ef982cec13,
		0xe10a5d74d58bd18d,
		0xe6f8966f0f2cbb33,
		0xebff70497e0ba555,
		0xfafc816633f98bb9,
		0xfb47810671a05b0d,
		0xfc185f518d220b8c,
		0xfdd799ed60c87723)
}
