// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: persistence.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1000001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "common.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(e10a5d74d58bd18d);
CAPNP_DECLARE_SCHEMA(fb47810671a05b0d);
CAPNP_DECLARE_SCHEMA(8fb25d0428898a69);
CAPNP_DECLARE_SCHEMA(d9eccdf2dbc48087);
CAPNP_DECLARE_SCHEMA(886d68271d83de4d);
CAPNP_DECLARE_SCHEMA(fdd799ed60c87723);
CAPNP_DECLARE_SCHEMA(fa412bb47f11b488);
CAPNP_DECLARE_SCHEMA(c1a7daa0dc36cb65);
CAPNP_DECLARE_SCHEMA(d5e0aac4225e0343);
CAPNP_DECLARE_SCHEMA(dc5bd1ef982cec13);
CAPNP_DECLARE_SCHEMA(8f700f81169f2e52);
CAPNP_DECLARE_SCHEMA(a4db8c20d9807c15);
CAPNP_DECLARE_SCHEMA(932d6ee32410e853);
CAPNP_DECLARE_SCHEMA(9fb6218427d92e3c);
CAPNP_DECLARE_SCHEMA(c541e5764a37d73a);
CAPNP_DECLARE_SCHEMA(da966d1d252e4d25);
CAPNP_DECLARE_SCHEMA(aa8d91fab6d01d9f);
CAPNP_DECLARE_SCHEMA(b0caf775704690b2);
CAPNP_DECLARE_SCHEMA(87de92d2d68df26f);
CAPNP_DECLARE_SCHEMA(ebff70497e0ba555);
CAPNP_DECLARE_SCHEMA(9510c22fa544a65e);
CAPNP_DECLARE_SCHEMA(bf018f62ff460d0f);
CAPNP_DECLARE_SCHEMA(fafc816633f98bb9);
CAPNP_DECLARE_SCHEMA(e6f8966f0f2cbb33);
CAPNP_DECLARE_SCHEMA(fc185f518d220b8c);

}  // namespace schemas
}  // namespace capnp

namespace mas {
namespace schema {
namespace persistence {

struct VatId {
  VatId() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e10a5d74d58bd18d, 4, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Address {
  Address() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    IP6,
    HOST,
  };
  struct Ip6;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fb47810671a05b0d, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Address::Ip6 {
  Ip6() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8fb25d0428898a69, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VatPath {
  VatPath() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d9eccdf2dbc48087, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SturdyRef {
  SturdyRef() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Owner;
  struct Token;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(886d68271d83de4d, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SturdyRef::Owner {
  Owner() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fdd799ed60c87723, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SturdyRef::Token {
  Token() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    TEXT,
    DATA,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fa412bb47f11b488, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Persistent {
  Persistent() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct SaveParams;
  struct SaveResults;
  struct ReleaseSturdyRef;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(c1a7daa0dc36cb65)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Persistent::SaveParams {
  SaveParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d5e0aac4225e0343, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Persistent::SaveResults {
  SaveResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dc5bd1ef982cec13, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Persistent::ReleaseSturdyRef {
  ReleaseSturdyRef() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct ReleaseParams;
  struct ReleaseResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(8f700f81169f2e52)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Persistent::ReleaseSturdyRef::ReleaseParams {
  ReleaseParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a4db8c20d9807c15, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Persistent::ReleaseSturdyRef::ReleaseResults {
  ReleaseResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(932d6ee32410e853, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Restorer {
  Restorer() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct RestoreParams;
  struct RestoreResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(9fb6218427d92e3c)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Restorer::RestoreParams {
  RestoreParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c541e5764a37d73a, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Restorer::RestoreResults {
  RestoreResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(da966d1d252e4d25, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HostPortResolver {
  HostPortResolver() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct Registrar;
  struct ResolveParams;
  struct ResolveResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(aa8d91fab6d01d9f)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct HostPortResolver::Registrar {
  Registrar() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct Heartbeat;
  struct RegisterParams;
  struct RegisterResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(b0caf775704690b2)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct HostPortResolver::Registrar::Heartbeat {
  Heartbeat() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct BeatParams;
  struct BeatResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(87de92d2d68df26f)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct HostPortResolver::Registrar::Heartbeat::BeatParams {
  BeatParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ebff70497e0ba555, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HostPortResolver::Registrar::Heartbeat::BeatResults {
  BeatResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9510c22fa544a65e, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HostPortResolver::Registrar::RegisterParams {
  RegisterParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bf018f62ff460d0f, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HostPortResolver::Registrar::RegisterResults {
  RegisterResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fafc816633f98bb9, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HostPortResolver::ResolveParams {
  ResolveParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e6f8966f0f2cbb33, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HostPortResolver::ResolveResults {
  ResolveResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fc185f518d220b8c, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class VatId::Reader {
public:
  typedef VatId Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getPublicKey0() const;

  inline  ::uint64_t getPublicKey1() const;

  inline  ::uint64_t getPublicKey2() const;

  inline  ::uint64_t getPublicKey3() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VatId::Builder {
public:
  typedef VatId Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getPublicKey0();
  inline void setPublicKey0( ::uint64_t value);

  inline  ::uint64_t getPublicKey1();
  inline void setPublicKey1( ::uint64_t value);

  inline  ::uint64_t getPublicKey2();
  inline void setPublicKey2( ::uint64_t value);

  inline  ::uint64_t getPublicKey3();
  inline void setPublicKey3( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VatId::Pipeline {
public:
  typedef VatId Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Address::Reader {
public:
  typedef Address Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isIp6() const;
  inline typename Ip6::Reader getIp6() const;

  inline  ::uint16_t getPort() const;

  inline bool isHost() const;
  inline bool hasHost() const;
  inline  ::capnp::Text::Reader getHost() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Address::Builder {
public:
  typedef Address Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isIp6();
  inline typename Ip6::Builder getIp6();
  inline typename Ip6::Builder initIp6();

  inline  ::uint16_t getPort();
  inline void setPort( ::uint16_t value);

  inline bool isHost();
  inline bool hasHost();
  inline  ::capnp::Text::Builder getHost();
  inline void setHost( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initHost(unsigned int size);
  inline void adoptHost(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownHost();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Address::Pipeline {
public:
  typedef Address Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Address::Ip6::Reader {
public:
  typedef Ip6 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLower64() const;

  inline  ::uint64_t getUpper64() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Address::Ip6::Builder {
public:
  typedef Ip6 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLower64();
  inline void setLower64( ::uint64_t value);

  inline  ::uint64_t getUpper64();
  inline void setUpper64( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Address::Ip6::Pipeline {
public:
  typedef Ip6 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VatPath::Reader {
public:
  typedef VatPath Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasId() const;
  inline  ::mas::schema::persistence::VatId::Reader getId() const;

  inline bool hasAddress() const;
  inline  ::mas::schema::persistence::Address::Reader getAddress() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VatPath::Builder {
public:
  typedef VatPath Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasId();
  inline  ::mas::schema::persistence::VatId::Builder getId();
  inline void setId( ::mas::schema::persistence::VatId::Reader value);
  inline  ::mas::schema::persistence::VatId::Builder initId();
  inline void adoptId(::capnp::Orphan< ::mas::schema::persistence::VatId>&& value);
  inline ::capnp::Orphan< ::mas::schema::persistence::VatId> disownId();

  inline bool hasAddress();
  inline  ::mas::schema::persistence::Address::Builder getAddress();
  inline void setAddress( ::mas::schema::persistence::Address::Reader value);
  inline  ::mas::schema::persistence::Address::Builder initAddress();
  inline void adoptAddress(::capnp::Orphan< ::mas::schema::persistence::Address>&& value);
  inline ::capnp::Orphan< ::mas::schema::persistence::Address> disownAddress();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VatPath::Pipeline {
public:
  typedef VatPath Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::persistence::VatId::Pipeline getId();
  inline  ::mas::schema::persistence::Address::Pipeline getAddress();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SturdyRef::Reader {
public:
  typedef SturdyRef Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasVat() const;
  inline  ::mas::schema::persistence::VatPath::Reader getVat() const;

  inline bool hasLocalRef() const;
  inline  ::mas::schema::persistence::SturdyRef::Token::Reader getLocalRef() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SturdyRef::Builder {
public:
  typedef SturdyRef Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasVat();
  inline  ::mas::schema::persistence::VatPath::Builder getVat();
  inline void setVat( ::mas::schema::persistence::VatPath::Reader value);
  inline  ::mas::schema::persistence::VatPath::Builder initVat();
  inline void adoptVat(::capnp::Orphan< ::mas::schema::persistence::VatPath>&& value);
  inline ::capnp::Orphan< ::mas::schema::persistence::VatPath> disownVat();

  inline bool hasLocalRef();
  inline  ::mas::schema::persistence::SturdyRef::Token::Builder getLocalRef();
  inline void setLocalRef( ::mas::schema::persistence::SturdyRef::Token::Reader value);
  inline  ::mas::schema::persistence::SturdyRef::Token::Builder initLocalRef();
  inline void adoptLocalRef(::capnp::Orphan< ::mas::schema::persistence::SturdyRef::Token>&& value);
  inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef::Token> disownLocalRef();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SturdyRef::Pipeline {
public:
  typedef SturdyRef Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::persistence::VatPath::Pipeline getVat();
  inline  ::mas::schema::persistence::SturdyRef::Token::Pipeline getLocalRef();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SturdyRef::Owner::Reader {
public:
  typedef Owner Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasGuid() const;
  inline  ::capnp::Text::Reader getGuid() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SturdyRef::Owner::Builder {
public:
  typedef Owner Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasGuid();
  inline  ::capnp::Text::Builder getGuid();
  inline void setGuid( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initGuid(unsigned int size);
  inline void adoptGuid(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownGuid();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SturdyRef::Owner::Pipeline {
public:
  typedef Owner Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SturdyRef::Token::Reader {
public:
  typedef Token Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isText() const;
  inline bool hasText() const;
  inline  ::capnp::Text::Reader getText() const;

  inline bool isData() const;
  inline bool hasData() const;
  inline  ::capnp::Data::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SturdyRef::Token::Builder {
public:
  typedef Token Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isText();
  inline bool hasText();
  inline  ::capnp::Text::Builder getText();
  inline void setText( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initText(unsigned int size);
  inline void adoptText(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownText();

  inline bool isData();
  inline bool hasData();
  inline  ::capnp::Data::Builder getData();
  inline void setData( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SturdyRef::Token::Pipeline {
public:
  typedef Token Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Persistent::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Persistent Calls;
  typedef Persistent Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::persistence::Persistent::SaveParams,  ::mas::schema::persistence::Persistent::SaveResults> saveRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Persistent::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Persistent Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef ::capnp::CallContext< ::mas::schema::persistence::Persistent::SaveParams,  ::mas::schema::persistence::Persistent::SaveResults> SaveContext;
  virtual ::kj::Promise<void> save(SaveContext context);

  inline  ::mas::schema::persistence::Persistent::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::persistence::Persistent>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Persistent::SaveParams::Reader {
public:
  typedef SaveParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasSealFor() const;
  inline  ::mas::schema::persistence::SturdyRef::Owner::Reader getSealFor() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Persistent::SaveParams::Builder {
public:
  typedef SaveParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasSealFor();
  inline  ::mas::schema::persistence::SturdyRef::Owner::Builder getSealFor();
  inline void setSealFor( ::mas::schema::persistence::SturdyRef::Owner::Reader value);
  inline  ::mas::schema::persistence::SturdyRef::Owner::Builder initSealFor();
  inline void adoptSealFor(::capnp::Orphan< ::mas::schema::persistence::SturdyRef::Owner>&& value);
  inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef::Owner> disownSealFor();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Persistent::SaveParams::Pipeline {
public:
  typedef SaveParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::persistence::SturdyRef::Owner::Pipeline getSealFor();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Persistent::SaveResults::Reader {
public:
  typedef SaveResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasSturdyRef() const;
  inline  ::mas::schema::persistence::SturdyRef::Reader getSturdyRef() const;

  inline bool hasUnsaveSR() const;
  inline  ::mas::schema::persistence::SturdyRef::Reader getUnsaveSR() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Persistent::SaveResults::Builder {
public:
  typedef SaveResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasSturdyRef();
  inline  ::mas::schema::persistence::SturdyRef::Builder getSturdyRef();
  inline void setSturdyRef( ::mas::schema::persistence::SturdyRef::Reader value);
  inline  ::mas::schema::persistence::SturdyRef::Builder initSturdyRef();
  inline void adoptSturdyRef(::capnp::Orphan< ::mas::schema::persistence::SturdyRef>&& value);
  inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef> disownSturdyRef();

  inline bool hasUnsaveSR();
  inline  ::mas::schema::persistence::SturdyRef::Builder getUnsaveSR();
  inline void setUnsaveSR( ::mas::schema::persistence::SturdyRef::Reader value);
  inline  ::mas::schema::persistence::SturdyRef::Builder initUnsaveSR();
  inline void adoptUnsaveSR(::capnp::Orphan< ::mas::schema::persistence::SturdyRef>&& value);
  inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef> disownUnsaveSR();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Persistent::SaveResults::Pipeline {
public:
  typedef SaveResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::persistence::SturdyRef::Pipeline getSturdyRef();
  inline  ::mas::schema::persistence::SturdyRef::Pipeline getUnsaveSR();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Persistent::ReleaseSturdyRef::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef ReleaseSturdyRef Calls;
  typedef ReleaseSturdyRef Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::persistence::Persistent::ReleaseSturdyRef::ReleaseParams,  ::mas::schema::persistence::Persistent::ReleaseSturdyRef::ReleaseResults> releaseRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Persistent::ReleaseSturdyRef::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef ReleaseSturdyRef Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::persistence::Persistent::ReleaseSturdyRef::ReleaseParams ReleaseParams;
  typedef  ::mas::schema::persistence::Persistent::ReleaseSturdyRef::ReleaseResults ReleaseResults;
  typedef ::capnp::CallContext<ReleaseParams, ReleaseResults> ReleaseContext;
  virtual ::kj::Promise<void> release(ReleaseContext context);

  inline  ::mas::schema::persistence::Persistent::ReleaseSturdyRef::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::persistence::Persistent::ReleaseSturdyRef>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Persistent::ReleaseSturdyRef::ReleaseParams::Reader {
public:
  typedef ReleaseParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Persistent::ReleaseSturdyRef::ReleaseParams::Builder {
public:
  typedef ReleaseParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Persistent::ReleaseSturdyRef::ReleaseParams::Pipeline {
public:
  typedef ReleaseParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Persistent::ReleaseSturdyRef::ReleaseResults::Reader {
public:
  typedef ReleaseResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getSuccess() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Persistent::ReleaseSturdyRef::ReleaseResults::Builder {
public:
  typedef ReleaseResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getSuccess();
  inline void setSuccess(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Persistent::ReleaseSturdyRef::ReleaseResults::Pipeline {
public:
  typedef ReleaseResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Restorer::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Restorer Calls;
  typedef Restorer Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::persistence::Restorer::RestoreParams,  ::mas::schema::persistence::Restorer::RestoreResults> restoreRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Restorer::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Restorer Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::persistence::Restorer::RestoreResults RestoreResults;
  typedef ::capnp::CallContext< ::mas::schema::persistence::Restorer::RestoreParams, RestoreResults> RestoreContext;
  virtual ::kj::Promise<void> restore(RestoreContext context);

  inline  ::mas::schema::persistence::Restorer::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::persistence::Restorer>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Restorer::RestoreParams::Reader {
public:
  typedef RestoreParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLocalRef() const;
  inline  ::mas::schema::persistence::SturdyRef::Token::Reader getLocalRef() const;

  inline bool hasSealedBy() const;
  inline  ::mas::schema::persistence::SturdyRef::Owner::Reader getSealedBy() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Restorer::RestoreParams::Builder {
public:
  typedef RestoreParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLocalRef();
  inline  ::mas::schema::persistence::SturdyRef::Token::Builder getLocalRef();
  inline void setLocalRef( ::mas::schema::persistence::SturdyRef::Token::Reader value);
  inline  ::mas::schema::persistence::SturdyRef::Token::Builder initLocalRef();
  inline void adoptLocalRef(::capnp::Orphan< ::mas::schema::persistence::SturdyRef::Token>&& value);
  inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef::Token> disownLocalRef();

  inline bool hasSealedBy();
  inline  ::mas::schema::persistence::SturdyRef::Owner::Builder getSealedBy();
  inline void setSealedBy( ::mas::schema::persistence::SturdyRef::Owner::Reader value);
  inline  ::mas::schema::persistence::SturdyRef::Owner::Builder initSealedBy();
  inline void adoptSealedBy(::capnp::Orphan< ::mas::schema::persistence::SturdyRef::Owner>&& value);
  inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef::Owner> disownSealedBy();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Restorer::RestoreParams::Pipeline {
public:
  typedef RestoreParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::persistence::SturdyRef::Token::Pipeline getLocalRef();
  inline  ::mas::schema::persistence::SturdyRef::Owner::Pipeline getSealedBy();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Restorer::RestoreResults::Reader {
public:
  typedef RestoreResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCap() const;
#if !CAPNP_LITE
  inline  ::capnp::Capability::Client getCap() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Restorer::RestoreResults::Builder {
public:
  typedef RestoreResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCap();
#if !CAPNP_LITE
  inline  ::capnp::Capability::Client getCap();
  inline void setCap( ::capnp::Capability::Client&& value);
  inline void setCap( ::capnp::Capability::Client& value);
  inline void adoptCap(::capnp::Orphan< ::capnp::Capability>&& value);
  inline ::capnp::Orphan< ::capnp::Capability> disownCap();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Restorer::RestoreResults::Pipeline {
public:
  typedef RestoreResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::Capability::Client getCap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class HostPortResolver::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client,
      public virtual  ::mas::schema::persistence::Restorer::Client {
public:
  typedef HostPortResolver Calls;
  typedef HostPortResolver Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::persistence::HostPortResolver::ResolveParams,  ::mas::schema::persistence::HostPortResolver::ResolveResults> resolveRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class HostPortResolver::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server,
      public virtual  ::mas::schema::persistence::Restorer::Server {
public:
  typedef HostPortResolver Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::persistence::HostPortResolver::ResolveParams ResolveParams;
  typedef  ::mas::schema::persistence::HostPortResolver::ResolveResults ResolveResults;
  typedef ::capnp::CallContext<ResolveParams, ResolveResults> ResolveContext;
  virtual ::kj::Promise<void> resolve(ResolveContext context);

  inline  ::mas::schema::persistence::HostPortResolver::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::persistence::HostPortResolver>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class HostPortResolver::Registrar::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Registrar Calls;
  typedef Registrar Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::persistence::HostPortResolver::Registrar::RegisterParams,  ::mas::schema::persistence::HostPortResolver::Registrar::RegisterResults> registerRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class HostPortResolver::Registrar::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Registrar Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::persistence::HostPortResolver::Registrar::RegisterResults RegisterResults;
  typedef ::capnp::CallContext< ::mas::schema::persistence::HostPortResolver::Registrar::RegisterParams, RegisterResults> RegisterContext;
  virtual ::kj::Promise<void> register_(RegisterContext context);

  inline  ::mas::schema::persistence::HostPortResolver::Registrar::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::persistence::HostPortResolver::Registrar>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class HostPortResolver::Registrar::Heartbeat::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Heartbeat Calls;
  typedef Heartbeat Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat::BeatParams,  ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat::BeatResults> beatRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class HostPortResolver::Registrar::Heartbeat::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Heartbeat Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat::BeatParams BeatParams;
  typedef  ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat::BeatResults BeatResults;
  typedef ::capnp::CallContext<BeatParams, BeatResults> BeatContext;
  virtual ::kj::Promise<void> beat(BeatContext context);

  inline  ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class HostPortResolver::Registrar::Heartbeat::BeatParams::Reader {
public:
  typedef BeatParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HostPortResolver::Registrar::Heartbeat::BeatParams::Builder {
public:
  typedef BeatParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HostPortResolver::Registrar::Heartbeat::BeatParams::Pipeline {
public:
  typedef BeatParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HostPortResolver::Registrar::Heartbeat::BeatResults::Reader {
public:
  typedef BeatResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HostPortResolver::Registrar::Heartbeat::BeatResults::Builder {
public:
  typedef BeatResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HostPortResolver::Registrar::Heartbeat::BeatResults::Pipeline {
public:
  typedef BeatResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HostPortResolver::Registrar::RegisterParams::Reader {
public:
  typedef RegisterParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasBase64VatId() const;
  inline  ::capnp::Text::Reader getBase64VatId() const;

  inline bool hasHost() const;
  inline  ::capnp::Text::Reader getHost() const;

  inline  ::uint16_t getPort() const;

  inline bool hasAlias() const;
  inline  ::capnp::Text::Reader getAlias() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HostPortResolver::Registrar::RegisterParams::Builder {
public:
  typedef RegisterParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBase64VatId();
  inline  ::capnp::Text::Builder getBase64VatId();
  inline void setBase64VatId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initBase64VatId(unsigned int size);
  inline void adoptBase64VatId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownBase64VatId();

  inline bool hasHost();
  inline  ::capnp::Text::Builder getHost();
  inline void setHost( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initHost(unsigned int size);
  inline void adoptHost(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownHost();

  inline  ::uint16_t getPort();
  inline void setPort( ::uint16_t value);

  inline bool hasAlias();
  inline  ::capnp::Text::Builder getAlias();
  inline void setAlias( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initAlias(unsigned int size);
  inline void adoptAlias(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownAlias();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HostPortResolver::Registrar::RegisterParams::Pipeline {
public:
  typedef RegisterParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HostPortResolver::Registrar::RegisterResults::Reader {
public:
  typedef RegisterResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeartbeat() const;
#if !CAPNP_LITE
  inline  ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat::Client getHeartbeat() const;
#endif  // !CAPNP_LITE

  inline  ::uint32_t getSecsHeartbeatInterval() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HostPortResolver::Registrar::RegisterResults::Builder {
public:
  typedef RegisterResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeartbeat();
#if !CAPNP_LITE
  inline  ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat::Client getHeartbeat();
  inline void setHeartbeat( ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat::Client&& value);
  inline void setHeartbeat( ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat::Client& value);
  inline void adoptHeartbeat(::capnp::Orphan< ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat>&& value);
  inline ::capnp::Orphan< ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat> disownHeartbeat();
#endif  // !CAPNP_LITE

  inline  ::uint32_t getSecsHeartbeatInterval();
  inline void setSecsHeartbeatInterval( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HostPortResolver::Registrar::RegisterResults::Pipeline {
public:
  typedef RegisterResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat::Client getHeartbeat();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HostPortResolver::ResolveParams::Reader {
public:
  typedef ResolveParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasId() const;
  inline  ::capnp::Text::Reader getId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HostPortResolver::ResolveParams::Builder {
public:
  typedef ResolveParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasId();
  inline  ::capnp::Text::Builder getId();
  inline void setId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initId(unsigned int size);
  inline void adoptId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownId();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HostPortResolver::ResolveParams::Pipeline {
public:
  typedef ResolveParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HostPortResolver::ResolveResults::Reader {
public:
  typedef ResolveResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHost() const;
  inline  ::capnp::Text::Reader getHost() const;

  inline  ::uint16_t getPort() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HostPortResolver::ResolveResults::Builder {
public:
  typedef ResolveResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHost();
  inline  ::capnp::Text::Builder getHost();
  inline void setHost( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initHost(unsigned int size);
  inline void adoptHost(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownHost();

  inline  ::uint16_t getPort();
  inline void setPort( ::uint16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HostPortResolver::ResolveResults::Pipeline {
public:
  typedef ResolveResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::uint64_t VatId::Reader::getPublicKey0() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t VatId::Builder::getPublicKey0() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void VatId::Builder::setPublicKey0( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t VatId::Reader::getPublicKey1() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t VatId::Builder::getPublicKey1() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void VatId::Builder::setPublicKey1( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t VatId::Reader::getPublicKey2() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t VatId::Builder::getPublicKey2() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void VatId::Builder::setPublicKey2( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t VatId::Reader::getPublicKey3() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t VatId::Builder::getPublicKey3() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void VatId::Builder::setPublicKey3( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::mas::schema::persistence::Address::Which Address::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}
inline  ::mas::schema::persistence::Address::Which Address::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}

inline bool Address::Reader::isIp6() const {
  return which() == Address::IP6;
}
inline bool Address::Builder::isIp6() {
  return which() == Address::IP6;
}
inline typename Address::Ip6::Reader Address::Reader::getIp6() const {
  KJ_IREQUIRE((which() == Address::IP6),
              "Must check which() before get()ing a union member.");
  return typename Address::Ip6::Reader(_reader);
}
inline typename Address::Ip6::Builder Address::Builder::getIp6() {
  KJ_IREQUIRE((which() == Address::IP6),
              "Must check which() before get()ing a union member.");
  return typename Address::Ip6::Builder(_builder);
}
inline typename Address::Ip6::Builder Address::Builder::initIp6() {
  _builder.setDataField<Address::Which>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, Address::IP6);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  return typename Address::Ip6::Builder(_builder);
}
inline  ::uint16_t Address::Reader::getPort() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Address::Builder::getPort() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}
inline void Address::Builder::setPort( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value);
}

inline bool Address::Reader::isHost() const {
  return which() == Address::HOST;
}
inline bool Address::Builder::isHost() {
  return which() == Address::HOST;
}
inline bool Address::Reader::hasHost() const {
  if (which() != Address::HOST) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Address::Builder::hasHost() {
  if (which() != Address::HOST) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Address::Reader::getHost() const {
  KJ_IREQUIRE((which() == Address::HOST),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Address::Builder::getHost() {
  KJ_IREQUIRE((which() == Address::HOST),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Address::Builder::setHost( ::capnp::Text::Reader value) {
  _builder.setDataField<Address::Which>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, Address::HOST);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Address::Builder::initHost(unsigned int size) {
  _builder.setDataField<Address::Which>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, Address::HOST);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Address::Builder::adoptHost(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<Address::Which>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, Address::HOST);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Address::Builder::disownHost() {
  KJ_IREQUIRE((which() == Address::HOST),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t Address::Ip6::Reader::getLower64() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Address::Ip6::Builder::getLower64() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Address::Ip6::Builder::setLower64( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Address::Ip6::Reader::getUpper64() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Address::Ip6::Builder::getUpper64() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Address::Ip6::Builder::setUpper64( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool VatPath::Reader::hasId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VatPath::Builder::hasId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::persistence::VatId::Reader VatPath::Reader::getId() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatId>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::persistence::VatId::Builder VatPath::Builder::getId() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatId>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::persistence::VatId::Pipeline VatPath::Pipeline::getId() {
  return  ::mas::schema::persistence::VatId::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void VatPath::Builder::setId( ::mas::schema::persistence::VatId::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatId>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::persistence::VatId::Builder VatPath::Builder::initId() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatId>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VatPath::Builder::adoptId(
    ::capnp::Orphan< ::mas::schema::persistence::VatId>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatId>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::persistence::VatId> VatPath::Builder::disownId() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatId>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool VatPath::Reader::hasAddress() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool VatPath::Builder::hasAddress() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::persistence::Address::Reader VatPath::Reader::getAddress() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::Address>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::persistence::Address::Builder VatPath::Builder::getAddress() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::Address>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::persistence::Address::Pipeline VatPath::Pipeline::getAddress() {
  return  ::mas::schema::persistence::Address::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void VatPath::Builder::setAddress( ::mas::schema::persistence::Address::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::Address>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::persistence::Address::Builder VatPath::Builder::initAddress() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::Address>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void VatPath::Builder::adoptAddress(
    ::capnp::Orphan< ::mas::schema::persistence::Address>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::Address>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::persistence::Address> VatPath::Builder::disownAddress() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::Address>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool SturdyRef::Reader::hasVat() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SturdyRef::Builder::hasVat() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::persistence::VatPath::Reader SturdyRef::Reader::getVat() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatPath>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::persistence::VatPath::Builder SturdyRef::Builder::getVat() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatPath>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::persistence::VatPath::Pipeline SturdyRef::Pipeline::getVat() {
  return  ::mas::schema::persistence::VatPath::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void SturdyRef::Builder::setVat( ::mas::schema::persistence::VatPath::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatPath>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::persistence::VatPath::Builder SturdyRef::Builder::initVat() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatPath>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SturdyRef::Builder::adoptVat(
    ::capnp::Orphan< ::mas::schema::persistence::VatPath>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatPath>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::persistence::VatPath> SturdyRef::Builder::disownVat() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatPath>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool SturdyRef::Reader::hasLocalRef() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool SturdyRef::Builder::hasLocalRef() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::persistence::SturdyRef::Token::Reader SturdyRef::Reader::getLocalRef() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Token>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::persistence::SturdyRef::Token::Builder SturdyRef::Builder::getLocalRef() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Token>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::persistence::SturdyRef::Token::Pipeline SturdyRef::Pipeline::getLocalRef() {
  return  ::mas::schema::persistence::SturdyRef::Token::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void SturdyRef::Builder::setLocalRef( ::mas::schema::persistence::SturdyRef::Token::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Token>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::persistence::SturdyRef::Token::Builder SturdyRef::Builder::initLocalRef() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Token>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void SturdyRef::Builder::adoptLocalRef(
    ::capnp::Orphan< ::mas::schema::persistence::SturdyRef::Token>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Token>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef::Token> SturdyRef::Builder::disownLocalRef() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Token>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool SturdyRef::Owner::Reader::hasGuid() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SturdyRef::Owner::Builder::hasGuid() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader SturdyRef::Owner::Reader::getGuid() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder SturdyRef::Owner::Builder::getGuid() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SturdyRef::Owner::Builder::setGuid( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder SturdyRef::Owner::Builder::initGuid(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void SturdyRef::Owner::Builder::adoptGuid(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> SturdyRef::Owner::Builder::disownGuid() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::mas::schema::persistence::SturdyRef::Token::Which SturdyRef::Token::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::mas::schema::persistence::SturdyRef::Token::Which SturdyRef::Token::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool SturdyRef::Token::Reader::isText() const {
  return which() == SturdyRef::Token::TEXT;
}
inline bool SturdyRef::Token::Builder::isText() {
  return which() == SturdyRef::Token::TEXT;
}
inline bool SturdyRef::Token::Reader::hasText() const {
  if (which() != SturdyRef::Token::TEXT) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SturdyRef::Token::Builder::hasText() {
  if (which() != SturdyRef::Token::TEXT) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader SturdyRef::Token::Reader::getText() const {
  KJ_IREQUIRE((which() == SturdyRef::Token::TEXT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder SturdyRef::Token::Builder::getText() {
  KJ_IREQUIRE((which() == SturdyRef::Token::TEXT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SturdyRef::Token::Builder::setText( ::capnp::Text::Reader value) {
  _builder.setDataField<SturdyRef::Token::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, SturdyRef::Token::TEXT);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder SturdyRef::Token::Builder::initText(unsigned int size) {
  _builder.setDataField<SturdyRef::Token::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, SturdyRef::Token::TEXT);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void SturdyRef::Token::Builder::adoptText(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<SturdyRef::Token::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, SturdyRef::Token::TEXT);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> SturdyRef::Token::Builder::disownText() {
  KJ_IREQUIRE((which() == SturdyRef::Token::TEXT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool SturdyRef::Token::Reader::isData() const {
  return which() == SturdyRef::Token::DATA;
}
inline bool SturdyRef::Token::Builder::isData() {
  return which() == SturdyRef::Token::DATA;
}
inline bool SturdyRef::Token::Reader::hasData() const {
  if (which() != SturdyRef::Token::DATA) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SturdyRef::Token::Builder::hasData() {
  if (which() != SturdyRef::Token::DATA) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader SturdyRef::Token::Reader::getData() const {
  KJ_IREQUIRE((which() == SturdyRef::Token::DATA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder SturdyRef::Token::Builder::getData() {
  KJ_IREQUIRE((which() == SturdyRef::Token::DATA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SturdyRef::Token::Builder::setData( ::capnp::Data::Reader value) {
  _builder.setDataField<SturdyRef::Token::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, SturdyRef::Token::DATA);
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder SturdyRef::Token::Builder::initData(unsigned int size) {
  _builder.setDataField<SturdyRef::Token::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, SturdyRef::Token::DATA);
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void SturdyRef::Token::Builder::adoptData(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  _builder.setDataField<SturdyRef::Token::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, SturdyRef::Token::DATA);
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> SturdyRef::Token::Builder::disownData() {
  KJ_IREQUIRE((which() == SturdyRef::Token::DATA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline Persistent::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Persistent::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Persistent::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Persistent::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Persistent::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::persistence::Persistent::Client& Persistent::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::persistence::Persistent::Client& Persistent::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Persistent::SaveParams::Reader::hasSealFor() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Persistent::SaveParams::Builder::hasSealFor() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::persistence::SturdyRef::Owner::Reader Persistent::SaveParams::Reader::getSealFor() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Owner>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::persistence::SturdyRef::Owner::Builder Persistent::SaveParams::Builder::getSealFor() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Owner>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::persistence::SturdyRef::Owner::Pipeline Persistent::SaveParams::Pipeline::getSealFor() {
  return  ::mas::schema::persistence::SturdyRef::Owner::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Persistent::SaveParams::Builder::setSealFor( ::mas::schema::persistence::SturdyRef::Owner::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Owner>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::persistence::SturdyRef::Owner::Builder Persistent::SaveParams::Builder::initSealFor() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Owner>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Persistent::SaveParams::Builder::adoptSealFor(
    ::capnp::Orphan< ::mas::schema::persistence::SturdyRef::Owner>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Owner>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef::Owner> Persistent::SaveParams::Builder::disownSealFor() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Owner>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Persistent::SaveResults::Reader::hasSturdyRef() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Persistent::SaveResults::Builder::hasSturdyRef() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::persistence::SturdyRef::Reader Persistent::SaveResults::Reader::getSturdyRef() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::persistence::SturdyRef::Builder Persistent::SaveResults::Builder::getSturdyRef() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::persistence::SturdyRef::Pipeline Persistent::SaveResults::Pipeline::getSturdyRef() {
  return  ::mas::schema::persistence::SturdyRef::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Persistent::SaveResults::Builder::setSturdyRef( ::mas::schema::persistence::SturdyRef::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::persistence::SturdyRef::Builder Persistent::SaveResults::Builder::initSturdyRef() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Persistent::SaveResults::Builder::adoptSturdyRef(
    ::capnp::Orphan< ::mas::schema::persistence::SturdyRef>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef> Persistent::SaveResults::Builder::disownSturdyRef() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Persistent::SaveResults::Reader::hasUnsaveSR() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Persistent::SaveResults::Builder::hasUnsaveSR() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::persistence::SturdyRef::Reader Persistent::SaveResults::Reader::getUnsaveSR() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::persistence::SturdyRef::Builder Persistent::SaveResults::Builder::getUnsaveSR() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::persistence::SturdyRef::Pipeline Persistent::SaveResults::Pipeline::getUnsaveSR() {
  return  ::mas::schema::persistence::SturdyRef::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Persistent::SaveResults::Builder::setUnsaveSR( ::mas::schema::persistence::SturdyRef::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::persistence::SturdyRef::Builder Persistent::SaveResults::Builder::initUnsaveSR() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Persistent::SaveResults::Builder::adoptUnsaveSR(
    ::capnp::Orphan< ::mas::schema::persistence::SturdyRef>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef> Persistent::SaveResults::Builder::disownUnsaveSR() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline Persistent::ReleaseSturdyRef::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Persistent::ReleaseSturdyRef::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Persistent::ReleaseSturdyRef::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Persistent::ReleaseSturdyRef::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Persistent::ReleaseSturdyRef::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::persistence::Persistent::ReleaseSturdyRef::Client& Persistent::ReleaseSturdyRef::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::persistence::Persistent::ReleaseSturdyRef::Client& Persistent::ReleaseSturdyRef::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Persistent::ReleaseSturdyRef::ReleaseResults::Reader::getSuccess() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Persistent::ReleaseSturdyRef::ReleaseResults::Builder::getSuccess() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Persistent::ReleaseSturdyRef::ReleaseResults::Builder::setSuccess(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

#if !CAPNP_LITE
inline Restorer::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Restorer::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Restorer::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Restorer::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Restorer::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::persistence::Restorer::Client& Restorer::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::persistence::Restorer::Client& Restorer::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Restorer::RestoreParams::Reader::hasLocalRef() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Restorer::RestoreParams::Builder::hasLocalRef() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::persistence::SturdyRef::Token::Reader Restorer::RestoreParams::Reader::getLocalRef() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Token>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::persistence::SturdyRef::Token::Builder Restorer::RestoreParams::Builder::getLocalRef() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Token>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::persistence::SturdyRef::Token::Pipeline Restorer::RestoreParams::Pipeline::getLocalRef() {
  return  ::mas::schema::persistence::SturdyRef::Token::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Restorer::RestoreParams::Builder::setLocalRef( ::mas::schema::persistence::SturdyRef::Token::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Token>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::persistence::SturdyRef::Token::Builder Restorer::RestoreParams::Builder::initLocalRef() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Token>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Restorer::RestoreParams::Builder::adoptLocalRef(
    ::capnp::Orphan< ::mas::schema::persistence::SturdyRef::Token>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Token>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef::Token> Restorer::RestoreParams::Builder::disownLocalRef() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Token>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Restorer::RestoreParams::Reader::hasSealedBy() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Restorer::RestoreParams::Builder::hasSealedBy() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::persistence::SturdyRef::Owner::Reader Restorer::RestoreParams::Reader::getSealedBy() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Owner>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::persistence::SturdyRef::Owner::Builder Restorer::RestoreParams::Builder::getSealedBy() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Owner>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::persistence::SturdyRef::Owner::Pipeline Restorer::RestoreParams::Pipeline::getSealedBy() {
  return  ::mas::schema::persistence::SturdyRef::Owner::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Restorer::RestoreParams::Builder::setSealedBy( ::mas::schema::persistence::SturdyRef::Owner::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Owner>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::persistence::SturdyRef::Owner::Builder Restorer::RestoreParams::Builder::initSealedBy() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Owner>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Restorer::RestoreParams::Builder::adoptSealedBy(
    ::capnp::Orphan< ::mas::schema::persistence::SturdyRef::Owner>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Owner>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef::Owner> Restorer::RestoreParams::Builder::disownSealedBy() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Owner>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Restorer::RestoreResults::Reader::hasCap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Restorer::RestoreResults::Builder::hasCap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnp::Capability::Client Restorer::RestoreResults::Reader::getCap() const {
  return ::capnp::_::PointerHelpers< ::capnp::Capability>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Capability::Client Restorer::RestoreResults::Builder::getCap() {
  return ::capnp::_::PointerHelpers< ::capnp::Capability>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Capability::Client Restorer::RestoreResults::Pipeline::getCap() {
  return  ::capnp::Capability::Client(_typeless.getPointerField(0).asCap());
}
inline void Restorer::RestoreResults::Builder::setCap( ::capnp::Capability::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnp::Capability>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Restorer::RestoreResults::Builder::setCap( ::capnp::Capability::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnp::Capability>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Restorer::RestoreResults::Builder::adoptCap(
    ::capnp::Orphan< ::capnp::Capability>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Capability>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Capability> Restorer::RestoreResults::Builder::disownCap() {
  return ::capnp::_::PointerHelpers< ::capnp::Capability>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
inline HostPortResolver::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline HostPortResolver::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline HostPortResolver::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline HostPortResolver::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline HostPortResolver::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::persistence::HostPortResolver::Client& HostPortResolver::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::persistence::HostPortResolver::Client& HostPortResolver::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
#if !CAPNP_LITE
inline HostPortResolver::Registrar::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline HostPortResolver::Registrar::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline HostPortResolver::Registrar::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline HostPortResolver::Registrar::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline HostPortResolver::Registrar::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::persistence::HostPortResolver::Registrar::Client& HostPortResolver::Registrar::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::persistence::HostPortResolver::Registrar::Client& HostPortResolver::Registrar::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
#if !CAPNP_LITE
inline HostPortResolver::Registrar::Heartbeat::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline HostPortResolver::Registrar::Heartbeat::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline HostPortResolver::Registrar::Heartbeat::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline HostPortResolver::Registrar::Heartbeat::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline HostPortResolver::Registrar::Heartbeat::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat::Client& HostPortResolver::Registrar::Heartbeat::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat::Client& HostPortResolver::Registrar::Heartbeat::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool HostPortResolver::Registrar::RegisterParams::Reader::hasBase64VatId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool HostPortResolver::Registrar::RegisterParams::Builder::hasBase64VatId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader HostPortResolver::Registrar::RegisterParams::Reader::getBase64VatId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder HostPortResolver::Registrar::RegisterParams::Builder::getBase64VatId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void HostPortResolver::Registrar::RegisterParams::Builder::setBase64VatId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder HostPortResolver::Registrar::RegisterParams::Builder::initBase64VatId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void HostPortResolver::Registrar::RegisterParams::Builder::adoptBase64VatId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> HostPortResolver::Registrar::RegisterParams::Builder::disownBase64VatId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool HostPortResolver::Registrar::RegisterParams::Reader::hasHost() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool HostPortResolver::Registrar::RegisterParams::Builder::hasHost() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader HostPortResolver::Registrar::RegisterParams::Reader::getHost() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder HostPortResolver::Registrar::RegisterParams::Builder::getHost() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void HostPortResolver::Registrar::RegisterParams::Builder::setHost( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder HostPortResolver::Registrar::RegisterParams::Builder::initHost(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void HostPortResolver::Registrar::RegisterParams::Builder::adoptHost(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> HostPortResolver::Registrar::RegisterParams::Builder::disownHost() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint16_t HostPortResolver::Registrar::RegisterParams::Reader::getPort() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t HostPortResolver::Registrar::RegisterParams::Builder::getPort() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void HostPortResolver::Registrar::RegisterParams::Builder::setPort( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool HostPortResolver::Registrar::RegisterParams::Reader::hasAlias() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool HostPortResolver::Registrar::RegisterParams::Builder::hasAlias() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader HostPortResolver::Registrar::RegisterParams::Reader::getAlias() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder HostPortResolver::Registrar::RegisterParams::Builder::getAlias() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void HostPortResolver::Registrar::RegisterParams::Builder::setAlias( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder HostPortResolver::Registrar::RegisterParams::Builder::initAlias(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void HostPortResolver::Registrar::RegisterParams::Builder::adoptAlias(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> HostPortResolver::Registrar::RegisterParams::Builder::disownAlias() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool HostPortResolver::Registrar::RegisterResults::Reader::hasHeartbeat() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool HostPortResolver::Registrar::RegisterResults::Builder::hasHeartbeat() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat::Client HostPortResolver::Registrar::RegisterResults::Reader::getHeartbeat() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat::Client HostPortResolver::Registrar::RegisterResults::Builder::getHeartbeat() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat::Client HostPortResolver::Registrar::RegisterResults::Pipeline::getHeartbeat() {
  return  ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat::Client(_typeless.getPointerField(0).asCap());
}
inline void HostPortResolver::Registrar::RegisterResults::Builder::setHeartbeat( ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void HostPortResolver::Registrar::RegisterResults::Builder::setHeartbeat( ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void HostPortResolver::Registrar::RegisterResults::Builder::adoptHeartbeat(
    ::capnp::Orphan< ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat> HostPortResolver::Registrar::RegisterResults::Builder::disownHeartbeat() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::HostPortResolver::Registrar::Heartbeat>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline  ::uint32_t HostPortResolver::Registrar::RegisterResults::Reader::getSecsHeartbeatInterval() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t HostPortResolver::Registrar::RegisterResults::Builder::getSecsHeartbeatInterval() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void HostPortResolver::Registrar::RegisterResults::Builder::setSecsHeartbeatInterval( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool HostPortResolver::ResolveParams::Reader::hasId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool HostPortResolver::ResolveParams::Builder::hasId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader HostPortResolver::ResolveParams::Reader::getId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder HostPortResolver::ResolveParams::Builder::getId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void HostPortResolver::ResolveParams::Builder::setId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder HostPortResolver::ResolveParams::Builder::initId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void HostPortResolver::ResolveParams::Builder::adoptId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> HostPortResolver::ResolveParams::Builder::disownId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool HostPortResolver::ResolveResults::Reader::hasHost() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool HostPortResolver::ResolveResults::Builder::hasHost() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader HostPortResolver::ResolveResults::Reader::getHost() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder HostPortResolver::ResolveResults::Builder::getHost() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void HostPortResolver::ResolveResults::Builder::setHost( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder HostPortResolver::ResolveResults::Builder::initHost(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void HostPortResolver::ResolveResults::Builder::adoptHost(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> HostPortResolver::ResolveResults::Builder::disownHost() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint16_t HostPortResolver::ResolveResults::Reader::getPort() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t HostPortResolver::ResolveResults::Builder::getPort() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void HostPortResolver::ResolveResults::Builder::setPort( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

