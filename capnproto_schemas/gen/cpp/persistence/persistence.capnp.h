// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: persistence.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#if CAPNP_VERSION != 10000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(e10a5d74d58bd18d);
CAPNP_DECLARE_SCHEMA(fb47810671a05b0d);
CAPNP_DECLARE_SCHEMA(8fb25d0428898a69);
CAPNP_DECLARE_SCHEMA(d9eccdf2dbc48087);
CAPNP_DECLARE_SCHEMA(886d68271d83de4d);
CAPNP_DECLARE_SCHEMA(fdd799ed60c87723);
CAPNP_DECLARE_SCHEMA(a42bd461f2a8a3c8);
CAPNP_DECLARE_SCHEMA(cbe679a401315eb8);
CAPNP_DECLARE_SCHEMA(c1a7daa0dc36cb65);
CAPNP_DECLARE_SCHEMA(ffc59cb2d8a71502);
CAPNP_DECLARE_SCHEMA(ef80b08e84155cc2);
CAPNP_DECLARE_SCHEMA(9fb6218427d92e3c);
CAPNP_DECLARE_SCHEMA(8071b2eb61aac3f0);
CAPNP_DECLARE_SCHEMA(da966d1d252e4d25);

}  // namespace schemas
}  // namespace capnp

namespace mas {
namespace schema {
namespace persistence {

struct VatId {
  VatId() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e10a5d74d58bd18d, 4, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Address {
  Address() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    IP6,
    HOST,
  };
  struct Ip6;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fb47810671a05b0d, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Address::Ip6 {
  Ip6() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8fb25d0428898a69, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VatPath {
  VatPath() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d9eccdf2dbc48087, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SturdyRef {
  SturdyRef() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    TRANSIENT,
    STORED,
  };
  struct Owner;
  struct Transient;
  struct Stored;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(886d68271d83de4d, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SturdyRef::Owner {
  Owner() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fdd799ed60c87723, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SturdyRef::Transient {
  Transient() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a42bd461f2a8a3c8, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SturdyRef::Stored {
  Stored() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cbe679a401315eb8, 4, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Persistent {
  Persistent() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct SaveParams;
  struct SaveResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(c1a7daa0dc36cb65)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Persistent::SaveParams {
  SaveParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ffc59cb2d8a71502, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Persistent::SaveResults {
  SaveResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ef80b08e84155cc2, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Restorer {
  Restorer() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct RestoreParams;
  struct RestoreResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(9fb6218427d92e3c)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Restorer::RestoreParams {
  RestoreParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8071b2eb61aac3f0, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Restorer::RestoreResults {
  RestoreResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(da966d1d252e4d25, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class VatId::Reader {
public:
  typedef VatId Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getPublicKey0() const;

  inline  ::uint64_t getPublicKey1() const;

  inline  ::uint64_t getPublicKey2() const;

  inline  ::uint64_t getPublicKey3() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VatId::Builder {
public:
  typedef VatId Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getPublicKey0();
  inline void setPublicKey0( ::uint64_t value);

  inline  ::uint64_t getPublicKey1();
  inline void setPublicKey1( ::uint64_t value);

  inline  ::uint64_t getPublicKey2();
  inline void setPublicKey2( ::uint64_t value);

  inline  ::uint64_t getPublicKey3();
  inline void setPublicKey3( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VatId::Pipeline {
public:
  typedef VatId Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Address::Reader {
public:
  typedef Address Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isIp6() const;
  inline typename Ip6::Reader getIp6() const;

  inline  ::uint16_t getPort() const;

  inline bool isHost() const;
  inline bool hasHost() const;
  inline  ::capnp::Text::Reader getHost() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Address::Builder {
public:
  typedef Address Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isIp6();
  inline typename Ip6::Builder getIp6();
  inline typename Ip6::Builder initIp6();

  inline  ::uint16_t getPort();
  inline void setPort( ::uint16_t value);

  inline bool isHost();
  inline bool hasHost();
  inline  ::capnp::Text::Builder getHost();
  inline void setHost( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initHost(unsigned int size);
  inline void adoptHost(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownHost();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Address::Pipeline {
public:
  typedef Address Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Address::Ip6::Reader {
public:
  typedef Ip6 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLower64() const;

  inline  ::uint64_t getUpper64() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Address::Ip6::Builder {
public:
  typedef Ip6 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLower64();
  inline void setLower64( ::uint64_t value);

  inline  ::uint64_t getUpper64();
  inline void setUpper64( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Address::Ip6::Pipeline {
public:
  typedef Ip6 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VatPath::Reader {
public:
  typedef VatPath Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasId() const;
  inline  ::mas::schema::persistence::VatId::Reader getId() const;

  inline bool hasAddress() const;
  inline  ::mas::schema::persistence::Address::Reader getAddress() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VatPath::Builder {
public:
  typedef VatPath Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasId();
  inline  ::mas::schema::persistence::VatId::Builder getId();
  inline void setId( ::mas::schema::persistence::VatId::Reader value);
  inline  ::mas::schema::persistence::VatId::Builder initId();
  inline void adoptId(::capnp::Orphan< ::mas::schema::persistence::VatId>&& value);
  inline ::capnp::Orphan< ::mas::schema::persistence::VatId> disownId();

  inline bool hasAddress();
  inline  ::mas::schema::persistence::Address::Builder getAddress();
  inline void setAddress( ::mas::schema::persistence::Address::Reader value);
  inline  ::mas::schema::persistence::Address::Builder initAddress();
  inline void adoptAddress(::capnp::Orphan< ::mas::schema::persistence::Address>&& value);
  inline ::capnp::Orphan< ::mas::schema::persistence::Address> disownAddress();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VatPath::Pipeline {
public:
  typedef VatPath Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::persistence::VatId::Pipeline getId();
  inline  ::mas::schema::persistence::Address::Pipeline getAddress();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SturdyRef::Reader {
public:
  typedef SturdyRef Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isTransient() const;
  inline bool hasTransient() const;
  inline  ::mas::schema::persistence::SturdyRef::Transient::Reader getTransient() const;

  inline bool isStored() const;
  inline bool hasStored() const;
  inline  ::mas::schema::persistence::SturdyRef::Stored::Reader getStored() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SturdyRef::Builder {
public:
  typedef SturdyRef Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isTransient();
  inline bool hasTransient();
  inline  ::mas::schema::persistence::SturdyRef::Transient::Builder getTransient();
  inline void setTransient( ::mas::schema::persistence::SturdyRef::Transient::Reader value);
  inline  ::mas::schema::persistence::SturdyRef::Transient::Builder initTransient();
  inline void adoptTransient(::capnp::Orphan< ::mas::schema::persistence::SturdyRef::Transient>&& value);
  inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef::Transient> disownTransient();

  inline bool isStored();
  inline bool hasStored();
  inline  ::mas::schema::persistence::SturdyRef::Stored::Builder getStored();
  inline void setStored( ::mas::schema::persistence::SturdyRef::Stored::Reader value);
  inline  ::mas::schema::persistence::SturdyRef::Stored::Builder initStored();
  inline void adoptStored(::capnp::Orphan< ::mas::schema::persistence::SturdyRef::Stored>&& value);
  inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef::Stored> disownStored();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SturdyRef::Pipeline {
public:
  typedef SturdyRef Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SturdyRef::Owner::Reader {
public:
  typedef Owner Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasGuid() const;
  inline  ::capnp::Text::Reader getGuid() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SturdyRef::Owner::Builder {
public:
  typedef Owner Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasGuid();
  inline  ::capnp::Text::Builder getGuid();
  inline void setGuid( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initGuid(unsigned int size);
  inline void adoptGuid(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownGuid();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SturdyRef::Owner::Pipeline {
public:
  typedef Owner Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SturdyRef::Transient::Reader {
public:
  typedef Transient Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasVat() const;
  inline  ::mas::schema::persistence::VatPath::Reader getVat() const;

  inline bool hasLocalRef() const;
  inline ::capnp::AnyPointer::Reader getLocalRef() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SturdyRef::Transient::Builder {
public:
  typedef Transient Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasVat();
  inline  ::mas::schema::persistence::VatPath::Builder getVat();
  inline void setVat( ::mas::schema::persistence::VatPath::Reader value);
  inline  ::mas::schema::persistence::VatPath::Builder initVat();
  inline void adoptVat(::capnp::Orphan< ::mas::schema::persistence::VatPath>&& value);
  inline ::capnp::Orphan< ::mas::schema::persistence::VatPath> disownVat();

  inline bool hasLocalRef();
  inline ::capnp::AnyPointer::Builder getLocalRef();
  inline ::capnp::AnyPointer::Builder initLocalRef();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SturdyRef::Transient::Pipeline {
public:
  typedef Transient Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::persistence::VatPath::Pipeline getVat();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SturdyRef::Stored::Reader {
public:
  typedef Stored Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getKey0() const;

  inline  ::uint64_t getKey1() const;

  inline  ::uint64_t getKey2() const;

  inline  ::uint64_t getKey3() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SturdyRef::Stored::Builder {
public:
  typedef Stored Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getKey0();
  inline void setKey0( ::uint64_t value);

  inline  ::uint64_t getKey1();
  inline void setKey1( ::uint64_t value);

  inline  ::uint64_t getKey2();
  inline void setKey2( ::uint64_t value);

  inline  ::uint64_t getKey3();
  inline void setKey3( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SturdyRef::Stored::Pipeline {
public:
  typedef Stored Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Persistent::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Persistent Calls;
  typedef Persistent Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::persistence::Persistent::SaveParams,  ::mas::schema::persistence::Persistent::SaveResults> saveRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Persistent::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Persistent Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::persistence::Persistent::SaveParams SaveParams;
  typedef  ::mas::schema::persistence::Persistent::SaveResults SaveResults;
  typedef ::capnp::CallContext<SaveParams, SaveResults> SaveContext;
  virtual ::kj::Promise<void> save(SaveContext context);

  inline  ::mas::schema::persistence::Persistent::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::persistence::Persistent>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Persistent::SaveParams::Reader {
public:
  typedef SaveParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Persistent::SaveParams::Builder {
public:
  typedef SaveParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Persistent::SaveParams::Pipeline {
public:
  typedef SaveParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Persistent::SaveResults::Reader {
public:
  typedef SaveResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasSturdyRef() const;
  inline  ::capnp::Text::Reader getSturdyRef() const;

  inline bool hasUnsaveSR() const;
  inline  ::capnp::Text::Reader getUnsaveSR() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Persistent::SaveResults::Builder {
public:
  typedef SaveResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasSturdyRef();
  inline  ::capnp::Text::Builder getSturdyRef();
  inline void setSturdyRef( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initSturdyRef(unsigned int size);
  inline void adoptSturdyRef(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownSturdyRef();

  inline bool hasUnsaveSR();
  inline  ::capnp::Text::Builder getUnsaveSR();
  inline void setUnsaveSR( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initUnsaveSR(unsigned int size);
  inline void adoptUnsaveSR(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownUnsaveSR();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Persistent::SaveResults::Pipeline {
public:
  typedef SaveResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Restorer::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Restorer Calls;
  typedef Restorer Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::persistence::Restorer::RestoreParams,  ::mas::schema::persistence::Restorer::RestoreResults> restoreRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Restorer::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Restorer Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::persistence::Restorer::RestoreParams RestoreParams;
  typedef  ::mas::schema::persistence::Restorer::RestoreResults RestoreResults;
  typedef ::capnp::CallContext<RestoreParams, RestoreResults> RestoreContext;
  virtual ::kj::Promise<void> restore(RestoreContext context);

  inline  ::mas::schema::persistence::Restorer::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::persistence::Restorer>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Restorer::RestoreParams::Reader {
public:
  typedef RestoreParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasSrToken() const;
  inline  ::capnp::Text::Reader getSrToken() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Restorer::RestoreParams::Builder {
public:
  typedef RestoreParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasSrToken();
  inline  ::capnp::Text::Builder getSrToken();
  inline void setSrToken( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initSrToken(unsigned int size);
  inline void adoptSrToken(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownSrToken();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Restorer::RestoreParams::Pipeline {
public:
  typedef RestoreParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Restorer::RestoreResults::Reader {
public:
  typedef RestoreResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCap() const;
#if !CAPNP_LITE
  inline  ::capnp::Capability::Client getCap() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Restorer::RestoreResults::Builder {
public:
  typedef RestoreResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCap();
#if !CAPNP_LITE
  inline  ::capnp::Capability::Client getCap();
  inline void setCap( ::capnp::Capability::Client&& value);
  inline void setCap( ::capnp::Capability::Client& value);
  inline void adoptCap(::capnp::Orphan< ::capnp::Capability>&& value);
  inline ::capnp::Orphan< ::capnp::Capability> disownCap();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Restorer::RestoreResults::Pipeline {
public:
  typedef RestoreResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::Capability::Client getCap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::uint64_t VatId::Reader::getPublicKey0() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t VatId::Builder::getPublicKey0() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void VatId::Builder::setPublicKey0( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t VatId::Reader::getPublicKey1() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t VatId::Builder::getPublicKey1() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void VatId::Builder::setPublicKey1( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t VatId::Reader::getPublicKey2() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t VatId::Builder::getPublicKey2() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void VatId::Builder::setPublicKey2( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t VatId::Reader::getPublicKey3() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t VatId::Builder::getPublicKey3() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void VatId::Builder::setPublicKey3( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::mas::schema::persistence::Address::Which Address::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}
inline  ::mas::schema::persistence::Address::Which Address::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}

inline bool Address::Reader::isIp6() const {
  return which() == Address::IP6;
}
inline bool Address::Builder::isIp6() {
  return which() == Address::IP6;
}
inline typename Address::Ip6::Reader Address::Reader::getIp6() const {
  KJ_IREQUIRE((which() == Address::IP6),
              "Must check which() before get()ing a union member.");
  return typename Address::Ip6::Reader(_reader);
}
inline typename Address::Ip6::Builder Address::Builder::getIp6() {
  KJ_IREQUIRE((which() == Address::IP6),
              "Must check which() before get()ing a union member.");
  return typename Address::Ip6::Builder(_builder);
}
inline typename Address::Ip6::Builder Address::Builder::initIp6() {
  _builder.setDataField<Address::Which>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, Address::IP6);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  return typename Address::Ip6::Builder(_builder);
}
inline  ::uint16_t Address::Reader::getPort() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Address::Builder::getPort() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}
inline void Address::Builder::setPort( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value);
}

inline bool Address::Reader::isHost() const {
  return which() == Address::HOST;
}
inline bool Address::Builder::isHost() {
  return which() == Address::HOST;
}
inline bool Address::Reader::hasHost() const {
  if (which() != Address::HOST) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Address::Builder::hasHost() {
  if (which() != Address::HOST) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Address::Reader::getHost() const {
  KJ_IREQUIRE((which() == Address::HOST),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Address::Builder::getHost() {
  KJ_IREQUIRE((which() == Address::HOST),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Address::Builder::setHost( ::capnp::Text::Reader value) {
  _builder.setDataField<Address::Which>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, Address::HOST);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Address::Builder::initHost(unsigned int size) {
  _builder.setDataField<Address::Which>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, Address::HOST);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Address::Builder::adoptHost(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<Address::Which>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, Address::HOST);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Address::Builder::disownHost() {
  KJ_IREQUIRE((which() == Address::HOST),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t Address::Ip6::Reader::getLower64() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Address::Ip6::Builder::getLower64() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Address::Ip6::Builder::setLower64( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Address::Ip6::Reader::getUpper64() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Address::Ip6::Builder::getUpper64() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Address::Ip6::Builder::setUpper64( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool VatPath::Reader::hasId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VatPath::Builder::hasId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::persistence::VatId::Reader VatPath::Reader::getId() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatId>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::persistence::VatId::Builder VatPath::Builder::getId() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatId>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::persistence::VatId::Pipeline VatPath::Pipeline::getId() {
  return  ::mas::schema::persistence::VatId::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void VatPath::Builder::setId( ::mas::schema::persistence::VatId::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatId>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::persistence::VatId::Builder VatPath::Builder::initId() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatId>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VatPath::Builder::adoptId(
    ::capnp::Orphan< ::mas::schema::persistence::VatId>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatId>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::persistence::VatId> VatPath::Builder::disownId() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatId>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool VatPath::Reader::hasAddress() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool VatPath::Builder::hasAddress() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::persistence::Address::Reader VatPath::Reader::getAddress() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::Address>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::persistence::Address::Builder VatPath::Builder::getAddress() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::Address>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::persistence::Address::Pipeline VatPath::Pipeline::getAddress() {
  return  ::mas::schema::persistence::Address::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void VatPath::Builder::setAddress( ::mas::schema::persistence::Address::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::Address>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::persistence::Address::Builder VatPath::Builder::initAddress() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::Address>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void VatPath::Builder::adoptAddress(
    ::capnp::Orphan< ::mas::schema::persistence::Address>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::Address>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::persistence::Address> VatPath::Builder::disownAddress() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::Address>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::mas::schema::persistence::SturdyRef::Which SturdyRef::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::mas::schema::persistence::SturdyRef::Which SturdyRef::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool SturdyRef::Reader::isTransient() const {
  return which() == SturdyRef::TRANSIENT;
}
inline bool SturdyRef::Builder::isTransient() {
  return which() == SturdyRef::TRANSIENT;
}
inline bool SturdyRef::Reader::hasTransient() const {
  if (which() != SturdyRef::TRANSIENT) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SturdyRef::Builder::hasTransient() {
  if (which() != SturdyRef::TRANSIENT) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::persistence::SturdyRef::Transient::Reader SturdyRef::Reader::getTransient() const {
  KJ_IREQUIRE((which() == SturdyRef::TRANSIENT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Transient>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::persistence::SturdyRef::Transient::Builder SturdyRef::Builder::getTransient() {
  KJ_IREQUIRE((which() == SturdyRef::TRANSIENT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Transient>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SturdyRef::Builder::setTransient( ::mas::schema::persistence::SturdyRef::Transient::Reader value) {
  _builder.setDataField<SturdyRef::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, SturdyRef::TRANSIENT);
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Transient>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::persistence::SturdyRef::Transient::Builder SturdyRef::Builder::initTransient() {
  _builder.setDataField<SturdyRef::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, SturdyRef::TRANSIENT);
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Transient>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SturdyRef::Builder::adoptTransient(
    ::capnp::Orphan< ::mas::schema::persistence::SturdyRef::Transient>&& value) {
  _builder.setDataField<SturdyRef::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, SturdyRef::TRANSIENT);
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Transient>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef::Transient> SturdyRef::Builder::disownTransient() {
  KJ_IREQUIRE((which() == SturdyRef::TRANSIENT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Transient>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool SturdyRef::Reader::isStored() const {
  return which() == SturdyRef::STORED;
}
inline bool SturdyRef::Builder::isStored() {
  return which() == SturdyRef::STORED;
}
inline bool SturdyRef::Reader::hasStored() const {
  if (which() != SturdyRef::STORED) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SturdyRef::Builder::hasStored() {
  if (which() != SturdyRef::STORED) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::persistence::SturdyRef::Stored::Reader SturdyRef::Reader::getStored() const {
  KJ_IREQUIRE((which() == SturdyRef::STORED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Stored>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::persistence::SturdyRef::Stored::Builder SturdyRef::Builder::getStored() {
  KJ_IREQUIRE((which() == SturdyRef::STORED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Stored>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SturdyRef::Builder::setStored( ::mas::schema::persistence::SturdyRef::Stored::Reader value) {
  _builder.setDataField<SturdyRef::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, SturdyRef::STORED);
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Stored>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::persistence::SturdyRef::Stored::Builder SturdyRef::Builder::initStored() {
  _builder.setDataField<SturdyRef::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, SturdyRef::STORED);
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Stored>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SturdyRef::Builder::adoptStored(
    ::capnp::Orphan< ::mas::schema::persistence::SturdyRef::Stored>&& value) {
  _builder.setDataField<SturdyRef::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, SturdyRef::STORED);
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Stored>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::persistence::SturdyRef::Stored> SturdyRef::Builder::disownStored() {
  KJ_IREQUIRE((which() == SturdyRef::STORED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::SturdyRef::Stored>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool SturdyRef::Owner::Reader::hasGuid() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SturdyRef::Owner::Builder::hasGuid() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader SturdyRef::Owner::Reader::getGuid() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder SturdyRef::Owner::Builder::getGuid() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SturdyRef::Owner::Builder::setGuid( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder SturdyRef::Owner::Builder::initGuid(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void SturdyRef::Owner::Builder::adoptGuid(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> SturdyRef::Owner::Builder::disownGuid() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool SturdyRef::Transient::Reader::hasVat() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SturdyRef::Transient::Builder::hasVat() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::persistence::VatPath::Reader SturdyRef::Transient::Reader::getVat() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatPath>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::persistence::VatPath::Builder SturdyRef::Transient::Builder::getVat() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatPath>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::persistence::VatPath::Pipeline SturdyRef::Transient::Pipeline::getVat() {
  return  ::mas::schema::persistence::VatPath::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void SturdyRef::Transient::Builder::setVat( ::mas::schema::persistence::VatPath::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatPath>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::persistence::VatPath::Builder SturdyRef::Transient::Builder::initVat() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatPath>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SturdyRef::Transient::Builder::adoptVat(
    ::capnp::Orphan< ::mas::schema::persistence::VatPath>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatPath>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::persistence::VatPath> SturdyRef::Transient::Builder::disownVat() {
  return ::capnp::_::PointerHelpers< ::mas::schema::persistence::VatPath>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool SturdyRef::Transient::Reader::hasLocalRef() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool SturdyRef::Transient::Builder::hasLocalRef() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline ::capnp::AnyPointer::Reader SturdyRef::Transient::Reader::getLocalRef() const {
  return ::capnp::AnyPointer::Reader(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder SturdyRef::Transient::Builder::getLocalRef() {
  return ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder SturdyRef::Transient::Builder::initLocalRef() {
  auto result = ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
  result.clear();
  return result;
}

inline  ::uint64_t SturdyRef::Stored::Reader::getKey0() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t SturdyRef::Stored::Builder::getKey0() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void SturdyRef::Stored::Builder::setKey0( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t SturdyRef::Stored::Reader::getKey1() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t SturdyRef::Stored::Builder::getKey1() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void SturdyRef::Stored::Builder::setKey1( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t SturdyRef::Stored::Reader::getKey2() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t SturdyRef::Stored::Builder::getKey2() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void SturdyRef::Stored::Builder::setKey2( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t SturdyRef::Stored::Reader::getKey3() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t SturdyRef::Stored::Builder::getKey3() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void SturdyRef::Stored::Builder::setKey3( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

#if !CAPNP_LITE
inline Persistent::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Persistent::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Persistent::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Persistent::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Persistent::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::persistence::Persistent::Client& Persistent::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::persistence::Persistent::Client& Persistent::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Persistent::SaveResults::Reader::hasSturdyRef() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Persistent::SaveResults::Builder::hasSturdyRef() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Persistent::SaveResults::Reader::getSturdyRef() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Persistent::SaveResults::Builder::getSturdyRef() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Persistent::SaveResults::Builder::setSturdyRef( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Persistent::SaveResults::Builder::initSturdyRef(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Persistent::SaveResults::Builder::adoptSturdyRef(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Persistent::SaveResults::Builder::disownSturdyRef() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Persistent::SaveResults::Reader::hasUnsaveSR() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Persistent::SaveResults::Builder::hasUnsaveSR() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Persistent::SaveResults::Reader::getUnsaveSR() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Persistent::SaveResults::Builder::getUnsaveSR() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Persistent::SaveResults::Builder::setUnsaveSR( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Persistent::SaveResults::Builder::initUnsaveSR(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Persistent::SaveResults::Builder::adoptUnsaveSR(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Persistent::SaveResults::Builder::disownUnsaveSR() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline Restorer::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Restorer::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Restorer::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Restorer::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Restorer::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::persistence::Restorer::Client& Restorer::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::persistence::Restorer::Client& Restorer::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Restorer::RestoreParams::Reader::hasSrToken() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Restorer::RestoreParams::Builder::hasSrToken() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Restorer::RestoreParams::Reader::getSrToken() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Restorer::RestoreParams::Builder::getSrToken() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Restorer::RestoreParams::Builder::setSrToken( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Restorer::RestoreParams::Builder::initSrToken(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Restorer::RestoreParams::Builder::adoptSrToken(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Restorer::RestoreParams::Builder::disownSrToken() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Restorer::RestoreResults::Reader::hasCap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Restorer::RestoreResults::Builder::hasCap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnp::Capability::Client Restorer::RestoreResults::Reader::getCap() const {
  return ::capnp::_::PointerHelpers< ::capnp::Capability>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Capability::Client Restorer::RestoreResults::Builder::getCap() {
  return ::capnp::_::PointerHelpers< ::capnp::Capability>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Capability::Client Restorer::RestoreResults::Pipeline::getCap() {
  return  ::capnp::Capability::Client(_typeless.getPointerField(0).asCap());
}
inline void Restorer::RestoreResults::Builder::setCap( ::capnp::Capability::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnp::Capability>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Restorer::RestoreResults::Builder::setCap( ::capnp::Capability::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnp::Capability>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Restorer::RestoreResults::Builder::adoptCap(
    ::capnp::Orphan< ::capnp::Capability>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Capability>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Capability> Restorer::RestoreResults::Builder::disownCap() {
  return ::capnp::_::PointerHelpers< ::capnp::Capability>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

