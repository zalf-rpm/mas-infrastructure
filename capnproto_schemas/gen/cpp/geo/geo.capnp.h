// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: geo.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 10000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(e529b4deb322ece8);
enum class CoordType_e529b4deb322ece8: uint16_t {
  GK,
  UTM,
  LATLON,
};
CAPNP_DECLARE_ENUM(CoordType, e529b4deb322ece8);
CAPNP_DECLARE_SCHEMA(b79427a74eb97fc0);
CAPNP_DECLARE_SCHEMA(cdaf64c4789f2b7d);
CAPNP_DECLARE_SCHEMA(c8fb53981e470885);
CAPNP_DECLARE_SCHEMA(cc67dee69497e2f3);
CAPNP_DECLARE_SCHEMA(958c02356c8797e1);
CAPNP_DECLARE_SCHEMA(e4afdddddec2511d);
CAPNP_DECLARE_SCHEMA(f5b9e8307038ad86);
CAPNP_DECLARE_SCHEMA(eb1acd255e40f049);
CAPNP_DECLARE_SCHEMA(ecf1fc3039cc8ffb);
CAPNP_DECLARE_SCHEMA(97ff7d61786091ae);
CAPNP_DECLARE_SCHEMA(c88fb91c1e6986e2);
CAPNP_DECLARE_SCHEMA(b0c6993e13e314ad);
CAPNP_DECLARE_SCHEMA(b8f6a6192a7359f8);
CAPNP_DECLARE_SCHEMA(b952dbe83866da4a);

}  // namespace schemas
}  // namespace capnp

namespace mas {
namespace schema {
namespace geo {

typedef ::capnp::schemas::CoordType_e529b4deb322ece8 CoordType;

struct EPSG {
  EPSG() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  static constexpr  ::uint32_t WGS84 = 4326u;
  static constexpr  ::uint32_t UTM21_S = 32721u;
  static constexpr  ::uint32_t UTM32_N = 25832u;
  static constexpr  ::uint32_t GK5 = 31469u;
  static constexpr  ::uint32_t GK4 = 31468u;
  static constexpr  ::uint32_t GK3 = 31467u;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b79427a74eb97fc0, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct UTMCoord {
  UTMCoord() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(eb1acd255e40f049, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LatLonCoord {
  LatLonCoord() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ecf1fc3039cc8ffb, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GKCoord {
  GKCoord() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(97ff7d61786091ae, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Point2D {
  Point2D() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c88fb91c1e6986e2, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RowCol {
  RowCol() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b0c6993e13e314ad, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Coord {
  Coord() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    GK,
    LATLON,
    UTM,
    P2_D,
    ROWCOL,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b8f6a6192a7359f8, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

template <typename CoordinateType = ::capnp::AnyPointer>
struct RectBounds {
  RectBounds() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b952dbe83866da4a, 0, 2)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, CoordinateType>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class EPSG::Reader {
public:
  typedef EPSG Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class EPSG::Builder {
public:
  typedef EPSG Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class EPSG::Pipeline {
public:
  typedef EPSG Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class UTMCoord::Reader {
public:
  typedef UTMCoord Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getZone() const;

  inline bool hasLatitudeBand() const;
  inline  ::capnp::Text::Reader getLatitudeBand() const;

  inline double getR() const;

  inline double getH() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class UTMCoord::Builder {
public:
  typedef UTMCoord Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getZone();
  inline void setZone( ::uint8_t value);

  inline bool hasLatitudeBand();
  inline  ::capnp::Text::Builder getLatitudeBand();
  inline void setLatitudeBand( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initLatitudeBand(unsigned int size);
  inline void adoptLatitudeBand(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownLatitudeBand();

  inline double getR();
  inline void setR(double value);

  inline double getH();
  inline void setH(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class UTMCoord::Pipeline {
public:
  typedef UTMCoord Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LatLonCoord::Reader {
public:
  typedef LatLonCoord Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getLat() const;

  inline double getLon() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LatLonCoord::Builder {
public:
  typedef LatLonCoord Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getLat();
  inline void setLat(double value);

  inline double getLon();
  inline void setLon(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LatLonCoord::Pipeline {
public:
  typedef LatLonCoord Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GKCoord::Reader {
public:
  typedef GKCoord Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getMeridianNo() const;

  inline double getR() const;

  inline double getH() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GKCoord::Builder {
public:
  typedef GKCoord Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getMeridianNo();
  inline void setMeridianNo( ::uint8_t value);

  inline double getR();
  inline void setR(double value);

  inline double getH();
  inline void setH(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GKCoord::Pipeline {
public:
  typedef GKCoord Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Point2D::Reader {
public:
  typedef Point2D Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getX() const;

  inline double getY() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Point2D::Builder {
public:
  typedef Point2D Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getX();
  inline void setX(double value);

  inline double getY();
  inline void setY(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Point2D::Pipeline {
public:
  typedef Point2D Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RowCol::Reader {
public:
  typedef RowCol Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getRow() const;

  inline  ::uint64_t getCol() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RowCol::Builder {
public:
  typedef RowCol Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getRow();
  inline void setRow( ::uint64_t value);

  inline  ::uint64_t getCol();
  inline void setCol( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RowCol::Pipeline {
public:
  typedef RowCol Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Coord::Reader {
public:
  typedef Coord Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isGk() const;
  inline bool hasGk() const;
  inline  ::mas::schema::geo::GKCoord::Reader getGk() const;

  inline bool isLatlon() const;
  inline bool hasLatlon() const;
  inline  ::mas::schema::geo::LatLonCoord::Reader getLatlon() const;

  inline bool isUtm() const;
  inline bool hasUtm() const;
  inline  ::mas::schema::geo::UTMCoord::Reader getUtm() const;

  inline bool isP2D() const;
  inline bool hasP2D() const;
  inline  ::mas::schema::geo::Point2D::Reader getP2D() const;

  inline bool isRowcol() const;
  inline bool hasRowcol() const;
  inline  ::mas::schema::geo::RowCol::Reader getRowcol() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Coord::Builder {
public:
  typedef Coord Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isGk();
  inline bool hasGk();
  inline  ::mas::schema::geo::GKCoord::Builder getGk();
  inline void setGk( ::mas::schema::geo::GKCoord::Reader value);
  inline  ::mas::schema::geo::GKCoord::Builder initGk();
  inline void adoptGk(::capnp::Orphan< ::mas::schema::geo::GKCoord>&& value);
  inline ::capnp::Orphan< ::mas::schema::geo::GKCoord> disownGk();

  inline bool isLatlon();
  inline bool hasLatlon();
  inline  ::mas::schema::geo::LatLonCoord::Builder getLatlon();
  inline void setLatlon( ::mas::schema::geo::LatLonCoord::Reader value);
  inline  ::mas::schema::geo::LatLonCoord::Builder initLatlon();
  inline void adoptLatlon(::capnp::Orphan< ::mas::schema::geo::LatLonCoord>&& value);
  inline ::capnp::Orphan< ::mas::schema::geo::LatLonCoord> disownLatlon();

  inline bool isUtm();
  inline bool hasUtm();
  inline  ::mas::schema::geo::UTMCoord::Builder getUtm();
  inline void setUtm( ::mas::schema::geo::UTMCoord::Reader value);
  inline  ::mas::schema::geo::UTMCoord::Builder initUtm();
  inline void adoptUtm(::capnp::Orphan< ::mas::schema::geo::UTMCoord>&& value);
  inline ::capnp::Orphan< ::mas::schema::geo::UTMCoord> disownUtm();

  inline bool isP2D();
  inline bool hasP2D();
  inline  ::mas::schema::geo::Point2D::Builder getP2D();
  inline void setP2D( ::mas::schema::geo::Point2D::Reader value);
  inline  ::mas::schema::geo::Point2D::Builder initP2D();
  inline void adoptP2D(::capnp::Orphan< ::mas::schema::geo::Point2D>&& value);
  inline ::capnp::Orphan< ::mas::schema::geo::Point2D> disownP2D();

  inline bool isRowcol();
  inline bool hasRowcol();
  inline  ::mas::schema::geo::RowCol::Builder getRowcol();
  inline void setRowcol( ::mas::schema::geo::RowCol::Reader value);
  inline  ::mas::schema::geo::RowCol::Builder initRowcol();
  inline void adoptRowcol(::capnp::Orphan< ::mas::schema::geo::RowCol>&& value);
  inline ::capnp::Orphan< ::mas::schema::geo::RowCol> disownRowcol();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Coord::Pipeline {
public:
  typedef Coord Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename CoordinateType>
class RectBounds<CoordinateType>::Reader {
public:
  typedef RectBounds Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename CoordinateType2 = ::capnp::AnyPointer>
  typename RectBounds<CoordinateType2>::Reader asGeneric() {
    return typename RectBounds<CoordinateType2>::Reader(_reader);
  }

  inline bool hasTl() const;
  inline  ::capnp::ReaderFor<CoordinateType> getTl() const;

  inline bool hasBr() const;
  inline  ::capnp::ReaderFor<CoordinateType> getBr() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename CoordinateType>
class RectBounds<CoordinateType>::Builder {
public:
  typedef RectBounds Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename CoordinateType2 = ::capnp::AnyPointer>
  typename RectBounds<CoordinateType2>::Builder asGeneric() {
    return typename RectBounds<CoordinateType2>::Builder(_builder);
  }

  inline bool hasTl();
  inline  ::capnp::BuilderFor<CoordinateType> getTl();
  inline void setTl( ::capnp::ReaderFor<CoordinateType> value);
  inline  ::capnp::BuilderFor<CoordinateType> initTl();
  inline  ::capnp::BuilderFor<CoordinateType> initTl(unsigned int size);
  inline void adoptTl(::capnp::Orphan<CoordinateType>&& value);
  inline ::capnp::Orphan<CoordinateType> disownTl();

  inline bool hasBr();
  inline  ::capnp::BuilderFor<CoordinateType> getBr();
  inline void setBr( ::capnp::ReaderFor<CoordinateType> value);
  inline  ::capnp::BuilderFor<CoordinateType> initBr();
  inline  ::capnp::BuilderFor<CoordinateType> initBr(unsigned int size);
  inline void adoptBr(::capnp::Orphan<CoordinateType>&& value);
  inline ::capnp::Orphan<CoordinateType> disownBr();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename CoordinateType>
class RectBounds<CoordinateType>::Pipeline {
public:
  typedef RectBounds Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<CoordinateType> getTl();
  inline  ::capnp::PipelineFor<CoordinateType> getBr();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::uint8_t UTMCoord::Reader::getZone() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t UTMCoord::Builder::getZone() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void UTMCoord::Builder::setZone( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool UTMCoord::Reader::hasLatitudeBand() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool UTMCoord::Builder::hasLatitudeBand() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader UTMCoord::Reader::getLatitudeBand() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder UTMCoord::Builder::getLatitudeBand() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void UTMCoord::Builder::setLatitudeBand( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder UTMCoord::Builder::initLatitudeBand(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void UTMCoord::Builder::adoptLatitudeBand(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> UTMCoord::Builder::disownLatitudeBand() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double UTMCoord::Reader::getR() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double UTMCoord::Builder::getR() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void UTMCoord::Builder::setR(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline double UTMCoord::Reader::getH() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline double UTMCoord::Builder::getH() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void UTMCoord::Builder::setH(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline double LatLonCoord::Reader::getLat() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double LatLonCoord::Builder::getLat() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void LatLonCoord::Builder::setLat(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double LatLonCoord::Reader::getLon() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double LatLonCoord::Builder::getLon() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void LatLonCoord::Builder::setLon(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t GKCoord::Reader::getMeridianNo() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t GKCoord::Builder::getMeridianNo() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void GKCoord::Builder::setMeridianNo( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double GKCoord::Reader::getR() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double GKCoord::Builder::getR() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void GKCoord::Builder::setR(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline double GKCoord::Reader::getH() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline double GKCoord::Builder::getH() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void GKCoord::Builder::setH(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline double Point2D::Reader::getX() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Point2D::Builder::getX() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Point2D::Builder::setX(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Point2D::Reader::getY() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Point2D::Builder::getY() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Point2D::Builder::setY(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t RowCol::Reader::getRow() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t RowCol::Builder::getRow() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void RowCol::Builder::setRow( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t RowCol::Reader::getCol() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t RowCol::Builder::getCol() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void RowCol::Builder::setCol( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::mas::schema::geo::Coord::Which Coord::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::mas::schema::geo::Coord::Which Coord::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Coord::Reader::isGk() const {
  return which() == Coord::GK;
}
inline bool Coord::Builder::isGk() {
  return which() == Coord::GK;
}
inline bool Coord::Reader::hasGk() const {
  if (which() != Coord::GK) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Coord::Builder::hasGk() {
  if (which() != Coord::GK) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::geo::GKCoord::Reader Coord::Reader::getGk() const {
  KJ_IREQUIRE((which() == Coord::GK),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::GKCoord>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::geo::GKCoord::Builder Coord::Builder::getGk() {
  KJ_IREQUIRE((which() == Coord::GK),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::GKCoord>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Coord::Builder::setGk( ::mas::schema::geo::GKCoord::Reader value) {
  _builder.setDataField<Coord::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Coord::GK);
  ::capnp::_::PointerHelpers< ::mas::schema::geo::GKCoord>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::geo::GKCoord::Builder Coord::Builder::initGk() {
  _builder.setDataField<Coord::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Coord::GK);
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::GKCoord>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Coord::Builder::adoptGk(
    ::capnp::Orphan< ::mas::schema::geo::GKCoord>&& value) {
  _builder.setDataField<Coord::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Coord::GK);
  ::capnp::_::PointerHelpers< ::mas::schema::geo::GKCoord>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::geo::GKCoord> Coord::Builder::disownGk() {
  KJ_IREQUIRE((which() == Coord::GK),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::GKCoord>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Coord::Reader::isLatlon() const {
  return which() == Coord::LATLON;
}
inline bool Coord::Builder::isLatlon() {
  return which() == Coord::LATLON;
}
inline bool Coord::Reader::hasLatlon() const {
  if (which() != Coord::LATLON) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Coord::Builder::hasLatlon() {
  if (which() != Coord::LATLON) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::geo::LatLonCoord::Reader Coord::Reader::getLatlon() const {
  KJ_IREQUIRE((which() == Coord::LATLON),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::geo::LatLonCoord::Builder Coord::Builder::getLatlon() {
  KJ_IREQUIRE((which() == Coord::LATLON),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Coord::Builder::setLatlon( ::mas::schema::geo::LatLonCoord::Reader value) {
  _builder.setDataField<Coord::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Coord::LATLON);
  ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::geo::LatLonCoord::Builder Coord::Builder::initLatlon() {
  _builder.setDataField<Coord::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Coord::LATLON);
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Coord::Builder::adoptLatlon(
    ::capnp::Orphan< ::mas::schema::geo::LatLonCoord>&& value) {
  _builder.setDataField<Coord::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Coord::LATLON);
  ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::geo::LatLonCoord> Coord::Builder::disownLatlon() {
  KJ_IREQUIRE((which() == Coord::LATLON),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Coord::Reader::isUtm() const {
  return which() == Coord::UTM;
}
inline bool Coord::Builder::isUtm() {
  return which() == Coord::UTM;
}
inline bool Coord::Reader::hasUtm() const {
  if (which() != Coord::UTM) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Coord::Builder::hasUtm() {
  if (which() != Coord::UTM) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::geo::UTMCoord::Reader Coord::Reader::getUtm() const {
  KJ_IREQUIRE((which() == Coord::UTM),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::UTMCoord>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::geo::UTMCoord::Builder Coord::Builder::getUtm() {
  KJ_IREQUIRE((which() == Coord::UTM),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::UTMCoord>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Coord::Builder::setUtm( ::mas::schema::geo::UTMCoord::Reader value) {
  _builder.setDataField<Coord::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Coord::UTM);
  ::capnp::_::PointerHelpers< ::mas::schema::geo::UTMCoord>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::geo::UTMCoord::Builder Coord::Builder::initUtm() {
  _builder.setDataField<Coord::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Coord::UTM);
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::UTMCoord>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Coord::Builder::adoptUtm(
    ::capnp::Orphan< ::mas::schema::geo::UTMCoord>&& value) {
  _builder.setDataField<Coord::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Coord::UTM);
  ::capnp::_::PointerHelpers< ::mas::schema::geo::UTMCoord>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::geo::UTMCoord> Coord::Builder::disownUtm() {
  KJ_IREQUIRE((which() == Coord::UTM),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::UTMCoord>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Coord::Reader::isP2D() const {
  return which() == Coord::P2_D;
}
inline bool Coord::Builder::isP2D() {
  return which() == Coord::P2_D;
}
inline bool Coord::Reader::hasP2D() const {
  if (which() != Coord::P2_D) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Coord::Builder::hasP2D() {
  if (which() != Coord::P2_D) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::geo::Point2D::Reader Coord::Reader::getP2D() const {
  KJ_IREQUIRE((which() == Coord::P2_D),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::Point2D>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::geo::Point2D::Builder Coord::Builder::getP2D() {
  KJ_IREQUIRE((which() == Coord::P2_D),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::Point2D>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Coord::Builder::setP2D( ::mas::schema::geo::Point2D::Reader value) {
  _builder.setDataField<Coord::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Coord::P2_D);
  ::capnp::_::PointerHelpers< ::mas::schema::geo::Point2D>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::geo::Point2D::Builder Coord::Builder::initP2D() {
  _builder.setDataField<Coord::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Coord::P2_D);
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::Point2D>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Coord::Builder::adoptP2D(
    ::capnp::Orphan< ::mas::schema::geo::Point2D>&& value) {
  _builder.setDataField<Coord::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Coord::P2_D);
  ::capnp::_::PointerHelpers< ::mas::schema::geo::Point2D>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::geo::Point2D> Coord::Builder::disownP2D() {
  KJ_IREQUIRE((which() == Coord::P2_D),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::Point2D>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Coord::Reader::isRowcol() const {
  return which() == Coord::ROWCOL;
}
inline bool Coord::Builder::isRowcol() {
  return which() == Coord::ROWCOL;
}
inline bool Coord::Reader::hasRowcol() const {
  if (which() != Coord::ROWCOL) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Coord::Builder::hasRowcol() {
  if (which() != Coord::ROWCOL) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::geo::RowCol::Reader Coord::Reader::getRowcol() const {
  KJ_IREQUIRE((which() == Coord::ROWCOL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::RowCol>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::geo::RowCol::Builder Coord::Builder::getRowcol() {
  KJ_IREQUIRE((which() == Coord::ROWCOL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::RowCol>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Coord::Builder::setRowcol( ::mas::schema::geo::RowCol::Reader value) {
  _builder.setDataField<Coord::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Coord::ROWCOL);
  ::capnp::_::PointerHelpers< ::mas::schema::geo::RowCol>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::geo::RowCol::Builder Coord::Builder::initRowcol() {
  _builder.setDataField<Coord::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Coord::ROWCOL);
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::RowCol>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Coord::Builder::adoptRowcol(
    ::capnp::Orphan< ::mas::schema::geo::RowCol>&& value) {
  _builder.setDataField<Coord::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Coord::ROWCOL);
  ::capnp::_::PointerHelpers< ::mas::schema::geo::RowCol>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::geo::RowCol> Coord::Builder::disownRowcol() {
  KJ_IREQUIRE((which() == Coord::ROWCOL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::RowCol>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename CoordinateType>
inline bool RectBounds<CoordinateType>::Reader::hasTl() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename CoordinateType>
inline bool RectBounds<CoordinateType>::Builder::hasTl() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename CoordinateType>
inline  ::capnp::ReaderFor<CoordinateType> RectBounds<CoordinateType>::Reader::getTl() const {
  return ::capnp::_::PointerHelpers<CoordinateType>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename CoordinateType>
inline  ::capnp::BuilderFor<CoordinateType> RectBounds<CoordinateType>::Builder::getTl() {
  return ::capnp::_::PointerHelpers<CoordinateType>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename CoordinateType>
inline  ::capnp::PipelineFor<CoordinateType> RectBounds<CoordinateType>::Pipeline::getTl() {
  return  ::capnp::PipelineFor<CoordinateType>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename CoordinateType>
inline void RectBounds<CoordinateType>::Builder::setTl( ::capnp::ReaderFor<CoordinateType> value) {
  ::capnp::_::PointerHelpers<CoordinateType>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename CoordinateType>
inline  ::capnp::BuilderFor<CoordinateType> RectBounds<CoordinateType>::Builder::initTl() {
  return ::capnp::_::PointerHelpers<CoordinateType>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename CoordinateType>
inline  ::capnp::BuilderFor<CoordinateType> RectBounds<CoordinateType>::Builder::initTl(unsigned int size) {
  return ::capnp::_::PointerHelpers<CoordinateType>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename CoordinateType>
inline void RectBounds<CoordinateType>::Builder::adoptTl(
    ::capnp::Orphan<CoordinateType>&& value) {
  ::capnp::_::PointerHelpers<CoordinateType>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename CoordinateType>
inline ::capnp::Orphan<CoordinateType> RectBounds<CoordinateType>::Builder::disownTl() {
  return ::capnp::_::PointerHelpers<CoordinateType>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename CoordinateType>
inline bool RectBounds<CoordinateType>::Reader::hasBr() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename CoordinateType>
inline bool RectBounds<CoordinateType>::Builder::hasBr() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename CoordinateType>
inline  ::capnp::ReaderFor<CoordinateType> RectBounds<CoordinateType>::Reader::getBr() const {
  return ::capnp::_::PointerHelpers<CoordinateType>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename CoordinateType>
inline  ::capnp::BuilderFor<CoordinateType> RectBounds<CoordinateType>::Builder::getBr() {
  return ::capnp::_::PointerHelpers<CoordinateType>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename CoordinateType>
inline  ::capnp::PipelineFor<CoordinateType> RectBounds<CoordinateType>::Pipeline::getBr() {
  return  ::capnp::PipelineFor<CoordinateType>(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
template <typename CoordinateType>
inline void RectBounds<CoordinateType>::Builder::setBr( ::capnp::ReaderFor<CoordinateType> value) {
  ::capnp::_::PointerHelpers<CoordinateType>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename CoordinateType>
inline  ::capnp::BuilderFor<CoordinateType> RectBounds<CoordinateType>::Builder::initBr() {
  return ::capnp::_::PointerHelpers<CoordinateType>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename CoordinateType>
inline  ::capnp::BuilderFor<CoordinateType> RectBounds<CoordinateType>::Builder::initBr(unsigned int size) {
  return ::capnp::_::PointerHelpers<CoordinateType>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
template <typename CoordinateType>
inline void RectBounds<CoordinateType>::Builder::adoptBr(
    ::capnp::Orphan<CoordinateType>&& value) {
  ::capnp::_::PointerHelpers<CoordinateType>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename CoordinateType>
inline ::capnp::Orphan<CoordinateType> RectBounds<CoordinateType>::Builder::disownBr() {
  return ::capnp::_::PointerHelpers<CoordinateType>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

// RectBounds<CoordinateType>
template <typename CoordinateType>
constexpr uint16_t RectBounds<CoordinateType>::_capnpPrivate::dataWordSize;
template <typename CoordinateType>
constexpr uint16_t RectBounds<CoordinateType>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename CoordinateType>
constexpr ::capnp::Kind RectBounds<CoordinateType>::_capnpPrivate::kind;
template <typename CoordinateType>
constexpr ::capnp::_::RawSchema const* RectBounds<CoordinateType>::_capnpPrivate::schema;
template <typename CoordinateType>
const ::capnp::_::RawBrandedSchema::Scope RectBounds<CoordinateType>::_capnpPrivate::brandScopes[] = {
  { 0xb952dbe83866da4a, brandBindings + 0, 1, false},
};
template <typename CoordinateType>
const ::capnp::_::RawBrandedSchema::Binding RectBounds<CoordinateType>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<CoordinateType>(),
};
template <typename CoordinateType>
const ::capnp::_::RawBrandedSchema RectBounds<CoordinateType>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_b952dbe83866da4a, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

