// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: model.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#if CAPNP_VERSION != 10000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "climate.capnp.h"
#include "common.capnp.h"
#include "management.capnp.h"
#include "persistence.capnp.h"
#include "service.capnp.h"
#include "soil.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(851d47c6ccdecf08);
CAPNP_DECLARE_SCHEMA(a6be2e805ea10a68);
CAPNP_DECLARE_SCHEMA(bd33bb6d8cbd9ed2);
enum class Type_bd33bb6d8cbd9ed2: uint16_t {
  MIN,
  MAX,
  SD,
  AVG,
  MEDIAN,
};
CAPNP_DECLARE_ENUM(Type, bd33bb6d8cbd9ed2);
CAPNP_DECLARE_SCHEMA(8f86b66260d02d1d);
CAPNP_DECLARE_SCHEMA(dfcfeb783c4948fc);
CAPNP_DECLARE_SCHEMA(df787fd9d51f235b);
CAPNP_DECLARE_SCHEMA(cc39e47cdead74c4);
CAPNP_DECLARE_SCHEMA(aa9d146226037822);
CAPNP_DECLARE_SCHEMA(e22282cb3449bb4a);
CAPNP_DECLARE_SCHEMA(b7fc866ef1127f7c);
CAPNP_DECLARE_SCHEMA(a5feedafa5ec5c4a);
CAPNP_DECLARE_SCHEMA(811895634b6bd959);
CAPNP_DECLARE_SCHEMA(a931ae5cae90ece0);
CAPNP_DECLARE_SCHEMA(87cbebfc1164a24a);
CAPNP_DECLARE_SCHEMA(c727892bd5c66f88);
CAPNP_DECLARE_SCHEMA(82136633e6b6d8ae);
CAPNP_DECLARE_SCHEMA(e91cc3866fdea82a);
CAPNP_DECLARE_SCHEMA(d10259a623f95bb4);
CAPNP_DECLARE_SCHEMA(df50acfa56a9674e);
CAPNP_DECLARE_SCHEMA(ce552eef738a45ea);
CAPNP_DECLARE_SCHEMA(bf49e08cc9412aaf);
CAPNP_DECLARE_SCHEMA(9ee4515395213845);
CAPNP_DECLARE_SCHEMA(f013eda158070488);
CAPNP_DECLARE_SCHEMA(d9fa9ece71d1db50);
CAPNP_DECLARE_SCHEMA(af9a1cb72ba68156);

}  // namespace schemas
}  // namespace capnp

namespace mas {
namespace schema {
namespace model {

struct XYResult {
  XYResult() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(851d47c6ccdecf08, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Stat {
  Stat() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::Type_bd33bb6d8cbd9ed2 Type;


  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a6be2e805ea10a68, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct XYPlusResult {
  XYPlusResult() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8f86b66260d02d1d, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ClimateInstance {
  ClimateInstance() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct RunParams;
  struct RunResults;
  struct RunSetParams;
  struct RunSetResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(dfcfeb783c4948fc)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct ClimateInstance::RunParams {
  RunParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(df787fd9d51f235b, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ClimateInstance::RunResults {
  RunResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cc39e47cdead74c4, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ClimateInstance::RunSetParams {
  RunSetParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(aa9d146226037822, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ClimateInstance::RunSetResults {
  RunSetResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e22282cb3449bb4a, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

template <typename RestInput = ::capnp::AnyPointer>
struct Env {
  Env() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b7fc866ef1127f7c, 0, 4)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, RestInput>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename RestInput = ::capnp::AnyPointer, typename Output = ::capnp::AnyPointer>
struct EnvInstance {
  EnvInstance() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct RunParams;
  struct RunResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(a5feedafa5ec5c4a)
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, RestInput, Output>::brand(); }
  };
  #endif  // !CAPNP_LITE
};

template <typename RestInput, typename Output>
struct EnvInstance<RestInput, Output>::RunParams {
  RunParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(811895634b6bd959, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, RestInput, Output>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename RestInput, typename Output>
struct EnvInstance<RestInput, Output>::RunResults {
  RunResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a931ae5cae90ece0, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, RestInput, Output>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename RestInput = ::capnp::AnyPointer, typename Output = ::capnp::AnyPointer>
struct EnvInstanceProxy {
  EnvInstanceProxy() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct Unregister;
  struct RegisterEnvInstanceParams;
  struct RegisterEnvInstanceResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(87cbebfc1164a24a)
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, RestInput, Output>::brand(); }
  };
  #endif  // !CAPNP_LITE
};

template <typename RestInput, typename Output>
struct EnvInstanceProxy<RestInput, Output>::Unregister {
  Unregister() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct UnregisterParams;
  struct UnregisterResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(c727892bd5c66f88)
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, RestInput, Output>::brand(); }
  };
  #endif  // !CAPNP_LITE
};

template <typename RestInput, typename Output>
struct EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterParams {
  UnregisterParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(82136633e6b6d8ae, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, RestInput, Output>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename RestInput, typename Output>
struct EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterResults {
  UnregisterResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e91cc3866fdea82a, 1, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, RestInput, Output>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename RestInput, typename Output>
struct EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams {
  RegisterEnvInstanceParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d10259a623f95bb4, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, RestInput, Output>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename RestInput, typename Output>
struct EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults {
  RegisterEnvInstanceResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(df50acfa56a9674e, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, RestInput, Output>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

struct InstanceFactory {
  InstanceFactory() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct ModelInfoParams;
  struct NewInstanceParams;
  struct NewInstanceResults;
  struct NewInstancesParams;
  struct NewInstancesResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(ce552eef738a45ea)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct InstanceFactory::ModelInfoParams {
  ModelInfoParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bf49e08cc9412aaf, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct InstanceFactory::NewInstanceParams {
  NewInstanceParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9ee4515395213845, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct InstanceFactory::NewInstanceResults {
  NewInstanceResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f013eda158070488, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct InstanceFactory::NewInstancesParams {
  NewInstancesParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d9fa9ece71d1db50, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct InstanceFactory::NewInstancesResults {
  NewInstancesResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(af9a1cb72ba68156, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class XYResult::Reader {
public:
  typedef XYResult Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasXs() const;
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader getXs() const;

  inline bool hasYs() const;
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader getYs() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class XYResult::Builder {
public:
  typedef XYResult Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasXs();
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder getXs();
  inline void setXs( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setXs(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder initXs(unsigned int size);
  inline void adoptXs(::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> disownXs();

  inline bool hasYs();
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder getYs();
  inline void setYs( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setYs(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder initYs(unsigned int size);
  inline void adoptYs(::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> disownYs();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class XYResult::Pipeline {
public:
  typedef XYResult Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Stat::Reader {
public:
  typedef Stat Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::mas::schema::model::Stat::Type getType() const;

  inline bool hasVs() const;
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader getVs() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Stat::Builder {
public:
  typedef Stat Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::mas::schema::model::Stat::Type getType();
  inline void setType( ::mas::schema::model::Stat::Type value);

  inline bool hasVs();
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder getVs();
  inline void setVs( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setVs(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder initVs(unsigned int size);
  inline void adoptVs(::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> disownVs();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Stat::Pipeline {
public:
  typedef Stat Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class XYPlusResult::Reader {
public:
  typedef XYPlusResult Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasXy() const;
  inline  ::mas::schema::model::XYResult::Reader getXy() const;

  inline bool hasStats() const;
  inline  ::capnp::List< ::mas::schema::model::Stat,  ::capnp::Kind::STRUCT>::Reader getStats() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class XYPlusResult::Builder {
public:
  typedef XYPlusResult Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasXy();
  inline  ::mas::schema::model::XYResult::Builder getXy();
  inline void setXy( ::mas::schema::model::XYResult::Reader value);
  inline  ::mas::schema::model::XYResult::Builder initXy();
  inline void adoptXy(::capnp::Orphan< ::mas::schema::model::XYResult>&& value);
  inline ::capnp::Orphan< ::mas::schema::model::XYResult> disownXy();

  inline bool hasStats();
  inline  ::capnp::List< ::mas::schema::model::Stat,  ::capnp::Kind::STRUCT>::Builder getStats();
  inline void setStats( ::capnp::List< ::mas::schema::model::Stat,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::model::Stat,  ::capnp::Kind::STRUCT>::Builder initStats(unsigned int size);
  inline void adoptStats(::capnp::Orphan< ::capnp::List< ::mas::schema::model::Stat,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::model::Stat,  ::capnp::Kind::STRUCT>> disownStats();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class XYPlusResult::Pipeline {
public:
  typedef XYPlusResult Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::model::XYResult::Pipeline getXy();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class ClimateInstance::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client {
public:
  typedef ClimateInstance Calls;
  typedef ClimateInstance Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::model::ClimateInstance::RunParams,  ::mas::schema::model::ClimateInstance::RunResults> runRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::model::ClimateInstance::RunSetParams,  ::mas::schema::model::ClimateInstance::RunSetResults> runSetRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class ClimateInstance::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server {
public:
  typedef ClimateInstance Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::model::ClimateInstance::RunParams RunParams;
  typedef  ::mas::schema::model::ClimateInstance::RunResults RunResults;
  typedef ::capnp::CallContext<RunParams, RunResults> RunContext;
  virtual ::kj::Promise<void> run(RunContext context);
  typedef  ::mas::schema::model::ClimateInstance::RunSetParams RunSetParams;
  typedef  ::mas::schema::model::ClimateInstance::RunSetResults RunSetResults;
  typedef ::capnp::CallContext<RunSetParams, RunSetResults> RunSetContext;
  virtual ::kj::Promise<void> runSet(RunSetContext context);

  inline  ::mas::schema::model::ClimateInstance::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::model::ClimateInstance>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class ClimateInstance::RunParams::Reader {
public:
  typedef RunParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTimeSeries() const;
#if !CAPNP_LITE
  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ClimateInstance::RunParams::Builder {
public:
  typedef RunParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTimeSeries();
#if !CAPNP_LITE
  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries();
  inline void setTimeSeries( ::mas::schema::climate::TimeSeries::Client&& value);
  inline void setTimeSeries( ::mas::schema::climate::TimeSeries::Client& value);
  inline void adoptTimeSeries(::capnp::Orphan< ::mas::schema::climate::TimeSeries>&& value);
  inline ::capnp::Orphan< ::mas::schema::climate::TimeSeries> disownTimeSeries();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ClimateInstance::RunParams::Pipeline {
public:
  typedef RunParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ClimateInstance::RunResults::Reader {
public:
  typedef RunResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::mas::schema::model::XYResult::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ClimateInstance::RunResults::Builder {
public:
  typedef RunResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::mas::schema::model::XYResult::Builder getResult();
  inline void setResult( ::mas::schema::model::XYResult::Reader value);
  inline  ::mas::schema::model::XYResult::Builder initResult();
  inline void adoptResult(::capnp::Orphan< ::mas::schema::model::XYResult>&& value);
  inline ::capnp::Orphan< ::mas::schema::model::XYResult> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ClimateInstance::RunResults::Pipeline {
public:
  typedef RunResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::model::XYResult::Pipeline getResult();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ClimateInstance::RunSetParams::Reader {
public:
  typedef RunSetParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasDataset() const;
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::climate::TimeSeries,  ::capnp::Kind::INTERFACE>::Reader getDataset() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ClimateInstance::RunSetParams::Builder {
public:
  typedef RunSetParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasDataset();
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::climate::TimeSeries,  ::capnp::Kind::INTERFACE>::Builder getDataset();
  inline void setDataset( ::capnp::List< ::mas::schema::climate::TimeSeries,  ::capnp::Kind::INTERFACE>::Reader value);
  inline  ::capnp::List< ::mas::schema::climate::TimeSeries,  ::capnp::Kind::INTERFACE>::Builder initDataset(unsigned int size);
  inline void adoptDataset(::capnp::Orphan< ::capnp::List< ::mas::schema::climate::TimeSeries,  ::capnp::Kind::INTERFACE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::TimeSeries,  ::capnp::Kind::INTERFACE>> disownDataset();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ClimateInstance::RunSetParams::Pipeline {
public:
  typedef RunSetParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ClimateInstance::RunSetResults::Reader {
public:
  typedef RunSetResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::mas::schema::model::XYPlusResult::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ClimateInstance::RunSetResults::Builder {
public:
  typedef RunSetResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::mas::schema::model::XYPlusResult::Builder getResult();
  inline void setResult( ::mas::schema::model::XYPlusResult::Reader value);
  inline  ::mas::schema::model::XYPlusResult::Builder initResult();
  inline void adoptResult(::capnp::Orphan< ::mas::schema::model::XYPlusResult>&& value);
  inline ::capnp::Orphan< ::mas::schema::model::XYPlusResult> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ClimateInstance::RunSetResults::Pipeline {
public:
  typedef RunSetResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::model::XYPlusResult::Pipeline getResult();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename RestInput>
class Env<RestInput>::Reader {
public:
  typedef Env Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename RestInput2 = ::capnp::AnyPointer>
  typename Env<RestInput2>::Reader asGeneric() {
    return typename Env<RestInput2>::Reader(_reader);
  }

  inline bool hasRest() const;
  inline  ::capnp::ReaderFor<RestInput> getRest() const;

  inline bool hasTimeSeries() const;
#if !CAPNP_LITE
  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries() const;
#endif  // !CAPNP_LITE

  inline bool hasSoilProfile() const;
#if !CAPNP_LITE
  inline  ::mas::schema::soil::Profile::Client getSoilProfile() const;
#endif  // !CAPNP_LITE

  inline bool hasMgmtEvents() const;
  inline  ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>::Reader getMgmtEvents() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename RestInput>
class Env<RestInput>::Builder {
public:
  typedef Env Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename RestInput2 = ::capnp::AnyPointer>
  typename Env<RestInput2>::Builder asGeneric() {
    return typename Env<RestInput2>::Builder(_builder);
  }

  inline bool hasRest();
  inline  ::capnp::BuilderFor<RestInput> getRest();
  inline void setRest( ::capnp::ReaderFor<RestInput> value);
  inline  ::capnp::BuilderFor<RestInput> initRest();
  inline  ::capnp::BuilderFor<RestInput> initRest(unsigned int size);
  inline void adoptRest(::capnp::Orphan<RestInput>&& value);
  inline ::capnp::Orphan<RestInput> disownRest();

  inline bool hasTimeSeries();
#if !CAPNP_LITE
  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries();
  inline void setTimeSeries( ::mas::schema::climate::TimeSeries::Client&& value);
  inline void setTimeSeries( ::mas::schema::climate::TimeSeries::Client& value);
  inline void adoptTimeSeries(::capnp::Orphan< ::mas::schema::climate::TimeSeries>&& value);
  inline ::capnp::Orphan< ::mas::schema::climate::TimeSeries> disownTimeSeries();
#endif  // !CAPNP_LITE

  inline bool hasSoilProfile();
#if !CAPNP_LITE
  inline  ::mas::schema::soil::Profile::Client getSoilProfile();
  inline void setSoilProfile( ::mas::schema::soil::Profile::Client&& value);
  inline void setSoilProfile( ::mas::schema::soil::Profile::Client& value);
  inline void adoptSoilProfile(::capnp::Orphan< ::mas::schema::soil::Profile>&& value);
  inline ::capnp::Orphan< ::mas::schema::soil::Profile> disownSoilProfile();
#endif  // !CAPNP_LITE

  inline bool hasMgmtEvents();
  inline  ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>::Builder getMgmtEvents();
  inline void setMgmtEvents( ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>::Builder initMgmtEvents(unsigned int size);
  inline void adoptMgmtEvents(::capnp::Orphan< ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>> disownMgmtEvents();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename RestInput>
class Env<RestInput>::Pipeline {
public:
  typedef Env Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<RestInput> getRest();
  inline  ::mas::schema::climate::TimeSeries::Client getTimeSeries();
  inline  ::mas::schema::soil::Profile::Client getSoilProfile();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename RestInput, typename Output>
class EnvInstance<RestInput, Output>::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client,
      public virtual  ::mas::schema::persistence::Persistent::Client,
      public virtual  ::mas::schema::service::Stopable::Client {
public:
  typedef EnvInstance Calls;
  typedef EnvInstance Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename RestInput2 = ::capnp::AnyPointer, typename Output2 = ::capnp::AnyPointer>
  typename EnvInstance<RestInput2, Output2>::Client asGeneric() {
    return castAs<EnvInstance<RestInput2, Output2>>();
  }

  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::model::EnvInstance<RestInput, Output>::RunParams, typename  ::mas::schema::model::EnvInstance<RestInput, Output>::RunResults>) runRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

template <typename RestInput, typename Output>
class EnvInstance<RestInput, Output>::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server,
      public virtual  ::mas::schema::persistence::Persistent::Server,
      public virtual  ::mas::schema::service::Stopable::Server {
public:
  typedef EnvInstance Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef typename  ::mas::schema::model::EnvInstance<RestInput, Output>::RunParams RunParams;
  typedef typename  ::mas::schema::model::EnvInstance<RestInput, Output>::RunResults RunResults;
  typedef ::capnp::CallContext<RunParams, RunResults> RunContext;
  virtual ::kj::Promise<void> run(RunContext context);

  inline typename  ::mas::schema::model::EnvInstance<RestInput, Output>::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::model::EnvInstance<RestInput, Output>>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename RestInput, typename Output>
class EnvInstance<RestInput, Output>::RunParams::Reader {
public:
  typedef RunParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename RestInput2 = ::capnp::AnyPointer, typename Output2 = ::capnp::AnyPointer>
  typename EnvInstance<RestInput2, Output2>::RunParams::Reader asEnvInstanceGeneric() {
    return typename EnvInstance<RestInput2, Output2>::RunParams::Reader(_reader);
  }

  inline bool hasEnv() const;
  inline typename  ::mas::schema::model::Env<RestInput>::Reader getEnv() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename RestInput, typename Output>
class EnvInstance<RestInput, Output>::RunParams::Builder {
public:
  typedef RunParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename RestInput2 = ::capnp::AnyPointer, typename Output2 = ::capnp::AnyPointer>
  typename EnvInstance<RestInput2, Output2>::RunParams::Builder asEnvInstanceGeneric() {
    return typename EnvInstance<RestInput2, Output2>::RunParams::Builder(_builder);
  }

  inline bool hasEnv();
  inline typename  ::mas::schema::model::Env<RestInput>::Builder getEnv();
  inline void setEnv(typename  ::mas::schema::model::Env<RestInput>::Reader value);
  inline typename  ::mas::schema::model::Env<RestInput>::Builder initEnv();
  inline void adoptEnv(::capnp::Orphan< ::mas::schema::model::Env<RestInput>>&& value);
  inline ::capnp::Orphan< ::mas::schema::model::Env<RestInput>> disownEnv();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename RestInput, typename Output>
class EnvInstance<RestInput, Output>::RunParams::Pipeline {
public:
  typedef RunParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename  ::mas::schema::model::Env<RestInput>::Pipeline getEnv();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename RestInput, typename Output>
class EnvInstance<RestInput, Output>::RunResults::Reader {
public:
  typedef RunResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename RestInput2 = ::capnp::AnyPointer, typename Output2 = ::capnp::AnyPointer>
  typename EnvInstance<RestInput2, Output2>::RunResults::Reader asEnvInstanceGeneric() {
    return typename EnvInstance<RestInput2, Output2>::RunResults::Reader(_reader);
  }

  inline bool hasResult() const;
  inline  ::capnp::ReaderFor<Output> getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename RestInput, typename Output>
class EnvInstance<RestInput, Output>::RunResults::Builder {
public:
  typedef RunResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename RestInput2 = ::capnp::AnyPointer, typename Output2 = ::capnp::AnyPointer>
  typename EnvInstance<RestInput2, Output2>::RunResults::Builder asEnvInstanceGeneric() {
    return typename EnvInstance<RestInput2, Output2>::RunResults::Builder(_builder);
  }

  inline bool hasResult();
  inline  ::capnp::BuilderFor<Output> getResult();
  inline void setResult( ::capnp::ReaderFor<Output> value);
  inline  ::capnp::BuilderFor<Output> initResult();
  inline  ::capnp::BuilderFor<Output> initResult(unsigned int size);
  inline void adoptResult(::capnp::Orphan<Output>&& value);
  inline ::capnp::Orphan<Output> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename RestInput, typename Output>
class EnvInstance<RestInput, Output>::RunResults::Pipeline {
public:
  typedef RunResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<Output> getResult();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename RestInput, typename Output>
class EnvInstanceProxy<RestInput, Output>::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::model::EnvInstance<RestInput, Output>::Client {
public:
  typedef EnvInstanceProxy Calls;
  typedef EnvInstanceProxy Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename RestInput2 = ::capnp::AnyPointer, typename Output2 = ::capnp::AnyPointer>
  typename EnvInstanceProxy<RestInput2, Output2>::Client asGeneric() {
    return castAs<EnvInstanceProxy<RestInput2, Output2>>();
  }

  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams, typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults>) registerEnvInstanceRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

template <typename RestInput, typename Output>
class EnvInstanceProxy<RestInput, Output>::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::model::EnvInstance<RestInput, Output>::Server {
public:
  typedef EnvInstanceProxy Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams RegisterEnvInstanceParams;
  typedef typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults RegisterEnvInstanceResults;
  typedef ::capnp::CallContext<RegisterEnvInstanceParams, RegisterEnvInstanceResults> RegisterEnvInstanceContext;
  virtual ::kj::Promise<void> registerEnvInstance(RegisterEnvInstanceContext context);

  inline typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::model::EnvInstanceProxy<RestInput, Output>>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename RestInput, typename Output>
class EnvInstanceProxy<RestInput, Output>::Unregister::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Unregister Calls;
  typedef Unregister Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename RestInput2 = ::capnp::AnyPointer, typename Output2 = ::capnp::AnyPointer>
  typename EnvInstanceProxy<RestInput2, Output2>::Unregister::Client asEnvInstanceProxyGeneric() {
    return castAs<typename EnvInstanceProxy<RestInput2, Output2>::Unregister>();
  }

  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterParams, typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterResults>) unregisterRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

template <typename RestInput, typename Output>
class EnvInstanceProxy<RestInput, Output>::Unregister::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Unregister Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterParams UnregisterParams;
  typedef typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterResults UnregisterResults;
  typedef ::capnp::CallContext<UnregisterParams, UnregisterResults> UnregisterContext;
  virtual ::kj::Promise<void> unregister(UnregisterContext context);

  inline typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs<typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename RestInput, typename Output>
class EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterParams::Reader {
public:
  typedef UnregisterParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename RestInput2 = ::capnp::AnyPointer, typename Output2 = ::capnp::AnyPointer>
  typename EnvInstanceProxy<RestInput2, Output2>::Unregister::Reader asEnvInstanceProxyGeneric() {
    return typename EnvInstanceProxy<RestInput2, Output2>::Unregister::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename RestInput, typename Output>
class EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterParams::Builder {
public:
  typedef UnregisterParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename RestInput2 = ::capnp::AnyPointer, typename Output2 = ::capnp::AnyPointer>
  typename EnvInstanceProxy<RestInput2, Output2>::Unregister::Builder asEnvInstanceProxyGeneric() {
    return typename EnvInstanceProxy<RestInput2, Output2>::Unregister::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename RestInput, typename Output>
class EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterParams::Pipeline {
public:
  typedef UnregisterParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename RestInput, typename Output>
class EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterResults::Reader {
public:
  typedef UnregisterResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename RestInput2 = ::capnp::AnyPointer, typename Output2 = ::capnp::AnyPointer>
  typename EnvInstanceProxy<RestInput2, Output2>::Unregister::Reader asEnvInstanceProxyGeneric() {
    return typename EnvInstanceProxy<RestInput2, Output2>::Unregister::Reader(_reader);
  }

  inline bool getSuccess() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename RestInput, typename Output>
class EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterResults::Builder {
public:
  typedef UnregisterResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename RestInput2 = ::capnp::AnyPointer, typename Output2 = ::capnp::AnyPointer>
  typename EnvInstanceProxy<RestInput2, Output2>::Unregister::Builder asEnvInstanceProxyGeneric() {
    return typename EnvInstanceProxy<RestInput2, Output2>::Unregister::Builder(_builder);
  }

  inline bool getSuccess();
  inline void setSuccess(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename RestInput, typename Output>
class EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterResults::Pipeline {
public:
  typedef UnregisterResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename RestInput, typename Output>
class EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams::Reader {
public:
  typedef RegisterEnvInstanceParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename RestInput2 = ::capnp::AnyPointer, typename Output2 = ::capnp::AnyPointer>
  typename EnvInstanceProxy<RestInput2, Output2>::RegisterEnvInstanceParams::Reader asEnvInstanceProxyGeneric() {
    return typename EnvInstanceProxy<RestInput2, Output2>::RegisterEnvInstanceParams::Reader(_reader);
  }

  inline bool hasInstance() const;
#if !CAPNP_LITE
  inline typename  ::mas::schema::model::EnvInstance<RestInput, Output>::Client getInstance() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename RestInput, typename Output>
class EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams::Builder {
public:
  typedef RegisterEnvInstanceParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename RestInput2 = ::capnp::AnyPointer, typename Output2 = ::capnp::AnyPointer>
  typename EnvInstanceProxy<RestInput2, Output2>::RegisterEnvInstanceParams::Builder asEnvInstanceProxyGeneric() {
    return typename EnvInstanceProxy<RestInput2, Output2>::RegisterEnvInstanceParams::Builder(_builder);
  }

  inline bool hasInstance();
#if !CAPNP_LITE
  inline typename  ::mas::schema::model::EnvInstance<RestInput, Output>::Client getInstance();
  inline void setInstance(typename  ::mas::schema::model::EnvInstance<RestInput, Output>::Client&& value);
  inline void setInstance(typename  ::mas::schema::model::EnvInstance<RestInput, Output>::Client& value);
  inline void adoptInstance(::capnp::Orphan< ::mas::schema::model::EnvInstance<RestInput, Output>>&& value);
  inline ::capnp::Orphan< ::mas::schema::model::EnvInstance<RestInput, Output>> disownInstance();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename RestInput, typename Output>
class EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams::Pipeline {
public:
  typedef RegisterEnvInstanceParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename  ::mas::schema::model::EnvInstance<RestInput, Output>::Client getInstance();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename RestInput, typename Output>
class EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults::Reader {
public:
  typedef RegisterEnvInstanceResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename RestInput2 = ::capnp::AnyPointer, typename Output2 = ::capnp::AnyPointer>
  typename EnvInstanceProxy<RestInput2, Output2>::RegisterEnvInstanceResults::Reader asEnvInstanceProxyGeneric() {
    return typename EnvInstanceProxy<RestInput2, Output2>::RegisterEnvInstanceResults::Reader(_reader);
  }

  inline bool hasUnregister() const;
#if !CAPNP_LITE
  inline typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::Client getUnregister() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename RestInput, typename Output>
class EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults::Builder {
public:
  typedef RegisterEnvInstanceResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename RestInput2 = ::capnp::AnyPointer, typename Output2 = ::capnp::AnyPointer>
  typename EnvInstanceProxy<RestInput2, Output2>::RegisterEnvInstanceResults::Builder asEnvInstanceProxyGeneric() {
    return typename EnvInstanceProxy<RestInput2, Output2>::RegisterEnvInstanceResults::Builder(_builder);
  }

  inline bool hasUnregister();
#if !CAPNP_LITE
  inline typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::Client getUnregister();
  inline void setUnregister(typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::Client&& value);
  inline void setUnregister(typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::Client& value);
  inline void adoptUnregister(::capnp::Orphan<typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister>&& value);
  inline ::capnp::Orphan<typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister> disownUnregister();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename RestInput, typename Output>
class EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults::Pipeline {
public:
  typedef RegisterEnvInstanceResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::Client getUnregister();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class InstanceFactory::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client {
public:
  typedef InstanceFactory Calls;
  typedef InstanceFactory Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::model::InstanceFactory::ModelInfoParams,  ::mas::schema::common::IdInformation> modelInfoRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::model::InstanceFactory::NewInstanceParams,  ::mas::schema::model::InstanceFactory::NewInstanceResults> newInstanceRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::model::InstanceFactory::NewInstancesParams,  ::mas::schema::model::InstanceFactory::NewInstancesResults> newInstancesRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class InstanceFactory::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server {
public:
  typedef InstanceFactory Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::model::InstanceFactory::ModelInfoParams ModelInfoParams;
  typedef ::capnp::CallContext<ModelInfoParams,  ::mas::schema::common::IdInformation> ModelInfoContext;
  virtual ::kj::Promise<void> modelInfo(ModelInfoContext context);
  typedef  ::mas::schema::model::InstanceFactory::NewInstanceParams NewInstanceParams;
  typedef  ::mas::schema::model::InstanceFactory::NewInstanceResults NewInstanceResults;
  typedef ::capnp::CallContext<NewInstanceParams, NewInstanceResults> NewInstanceContext;
  virtual ::kj::Promise<void> newInstance(NewInstanceContext context);
  typedef  ::mas::schema::model::InstanceFactory::NewInstancesParams NewInstancesParams;
  typedef  ::mas::schema::model::InstanceFactory::NewInstancesResults NewInstancesResults;
  typedef ::capnp::CallContext<NewInstancesParams, NewInstancesResults> NewInstancesContext;
  virtual ::kj::Promise<void> newInstances(NewInstancesContext context);

  inline  ::mas::schema::model::InstanceFactory::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::model::InstanceFactory>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class InstanceFactory::ModelInfoParams::Reader {
public:
  typedef ModelInfoParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class InstanceFactory::ModelInfoParams::Builder {
public:
  typedef ModelInfoParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class InstanceFactory::ModelInfoParams::Pipeline {
public:
  typedef ModelInfoParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class InstanceFactory::NewInstanceParams::Reader {
public:
  typedef NewInstanceParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class InstanceFactory::NewInstanceParams::Builder {
public:
  typedef NewInstanceParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class InstanceFactory::NewInstanceParams::Pipeline {
public:
  typedef NewInstanceParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class InstanceFactory::NewInstanceResults::Reader {
public:
  typedef NewInstanceResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasInstance() const;
#if !CAPNP_LITE
  inline  ::mas::schema::common::Identifiable::Client getInstance() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class InstanceFactory::NewInstanceResults::Builder {
public:
  typedef NewInstanceResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasInstance();
#if !CAPNP_LITE
  inline  ::mas::schema::common::Identifiable::Client getInstance();
  inline void setInstance( ::mas::schema::common::Identifiable::Client&& value);
  inline void setInstance( ::mas::schema::common::Identifiable::Client& value);
  inline void adoptInstance(::capnp::Orphan< ::mas::schema::common::Identifiable>&& value);
  inline ::capnp::Orphan< ::mas::schema::common::Identifiable> disownInstance();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class InstanceFactory::NewInstanceResults::Pipeline {
public:
  typedef NewInstanceResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::common::Identifiable::Client getInstance();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class InstanceFactory::NewInstancesParams::Reader {
public:
  typedef NewInstancesParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int16_t getNumberOfInstances() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class InstanceFactory::NewInstancesParams::Builder {
public:
  typedef NewInstancesParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int16_t getNumberOfInstances();
  inline void setNumberOfInstances( ::int16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class InstanceFactory::NewInstancesParams::Pipeline {
public:
  typedef NewInstancesParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class InstanceFactory::NewInstancesResults::Reader {
public:
  typedef NewInstancesResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasInstances() const;
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Reader getInstances() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class InstanceFactory::NewInstancesResults::Builder {
public:
  typedef NewInstancesResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasInstances();
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Builder getInstances();
  inline void setInstances( ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Reader value);
  inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Builder initInstances(unsigned int size);
  inline void adoptInstances(::capnp::Orphan< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>> disownInstances();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class InstanceFactory::NewInstancesResults::Pipeline {
public:
  typedef NewInstancesResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline bool XYResult::Reader::hasXs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool XYResult::Builder::hasXs() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader XYResult::Reader::getXs() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder XYResult::Builder::getXs() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void XYResult::Builder::setXs( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void XYResult::Builder::setXs(::kj::ArrayPtr<const double> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder XYResult::Builder::initXs(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void XYResult::Builder::adoptXs(
    ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> XYResult::Builder::disownXs() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool XYResult::Reader::hasYs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool XYResult::Builder::hasYs() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader XYResult::Reader::getYs() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder XYResult::Builder::getYs() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void XYResult::Builder::setYs( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void XYResult::Builder::setYs(::kj::ArrayPtr<const double> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder XYResult::Builder::initYs(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void XYResult::Builder::adoptYs(
    ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> XYResult::Builder::disownYs() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::mas::schema::model::Stat::Type Stat::Reader::getType() const {
  return _reader.getDataField< ::mas::schema::model::Stat::Type>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 3u);
}

inline  ::mas::schema::model::Stat::Type Stat::Builder::getType() {
  return _builder.getDataField< ::mas::schema::model::Stat::Type>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 3u);
}
inline void Stat::Builder::setType( ::mas::schema::model::Stat::Type value) {
  _builder.setDataField< ::mas::schema::model::Stat::Type>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, 3u);
}

inline bool Stat::Reader::hasVs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Stat::Builder::hasVs() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader Stat::Reader::getVs() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder Stat::Builder::getVs() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stat::Builder::setVs( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Stat::Builder::setVs(::kj::ArrayPtr<const double> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder Stat::Builder::initVs(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Stat::Builder::adoptVs(
    ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> Stat::Builder::disownVs() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool XYPlusResult::Reader::hasXy() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool XYPlusResult::Builder::hasXy() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::model::XYResult::Reader XYPlusResult::Reader::getXy() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::model::XYResult>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::model::XYResult::Builder XYPlusResult::Builder::getXy() {
  return ::capnp::_::PointerHelpers< ::mas::schema::model::XYResult>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::model::XYResult::Pipeline XYPlusResult::Pipeline::getXy() {
  return  ::mas::schema::model::XYResult::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void XYPlusResult::Builder::setXy( ::mas::schema::model::XYResult::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::model::XYResult>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::model::XYResult::Builder XYPlusResult::Builder::initXy() {
  return ::capnp::_::PointerHelpers< ::mas::schema::model::XYResult>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void XYPlusResult::Builder::adoptXy(
    ::capnp::Orphan< ::mas::schema::model::XYResult>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::model::XYResult>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::model::XYResult> XYPlusResult::Builder::disownXy() {
  return ::capnp::_::PointerHelpers< ::mas::schema::model::XYResult>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool XYPlusResult::Reader::hasStats() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool XYPlusResult::Builder::hasStats() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::model::Stat,  ::capnp::Kind::STRUCT>::Reader XYPlusResult::Reader::getStats() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::model::Stat,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::model::Stat,  ::capnp::Kind::STRUCT>::Builder XYPlusResult::Builder::getStats() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::model::Stat,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void XYPlusResult::Builder::setStats( ::capnp::List< ::mas::schema::model::Stat,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::model::Stat,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::model::Stat,  ::capnp::Kind::STRUCT>::Builder XYPlusResult::Builder::initStats(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::model::Stat,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void XYPlusResult::Builder::adoptStats(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::model::Stat,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::model::Stat,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::model::Stat,  ::capnp::Kind::STRUCT>> XYPlusResult::Builder::disownStats() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::model::Stat,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline ClimateInstance::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline ClimateInstance::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline ClimateInstance::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline ClimateInstance::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline ClimateInstance::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::model::ClimateInstance::Client& ClimateInstance::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::model::ClimateInstance::Client& ClimateInstance::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool ClimateInstance::RunParams::Reader::hasTimeSeries() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ClimateInstance::RunParams::Builder::hasTimeSeries() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::climate::TimeSeries::Client ClimateInstance::RunParams::Reader::getTimeSeries() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::TimeSeries::Client ClimateInstance::RunParams::Builder::getTimeSeries() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::climate::TimeSeries::Client ClimateInstance::RunParams::Pipeline::getTimeSeries() {
  return  ::mas::schema::climate::TimeSeries::Client(_typeless.getPointerField(0).asCap());
}
inline void ClimateInstance::RunParams::Builder::setTimeSeries( ::mas::schema::climate::TimeSeries::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void ClimateInstance::RunParams::Builder::setTimeSeries( ::mas::schema::climate::TimeSeries::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void ClimateInstance::RunParams::Builder::adoptTimeSeries(
    ::capnp::Orphan< ::mas::schema::climate::TimeSeries>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::climate::TimeSeries> ClimateInstance::RunParams::Builder::disownTimeSeries() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool ClimateInstance::RunResults::Reader::hasResult() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ClimateInstance::RunResults::Builder::hasResult() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::model::XYResult::Reader ClimateInstance::RunResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::model::XYResult>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::model::XYResult::Builder ClimateInstance::RunResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::mas::schema::model::XYResult>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::model::XYResult::Pipeline ClimateInstance::RunResults::Pipeline::getResult() {
  return  ::mas::schema::model::XYResult::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void ClimateInstance::RunResults::Builder::setResult( ::mas::schema::model::XYResult::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::model::XYResult>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::model::XYResult::Builder ClimateInstance::RunResults::Builder::initResult() {
  return ::capnp::_::PointerHelpers< ::mas::schema::model::XYResult>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ClimateInstance::RunResults::Builder::adoptResult(
    ::capnp::Orphan< ::mas::schema::model::XYResult>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::model::XYResult>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::model::XYResult> ClimateInstance::RunResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::mas::schema::model::XYResult>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ClimateInstance::RunSetParams::Reader::hasDataset() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ClimateInstance::RunSetParams::Builder::hasDataset() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnp::List< ::mas::schema::climate::TimeSeries,  ::capnp::Kind::INTERFACE>::Reader ClimateInstance::RunSetParams::Reader::getDataset() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::TimeSeries,  ::capnp::Kind::INTERFACE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::climate::TimeSeries,  ::capnp::Kind::INTERFACE>::Builder ClimateInstance::RunSetParams::Builder::getDataset() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::TimeSeries,  ::capnp::Kind::INTERFACE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ClimateInstance::RunSetParams::Builder::setDataset( ::capnp::List< ::mas::schema::climate::TimeSeries,  ::capnp::Kind::INTERFACE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::TimeSeries,  ::capnp::Kind::INTERFACE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::climate::TimeSeries,  ::capnp::Kind::INTERFACE>::Builder ClimateInstance::RunSetParams::Builder::initDataset(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::TimeSeries,  ::capnp::Kind::INTERFACE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ClimateInstance::RunSetParams::Builder::adoptDataset(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::TimeSeries,  ::capnp::Kind::INTERFACE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::TimeSeries,  ::capnp::Kind::INTERFACE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::climate::TimeSeries,  ::capnp::Kind::INTERFACE>> ClimateInstance::RunSetParams::Builder::disownDataset() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::climate::TimeSeries,  ::capnp::Kind::INTERFACE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool ClimateInstance::RunSetResults::Reader::hasResult() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ClimateInstance::RunSetResults::Builder::hasResult() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::model::XYPlusResult::Reader ClimateInstance::RunSetResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::model::XYPlusResult>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::model::XYPlusResult::Builder ClimateInstance::RunSetResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::mas::schema::model::XYPlusResult>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::model::XYPlusResult::Pipeline ClimateInstance::RunSetResults::Pipeline::getResult() {
  return  ::mas::schema::model::XYPlusResult::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void ClimateInstance::RunSetResults::Builder::setResult( ::mas::schema::model::XYPlusResult::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::model::XYPlusResult>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::model::XYPlusResult::Builder ClimateInstance::RunSetResults::Builder::initResult() {
  return ::capnp::_::PointerHelpers< ::mas::schema::model::XYPlusResult>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ClimateInstance::RunSetResults::Builder::adoptResult(
    ::capnp::Orphan< ::mas::schema::model::XYPlusResult>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::model::XYPlusResult>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::model::XYPlusResult> ClimateInstance::RunSetResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::mas::schema::model::XYPlusResult>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename RestInput>
inline bool Env<RestInput>::Reader::hasRest() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename RestInput>
inline bool Env<RestInput>::Builder::hasRest() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename RestInput>
inline  ::capnp::ReaderFor<RestInput> Env<RestInput>::Reader::getRest() const {
  return ::capnp::_::PointerHelpers<RestInput>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename RestInput>
inline  ::capnp::BuilderFor<RestInput> Env<RestInput>::Builder::getRest() {
  return ::capnp::_::PointerHelpers<RestInput>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename RestInput>
inline  ::capnp::PipelineFor<RestInput> Env<RestInput>::Pipeline::getRest() {
  return  ::capnp::PipelineFor<RestInput>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename RestInput>
inline void Env<RestInput>::Builder::setRest( ::capnp::ReaderFor<RestInput> value) {
  ::capnp::_::PointerHelpers<RestInput>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename RestInput>
inline  ::capnp::BuilderFor<RestInput> Env<RestInput>::Builder::initRest() {
  return ::capnp::_::PointerHelpers<RestInput>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename RestInput>
inline  ::capnp::BuilderFor<RestInput> Env<RestInput>::Builder::initRest(unsigned int size) {
  return ::capnp::_::PointerHelpers<RestInput>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename RestInput>
inline void Env<RestInput>::Builder::adoptRest(
    ::capnp::Orphan<RestInput>&& value) {
  ::capnp::_::PointerHelpers<RestInput>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename RestInput>
inline ::capnp::Orphan<RestInput> Env<RestInput>::Builder::disownRest() {
  return ::capnp::_::PointerHelpers<RestInput>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename RestInput>
inline bool Env<RestInput>::Reader::hasTimeSeries() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename RestInput>
inline bool Env<RestInput>::Builder::hasTimeSeries() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename RestInput>
inline  ::mas::schema::climate::TimeSeries::Client Env<RestInput>::Reader::getTimeSeries() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename RestInput>
inline  ::mas::schema::climate::TimeSeries::Client Env<RestInput>::Builder::getTimeSeries() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename RestInput>
inline  ::mas::schema::climate::TimeSeries::Client Env<RestInput>::Pipeline::getTimeSeries() {
  return  ::mas::schema::climate::TimeSeries::Client(_typeless.getPointerField(1).asCap());
}
template <typename RestInput>
inline void Env<RestInput>::Builder::setTimeSeries( ::mas::schema::climate::TimeSeries::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(cap));
}
template <typename RestInput>
inline void Env<RestInput>::Builder::setTimeSeries( ::mas::schema::climate::TimeSeries::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), cap);
}
template <typename RestInput>
inline void Env<RestInput>::Builder::adoptTimeSeries(
    ::capnp::Orphan< ::mas::schema::climate::TimeSeries>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename RestInput>
inline ::capnp::Orphan< ::mas::schema::climate::TimeSeries> Env<RestInput>::Builder::disownTimeSeries() {
  return ::capnp::_::PointerHelpers< ::mas::schema::climate::TimeSeries>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

template <typename RestInput>
inline bool Env<RestInput>::Reader::hasSoilProfile() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
template <typename RestInput>
inline bool Env<RestInput>::Builder::hasSoilProfile() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename RestInput>
inline  ::mas::schema::soil::Profile::Client Env<RestInput>::Reader::getSoilProfile() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::soil::Profile>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
template <typename RestInput>
inline  ::mas::schema::soil::Profile::Client Env<RestInput>::Builder::getSoilProfile() {
  return ::capnp::_::PointerHelpers< ::mas::schema::soil::Profile>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
template <typename RestInput>
inline  ::mas::schema::soil::Profile::Client Env<RestInput>::Pipeline::getSoilProfile() {
  return  ::mas::schema::soil::Profile::Client(_typeless.getPointerField(2).asCap());
}
template <typename RestInput>
inline void Env<RestInput>::Builder::setSoilProfile( ::mas::schema::soil::Profile::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::soil::Profile>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(cap));
}
template <typename RestInput>
inline void Env<RestInput>::Builder::setSoilProfile( ::mas::schema::soil::Profile::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::soil::Profile>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), cap);
}
template <typename RestInput>
inline void Env<RestInput>::Builder::adoptSoilProfile(
    ::capnp::Orphan< ::mas::schema::soil::Profile>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::soil::Profile>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename RestInput>
inline ::capnp::Orphan< ::mas::schema::soil::Profile> Env<RestInput>::Builder::disownSoilProfile() {
  return ::capnp::_::PointerHelpers< ::mas::schema::soil::Profile>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

template <typename RestInput>
inline bool Env<RestInput>::Reader::hasMgmtEvents() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
template <typename RestInput>
inline bool Env<RestInput>::Builder::hasMgmtEvents() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
template <typename RestInput>
inline  ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>::Reader Env<RestInput>::Reader::getMgmtEvents() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
template <typename RestInput>
inline  ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>::Builder Env<RestInput>::Builder::getMgmtEvents() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
template <typename RestInput>
inline void Env<RestInput>::Builder::setMgmtEvents( ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
template <typename RestInput>
inline  ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>::Builder Env<RestInput>::Builder::initMgmtEvents(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
template <typename RestInput>
inline void Env<RestInput>::Builder::adoptMgmtEvents(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename RestInput>
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>> Env<RestInput>::Builder::disownMgmtEvents() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

// Env<RestInput>
template <typename RestInput>
constexpr uint16_t Env<RestInput>::_capnpPrivate::dataWordSize;
template <typename RestInput>
constexpr uint16_t Env<RestInput>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename RestInput>
constexpr ::capnp::Kind Env<RestInput>::_capnpPrivate::kind;
template <typename RestInput>
constexpr ::capnp::_::RawSchema const* Env<RestInput>::_capnpPrivate::schema;
template <typename RestInput>
const ::capnp::_::RawBrandedSchema::Scope Env<RestInput>::_capnpPrivate::brandScopes[] = {
  { 0xb7fc866ef1127f7c, brandBindings + 0, 1, false},
};
template <typename RestInput>
const ::capnp::_::RawBrandedSchema::Binding Env<RestInput>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<RestInput>(),
};
template <typename RestInput>
const ::capnp::_::RawBrandedSchema Env<RestInput>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_b7fc866ef1127f7c, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename RestInput, typename Output>
inline EnvInstance<RestInput, Output>::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
template <typename RestInput, typename Output>
inline EnvInstance<RestInput, Output>::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename RestInput, typename Output>
template <typename _t, typename>
inline EnvInstance<RestInput, Output>::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename RestInput, typename Output>
template <typename _t, typename>
inline EnvInstance<RestInput, Output>::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
template <typename RestInput, typename Output>
inline EnvInstance<RestInput, Output>::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
template <typename RestInput, typename Output>
inline typename  ::mas::schema::model::EnvInstance<RestInput, Output>::Client& EnvInstance<RestInput, Output>::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
template <typename RestInput, typename Output>
inline typename  ::mas::schema::model::EnvInstance<RestInput, Output>::Client& EnvInstance<RestInput, Output>::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
template <typename RestInput, typename Output>
inline bool EnvInstance<RestInput, Output>::RunParams::Reader::hasEnv() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename RestInput, typename Output>
inline bool EnvInstance<RestInput, Output>::RunParams::Builder::hasEnv() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename RestInput, typename Output>
inline typename  ::mas::schema::model::Env<RestInput>::Reader EnvInstance<RestInput, Output>::RunParams::Reader::getEnv() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::model::Env<RestInput>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename RestInput, typename Output>
inline typename  ::mas::schema::model::Env<RestInput>::Builder EnvInstance<RestInput, Output>::RunParams::Builder::getEnv() {
  return ::capnp::_::PointerHelpers< ::mas::schema::model::Env<RestInput>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename RestInput, typename Output>
inline typename  ::mas::schema::model::Env<RestInput>::Pipeline EnvInstance<RestInput, Output>::RunParams::Pipeline::getEnv() {
  return typename  ::mas::schema::model::Env<RestInput>::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename RestInput, typename Output>
inline void EnvInstance<RestInput, Output>::RunParams::Builder::setEnv(typename  ::mas::schema::model::Env<RestInput>::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::model::Env<RestInput>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename RestInput, typename Output>
inline typename  ::mas::schema::model::Env<RestInput>::Builder EnvInstance<RestInput, Output>::RunParams::Builder::initEnv() {
  return ::capnp::_::PointerHelpers< ::mas::schema::model::Env<RestInput>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename RestInput, typename Output>
inline void EnvInstance<RestInput, Output>::RunParams::Builder::adoptEnv(
    ::capnp::Orphan< ::mas::schema::model::Env<RestInput>>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::model::Env<RestInput>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename RestInput, typename Output>
inline ::capnp::Orphan< ::mas::schema::model::Env<RestInput>> EnvInstance<RestInput, Output>::RunParams::Builder::disownEnv() {
  return ::capnp::_::PointerHelpers< ::mas::schema::model::Env<RestInput>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// EnvInstance<RestInput, Output>::RunParams
template <typename RestInput, typename Output>
constexpr uint16_t EnvInstance<RestInput, Output>::RunParams::_capnpPrivate::dataWordSize;
template <typename RestInput, typename Output>
constexpr uint16_t EnvInstance<RestInput, Output>::RunParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename RestInput, typename Output>
constexpr ::capnp::Kind EnvInstance<RestInput, Output>::RunParams::_capnpPrivate::kind;
template <typename RestInput, typename Output>
constexpr ::capnp::_::RawSchema const* EnvInstance<RestInput, Output>::RunParams::_capnpPrivate::schema;
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema::Scope EnvInstance<RestInput, Output>::RunParams::_capnpPrivate::brandScopes[] = {
  { 0xa5feedafa5ec5c4a, brandBindings + 0, 2, false},
};
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema::Binding EnvInstance<RestInput, Output>::RunParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<RestInput>(),
  ::capnp::_::brandBindingFor<Output>(),
};
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema::Dependency EnvInstance<RestInput, Output>::RunParams::_capnpPrivate::brandDependencies[] = {
  { 16777216,  ::mas::schema::model::Env<RestInput>::_capnpPrivate::brand() },
};
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema EnvInstance<RestInput, Output>::RunParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_811895634b6bd959, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE

template <typename RestInput, typename Output>
inline bool EnvInstance<RestInput, Output>::RunResults::Reader::hasResult() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename RestInput, typename Output>
inline bool EnvInstance<RestInput, Output>::RunResults::Builder::hasResult() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename RestInput, typename Output>
inline  ::capnp::ReaderFor<Output> EnvInstance<RestInput, Output>::RunResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers<Output>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename RestInput, typename Output>
inline  ::capnp::BuilderFor<Output> EnvInstance<RestInput, Output>::RunResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers<Output>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename RestInput, typename Output>
inline  ::capnp::PipelineFor<Output> EnvInstance<RestInput, Output>::RunResults::Pipeline::getResult() {
  return  ::capnp::PipelineFor<Output>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename RestInput, typename Output>
inline void EnvInstance<RestInput, Output>::RunResults::Builder::setResult( ::capnp::ReaderFor<Output> value) {
  ::capnp::_::PointerHelpers<Output>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename RestInput, typename Output>
inline  ::capnp::BuilderFor<Output> EnvInstance<RestInput, Output>::RunResults::Builder::initResult() {
  return ::capnp::_::PointerHelpers<Output>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename RestInput, typename Output>
inline  ::capnp::BuilderFor<Output> EnvInstance<RestInput, Output>::RunResults::Builder::initResult(unsigned int size) {
  return ::capnp::_::PointerHelpers<Output>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename RestInput, typename Output>
inline void EnvInstance<RestInput, Output>::RunResults::Builder::adoptResult(
    ::capnp::Orphan<Output>&& value) {
  ::capnp::_::PointerHelpers<Output>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename RestInput, typename Output>
inline ::capnp::Orphan<Output> EnvInstance<RestInput, Output>::RunResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers<Output>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// EnvInstance<RestInput, Output>::RunResults
template <typename RestInput, typename Output>
constexpr uint16_t EnvInstance<RestInput, Output>::RunResults::_capnpPrivate::dataWordSize;
template <typename RestInput, typename Output>
constexpr uint16_t EnvInstance<RestInput, Output>::RunResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename RestInput, typename Output>
constexpr ::capnp::Kind EnvInstance<RestInput, Output>::RunResults::_capnpPrivate::kind;
template <typename RestInput, typename Output>
constexpr ::capnp::_::RawSchema const* EnvInstance<RestInput, Output>::RunResults::_capnpPrivate::schema;
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema::Scope EnvInstance<RestInput, Output>::RunResults::_capnpPrivate::brandScopes[] = {
  { 0xa5feedafa5ec5c4a, brandBindings + 0, 2, false},
};
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema::Binding EnvInstance<RestInput, Output>::RunResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<RestInput>(),
  ::capnp::_::brandBindingFor<Output>(),
};
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema EnvInstance<RestInput, Output>::RunResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_a931ae5cae90ece0, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename RestInput, typename Output>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::model::EnvInstance<RestInput, Output>::RunParams, typename  ::mas::schema::model::EnvInstance<RestInput, Output>::RunResults>)
EnvInstance<RestInput, Output>::Client::runRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::model::EnvInstance<RestInput, Output>::RunParams, typename  ::mas::schema::model::EnvInstance<RestInput, Output>::RunResults>(
      0xa5feedafa5ec5c4aull, 0, sizeHint);
}
template <typename RestInput, typename Output>
::kj::Promise<void> EnvInstance<RestInput, Output>::Server::run(RunContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "model.capnp:EnvInstance", "run",
      0xa5feedafa5ec5c4aull, 0);
}
template <typename RestInput, typename Output>
::capnp::Capability::Server::DispatchCallResult EnvInstance<RestInput, Output>::Server::dispatchCall(
    uint64_t interfaceId, uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (interfaceId) {
    case 0xa5feedafa5ec5c4aull:
      return dispatchCallInternal(methodId, context);
    case 0xb2afd1cb599c48d5ull:
      return  ::mas::schema::common::Identifiable::Server::dispatchCallInternal(methodId, context);
    case 0xc1a7daa0dc36cb65ull:
      return  ::mas::schema::persistence::Persistent::Server::dispatchCallInternal(methodId, context);
    case 0xe9d1be2a6e9016e5ull:
      return  ::mas::schema::service::Stopable::Server::dispatchCallInternal(methodId, context);
    default:
      return internalUnimplemented("model.capnp:EnvInstance", interfaceId);
  }
}
template <typename RestInput, typename Output>
::capnp::Capability::Server::DispatchCallResult EnvInstance<RestInput, Output>::Server::dispatchCallInternal(
    uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (methodId) {
    case 0:
      return {
        run(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::model::EnvInstance<RestInput, Output>::RunParams, typename  ::mas::schema::model::EnvInstance<RestInput, Output>::RunResults>(context)),
        false
      };
    default:
      (void)context;
      return ::capnp::Capability::Server::internalUnimplemented(
          "model.capnp:EnvInstance",
          0xa5feedafa5ec5c4aull, methodId);
  }
}
#endif  // !CAPNP_LITE

// EnvInstance<RestInput, Output>
#if !CAPNP_LITE
template <typename RestInput, typename Output>
constexpr ::capnp::Kind EnvInstance<RestInput, Output>::_capnpPrivate::kind;
template <typename RestInput, typename Output>
constexpr ::capnp::_::RawSchema const* EnvInstance<RestInput, Output>::_capnpPrivate::schema;
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema::Scope EnvInstance<RestInput, Output>::_capnpPrivate::brandScopes[] = {
  { 0xa5feedafa5ec5c4a, brandBindings + 0, 2, false},
};
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema::Binding EnvInstance<RestInput, Output>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<RestInput>(),
  ::capnp::_::brandBindingFor<Output>(),
};
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema::Dependency EnvInstance<RestInput, Output>::_capnpPrivate::brandDependencies[] = {
  { 33554432,  ::mas::schema::model::EnvInstance<RestInput, Output>::RunParams::_capnpPrivate::brand() },
  { 50331648,  ::mas::schema::model::EnvInstance<RestInput, Output>::RunResults::_capnpPrivate::brand() },
};
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema EnvInstance<RestInput, Output>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_a5feedafa5ec5c4a, brandScopes, brandDependencies,
  1, 2, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename RestInput, typename Output>
inline EnvInstanceProxy<RestInput, Output>::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
template <typename RestInput, typename Output>
inline EnvInstanceProxy<RestInput, Output>::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename RestInput, typename Output>
template <typename _t, typename>
inline EnvInstanceProxy<RestInput, Output>::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename RestInput, typename Output>
template <typename _t, typename>
inline EnvInstanceProxy<RestInput, Output>::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
template <typename RestInput, typename Output>
inline EnvInstanceProxy<RestInput, Output>::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
template <typename RestInput, typename Output>
inline typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Client& EnvInstanceProxy<RestInput, Output>::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
template <typename RestInput, typename Output>
inline typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Client& EnvInstanceProxy<RestInput, Output>::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
#if !CAPNP_LITE
template <typename RestInput, typename Output>
inline EnvInstanceProxy<RestInput, Output>::Unregister::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
template <typename RestInput, typename Output>
inline EnvInstanceProxy<RestInput, Output>::Unregister::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename RestInput, typename Output>
template <typename _t, typename>
inline EnvInstanceProxy<RestInput, Output>::Unregister::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename RestInput, typename Output>
template <typename _t, typename>
inline EnvInstanceProxy<RestInput, Output>::Unregister::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
template <typename RestInput, typename Output>
inline EnvInstanceProxy<RestInput, Output>::Unregister::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
template <typename RestInput, typename Output>
inline typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::Client& EnvInstanceProxy<RestInput, Output>::Unregister::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
template <typename RestInput, typename Output>
inline typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::Client& EnvInstanceProxy<RestInput, Output>::Unregister::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
// EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterParams
template <typename RestInput, typename Output>
constexpr uint16_t EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterParams::_capnpPrivate::dataWordSize;
template <typename RestInput, typename Output>
constexpr uint16_t EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename RestInput, typename Output>
constexpr ::capnp::Kind EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterParams::_capnpPrivate::kind;
template <typename RestInput, typename Output>
constexpr ::capnp::_::RawSchema const* EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterParams::_capnpPrivate::schema;
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema::Scope EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterParams::_capnpPrivate::brandScopes[] = {
  { 0x87cbebfc1164a24a, brandBindings + 0, 2, false},
};
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema::Binding EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<RestInput>(),
  ::capnp::_::brandBindingFor<Output>(),
};
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_82136633e6b6d8ae, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename RestInput, typename Output>
inline bool EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterResults::Reader::getSuccess() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename RestInput, typename Output>
inline bool EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterResults::Builder::getSuccess() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename RestInput, typename Output>
inline void EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterResults::Builder::setSuccess(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

// EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterResults
template <typename RestInput, typename Output>
constexpr uint16_t EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterResults::_capnpPrivate::dataWordSize;
template <typename RestInput, typename Output>
constexpr uint16_t EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename RestInput, typename Output>
constexpr ::capnp::Kind EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterResults::_capnpPrivate::kind;
template <typename RestInput, typename Output>
constexpr ::capnp::_::RawSchema const* EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterResults::_capnpPrivate::schema;
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema::Scope EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterResults::_capnpPrivate::brandScopes[] = {
  { 0x87cbebfc1164a24a, brandBindings + 0, 2, false},
};
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema::Binding EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<RestInput>(),
  ::capnp::_::brandBindingFor<Output>(),
};
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_e91cc3866fdea82a, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename RestInput, typename Output>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterParams, typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterResults>)
EnvInstanceProxy<RestInput, Output>::Unregister::Client::unregisterRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterParams, typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterResults>(
      0xc727892bd5c66f88ull, 0, sizeHint);
}
template <typename RestInput, typename Output>
::kj::Promise<void> EnvInstanceProxy<RestInput, Output>::Unregister::Server::unregister(UnregisterContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "model.capnp:EnvInstanceProxy.Unregister", "unregister",
      0xc727892bd5c66f88ull, 0);
}
template <typename RestInput, typename Output>
::capnp::Capability::Server::DispatchCallResult EnvInstanceProxy<RestInput, Output>::Unregister::Server::dispatchCall(
    uint64_t interfaceId, uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (interfaceId) {
    case 0xc727892bd5c66f88ull:
      return dispatchCallInternal(methodId, context);
    default:
      return internalUnimplemented("model.capnp:EnvInstanceProxy.Unregister", interfaceId);
  }
}
template <typename RestInput, typename Output>
::capnp::Capability::Server::DispatchCallResult EnvInstanceProxy<RestInput, Output>::Unregister::Server::dispatchCallInternal(
    uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (methodId) {
    case 0:
      return {
        unregister(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterParams, typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterResults>(context)),
        false
      };
    default:
      (void)context;
      return ::capnp::Capability::Server::internalUnimplemented(
          "model.capnp:EnvInstanceProxy.Unregister",
          0xc727892bd5c66f88ull, methodId);
  }
}
#endif  // !CAPNP_LITE

// EnvInstanceProxy<RestInput, Output>::Unregister
#if !CAPNP_LITE
template <typename RestInput, typename Output>
constexpr ::capnp::Kind EnvInstanceProxy<RestInput, Output>::Unregister::_capnpPrivate::kind;
template <typename RestInput, typename Output>
constexpr ::capnp::_::RawSchema const* EnvInstanceProxy<RestInput, Output>::Unregister::_capnpPrivate::schema;
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema::Scope EnvInstanceProxy<RestInput, Output>::Unregister::_capnpPrivate::brandScopes[] = {
  { 0x87cbebfc1164a24a, brandBindings + 0, 2, false},
};
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema::Binding EnvInstanceProxy<RestInput, Output>::Unregister::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<RestInput>(),
  ::capnp::_::brandBindingFor<Output>(),
};
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema::Dependency EnvInstanceProxy<RestInput, Output>::Unregister::_capnpPrivate::brandDependencies[] = {
  { 33554432,  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterParams::_capnpPrivate::brand() },
  { 50331648,  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::UnregisterResults::_capnpPrivate::brand() },
};
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema EnvInstanceProxy<RestInput, Output>::Unregister::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_c727892bd5c66f88, brandScopes, brandDependencies,
  1, 2, nullptr
};
#endif  // !CAPNP_LITE

template <typename RestInput, typename Output>
inline bool EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams::Reader::hasInstance() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename RestInput, typename Output>
inline bool EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams::Builder::hasInstance() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename RestInput, typename Output>
inline typename  ::mas::schema::model::EnvInstance<RestInput, Output>::Client EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams::Reader::getInstance() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::model::EnvInstance<RestInput, Output>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename RestInput, typename Output>
inline typename  ::mas::schema::model::EnvInstance<RestInput, Output>::Client EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams::Builder::getInstance() {
  return ::capnp::_::PointerHelpers< ::mas::schema::model::EnvInstance<RestInput, Output>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename RestInput, typename Output>
inline typename  ::mas::schema::model::EnvInstance<RestInput, Output>::Client EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams::Pipeline::getInstance() {
  return typename  ::mas::schema::model::EnvInstance<RestInput, Output>::Client(_typeless.getPointerField(0).asCap());
}
template <typename RestInput, typename Output>
inline void EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams::Builder::setInstance(typename  ::mas::schema::model::EnvInstance<RestInput, Output>::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::model::EnvInstance<RestInput, Output>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
template <typename RestInput, typename Output>
inline void EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams::Builder::setInstance(typename  ::mas::schema::model::EnvInstance<RestInput, Output>::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::model::EnvInstance<RestInput, Output>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
template <typename RestInput, typename Output>
inline void EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams::Builder::adoptInstance(
    ::capnp::Orphan< ::mas::schema::model::EnvInstance<RestInput, Output>>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::model::EnvInstance<RestInput, Output>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename RestInput, typename Output>
inline ::capnp::Orphan< ::mas::schema::model::EnvInstance<RestInput, Output>> EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams::Builder::disownInstance() {
  return ::capnp::_::PointerHelpers< ::mas::schema::model::EnvInstance<RestInput, Output>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

// EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams
template <typename RestInput, typename Output>
constexpr uint16_t EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams::_capnpPrivate::dataWordSize;
template <typename RestInput, typename Output>
constexpr uint16_t EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename RestInput, typename Output>
constexpr ::capnp::Kind EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams::_capnpPrivate::kind;
template <typename RestInput, typename Output>
constexpr ::capnp::_::RawSchema const* EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams::_capnpPrivate::schema;
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema::Scope EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams::_capnpPrivate::brandScopes[] = {
  { 0x87cbebfc1164a24a, brandBindings + 0, 2, false},
};
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema::Binding EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<RestInput>(),
  ::capnp::_::brandBindingFor<Output>(),
};
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema::Dependency EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams::_capnpPrivate::brandDependencies[] = {
  { 16777216,  ::mas::schema::model::EnvInstance<RestInput, Output>::_capnpPrivate::brand() },
};
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_d10259a623f95bb4, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE

template <typename RestInput, typename Output>
inline bool EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults::Reader::hasUnregister() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename RestInput, typename Output>
inline bool EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults::Builder::hasUnregister() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename RestInput, typename Output>
inline typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::Client EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults::Reader::getUnregister() const {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename RestInput, typename Output>
inline typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::Client EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults::Builder::getUnregister() {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename RestInput, typename Output>
inline typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::Client EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults::Pipeline::getUnregister() {
  return typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::Client(_typeless.getPointerField(0).asCap());
}
template <typename RestInput, typename Output>
inline void EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults::Builder::setUnregister(typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::Client&& cap) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
template <typename RestInput, typename Output>
inline void EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults::Builder::setUnregister(typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::Client& cap) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
template <typename RestInput, typename Output>
inline void EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults::Builder::adoptUnregister(
    ::capnp::Orphan<typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister>&& value) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename RestInput, typename Output>
inline ::capnp::Orphan<typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister> EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults::Builder::disownUnregister() {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

// EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults
template <typename RestInput, typename Output>
constexpr uint16_t EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults::_capnpPrivate::dataWordSize;
template <typename RestInput, typename Output>
constexpr uint16_t EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename RestInput, typename Output>
constexpr ::capnp::Kind EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults::_capnpPrivate::kind;
template <typename RestInput, typename Output>
constexpr ::capnp::_::RawSchema const* EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults::_capnpPrivate::schema;
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema::Scope EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults::_capnpPrivate::brandScopes[] = {
  { 0x87cbebfc1164a24a, brandBindings + 0, 2, false},
};
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema::Binding EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<RestInput>(),
  ::capnp::_::brandBindingFor<Output>(),
};
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema::Dependency EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults::_capnpPrivate::brandDependencies[] = {
  { 16777216,  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::Unregister::_capnpPrivate::brand() },
};
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_df50acfa56a9674e, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename RestInput, typename Output>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams, typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults>)
EnvInstanceProxy<RestInput, Output>::Client::registerEnvInstanceRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams, typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults>(
      0x87cbebfc1164a24aull, 0, sizeHint);
}
template <typename RestInput, typename Output>
::kj::Promise<void> EnvInstanceProxy<RestInput, Output>::Server::registerEnvInstance(RegisterEnvInstanceContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "model.capnp:EnvInstanceProxy", "registerEnvInstance",
      0x87cbebfc1164a24aull, 0);
}
template <typename RestInput, typename Output>
::capnp::Capability::Server::DispatchCallResult EnvInstanceProxy<RestInput, Output>::Server::dispatchCall(
    uint64_t interfaceId, uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (interfaceId) {
    case 0x87cbebfc1164a24aull:
      return dispatchCallInternal(methodId, context);
    case 0xa5feedafa5ec5c4aull:
      return  ::mas::schema::model::EnvInstance<RestInput, Output>::Server::dispatchCallInternal(methodId, context);
    case 0xb2afd1cb599c48d5ull:
      return  ::mas::schema::common::Identifiable::Server::dispatchCallInternal(methodId, context);
    case 0xc1a7daa0dc36cb65ull:
      return  ::mas::schema::persistence::Persistent::Server::dispatchCallInternal(methodId, context);
    case 0xe9d1be2a6e9016e5ull:
      return  ::mas::schema::service::Stopable::Server::dispatchCallInternal(methodId, context);
    default:
      return internalUnimplemented("model.capnp:EnvInstanceProxy", interfaceId);
  }
}
template <typename RestInput, typename Output>
::capnp::Capability::Server::DispatchCallResult EnvInstanceProxy<RestInput, Output>::Server::dispatchCallInternal(
    uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (methodId) {
    case 0:
      return {
        registerEnvInstance(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams, typename  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults>(context)),
        false
      };
    default:
      (void)context;
      return ::capnp::Capability::Server::internalUnimplemented(
          "model.capnp:EnvInstanceProxy",
          0x87cbebfc1164a24aull, methodId);
  }
}
#endif  // !CAPNP_LITE

// EnvInstanceProxy<RestInput, Output>
#if !CAPNP_LITE
template <typename RestInput, typename Output>
constexpr ::capnp::Kind EnvInstanceProxy<RestInput, Output>::_capnpPrivate::kind;
template <typename RestInput, typename Output>
constexpr ::capnp::_::RawSchema const* EnvInstanceProxy<RestInput, Output>::_capnpPrivate::schema;
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema::Scope EnvInstanceProxy<RestInput, Output>::_capnpPrivate::brandScopes[] = {
  { 0x87cbebfc1164a24a, brandBindings + 0, 2, false},
};
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema::Binding EnvInstanceProxy<RestInput, Output>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<RestInput>(),
  ::capnp::_::brandBindingFor<Output>(),
};
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema::Dependency EnvInstanceProxy<RestInput, Output>::_capnpPrivate::brandDependencies[] = {
  { 33554432,  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceParams::_capnpPrivate::brand() },
  { 50331648,  ::mas::schema::model::EnvInstanceProxy<RestInput, Output>::RegisterEnvInstanceResults::_capnpPrivate::brand() },
  { 67108864,  ::mas::schema::model::EnvInstance<RestInput, Output>::_capnpPrivate::brand() },
};
template <typename RestInput, typename Output>
const ::capnp::_::RawBrandedSchema EnvInstanceProxy<RestInput, Output>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_87cbebfc1164a24a, brandScopes, brandDependencies,
  1, 3, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
inline InstanceFactory::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline InstanceFactory::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline InstanceFactory::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline InstanceFactory::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline InstanceFactory::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::model::InstanceFactory::Client& InstanceFactory::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::model::InstanceFactory::Client& InstanceFactory::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool InstanceFactory::NewInstanceResults::Reader::hasInstance() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool InstanceFactory::NewInstanceResults::Builder::hasInstance() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::common::Identifiable::Client InstanceFactory::NewInstanceResults::Reader::getInstance() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::Identifiable::Client InstanceFactory::NewInstanceResults::Builder::getInstance() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::Identifiable::Client InstanceFactory::NewInstanceResults::Pipeline::getInstance() {
  return  ::mas::schema::common::Identifiable::Client(_typeless.getPointerField(0).asCap());
}
inline void InstanceFactory::NewInstanceResults::Builder::setInstance( ::mas::schema::common::Identifiable::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void InstanceFactory::NewInstanceResults::Builder::setInstance( ::mas::schema::common::Identifiable::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void InstanceFactory::NewInstanceResults::Builder::adoptInstance(
    ::capnp::Orphan< ::mas::schema::common::Identifiable>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::common::Identifiable> InstanceFactory::NewInstanceResults::Builder::disownInstance() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline  ::int16_t InstanceFactory::NewInstancesParams::Reader::getNumberOfInstances() const {
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int16_t InstanceFactory::NewInstancesParams::Builder::getNumberOfInstances() {
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void InstanceFactory::NewInstancesParams::Builder::setNumberOfInstances( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool InstanceFactory::NewInstancesResults::Reader::hasInstances() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool InstanceFactory::NewInstancesResults::Builder::hasInstances() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Reader InstanceFactory::NewInstancesResults::Reader::getInstances() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Builder InstanceFactory::NewInstancesResults::Builder::getInstances() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void InstanceFactory::NewInstancesResults::Builder::setInstances( ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Builder InstanceFactory::NewInstancesResults::Builder::initInstances(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void InstanceFactory::NewInstancesResults::Builder::adoptInstances(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>> InstanceFactory::NewInstancesResults::Builder::disownInstances() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

