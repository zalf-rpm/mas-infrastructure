// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: management.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1000001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "common.capnp.h"
#include "crop.capnp.h"
#include "date.capnp.h"
#include "geo.capnp.h"
#include "persistence.capnp.h"
#include "registry.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(82a74595175b71a3);
enum class EventType_82a74595175b71a3: uint16_t {
  SOWING,
  AUTOMATIC_SOWING,
  HARVEST,
  AUTOMATIC_HARVEST,
  IRRIGATION,
  TILLAGE,
  ORGANIC_FERTILIZATION,
  MINERAL_FERTILIZATION,
  N_DEMAND_FERTILIZATION,
  CUTTING,
  SET_VALUE,
  SAVE_STATE,
};
CAPNP_DECLARE_ENUM(EventType, 82a74595175b71a3);
CAPNP_DECLARE_SCHEMA(c2d50914b83d42de);
enum class PlantOrgan_c2d50914b83d42de: uint16_t {
  ROOT,
  LEAF,
  SHOOT,
  FRUIT,
  STRUKT,
  SUGAR,
};
CAPNP_DECLARE_ENUM(PlantOrgan, c2d50914b83d42de);
CAPNP_DECLARE_SCHEMA(9c5dedfd679ac842);
CAPNP_DECLARE_SCHEMA(f082ec2d0eb50c9b);
enum class ExternalType_f082ec2d0eb50c9b: uint16_t {
  SOWING,
  AUTOMATIC_SOWING,
  HARVEST,
  AUTOMATIC_HARVEST,
  IRRIGATION,
  TILLAGE,
  ORGANIC_FERTILIZATION,
  MINERAL_FERTILIZATION,
  N_DEMAND_FERTILIZATION,
  CUTTING,
};
CAPNP_DECLARE_ENUM(ExternalType, f082ec2d0eb50c9b);
CAPNP_DECLARE_SCHEMA(8fa09457bc1bfc34);
enum class PhenoStage_8fa09457bc1bfc34: uint16_t {
  EMERGENCE,
  FLOWERING,
  ANTHESIS,
  MATURITY,
};
CAPNP_DECLARE_ENUM(PhenoStage, 8fa09457bc1bfc34);
CAPNP_DECLARE_SCHEMA(e1ed73d59c8ce359);
CAPNP_DECLARE_SCHEMA(c6c4991fe51b272f);
CAPNP_DECLARE_SCHEMA(9539b8e14ac7d5a9);
CAPNP_DECLARE_SCHEMA(c58610b90af83811);
CAPNP_DECLARE_SCHEMA(9d247c812334c917);
CAPNP_DECLARE_SCHEMA(80ce153f3bc9a9e8);
CAPNP_DECLARE_SCHEMA(cfcf44997e7ceab4);
CAPNP_DECLARE_SCHEMA(9d81d2bf4cd0f868);
CAPNP_DECLARE_SCHEMA(eed4e55bb04289ef);
CAPNP_DECLARE_SCHEMA(8f0cbec420589373);
enum class CropUsage_8f0cbec420589373: uint16_t {
  GREEN_MANURE,
  BIOMASS_PRODUCTION,
};
CAPNP_DECLARE_ENUM(CropUsage, 8f0cbec420589373);
CAPNP_DECLARE_SCHEMA(8cb6b3e3c50d3665);
CAPNP_DECLARE_SCHEMA(e3a37e340f816cd1);
CAPNP_DECLARE_SCHEMA(fec75f2ddd43431d);
CAPNP_DECLARE_SCHEMA(825bb2508c0b37b2);
enum class CL_825bb2508c0b37b2: uint16_t {
  CUT,
  LEFT,
};
CAPNP_DECLARE_ENUM(CL, 825bb2508c0b37b2);
CAPNP_DECLARE_SCHEMA(f0c763e472409ba2);
enum class Unit_f0c763e472409ba2: uint16_t {
  PERCENTAGE,
  BIOMASS,
  LAI,
};
CAPNP_DECLARE_ENUM(Unit, f0c763e472409ba2);
CAPNP_DECLARE_SCHEMA(9a221e04faf79efc);
CAPNP_DECLARE_SCHEMA(d3da30ea7b25d921);
CAPNP_DECLARE_SCHEMA(953375ac67d4f573);
CAPNP_DECLARE_SCHEMA(e98c76fb0fb0b2cd);
CAPNP_DECLARE_SCHEMA(88a5848ef8603554);
CAPNP_DECLARE_SCHEMA(87feb816363ff43c);
CAPNP_DECLARE_SCHEMA(aafe4332e17aa43e);
CAPNP_DECLARE_SCHEMA(bc6b579acf43fb6e);
enum class Name_bc6b579acf43fb6e: uint16_t {
  UREA,
  AMMONIA,
  NITRATE,
  PHOSPHORUS,
  POTASSIUM,
  SULFATE,
  ORGANIC_C,
  ORGANIC_N,
  ORGANIC_P,
  ORGANIC_N_FAST,
  ORGANIC_N_SLOW,
};
CAPNP_DECLARE_ENUM(Name, bc6b579acf43fb6e);
CAPNP_DECLARE_SCHEMA(987b68b57edbbdb6);
enum class Unit_987b68b57edbbdb6: uint16_t {
  NONE,
  FRACTION,
  PERCENT,
};
CAPNP_DECLARE_ENUM(Unit, 987b68b57edbbdb6);
CAPNP_DECLARE_SCHEMA(8c4cb8d60ae5aec7);
CAPNP_DECLARE_SCHEMA(cb5a624fdc982a1b);
CAPNP_DECLARE_SCHEMA(ae2976259bce5460);
CAPNP_DECLARE_SCHEMA(c0032af5b7bc50e4);
CAPNP_DECLARE_SCHEMA(fd4dbbbb758bb8f7);
CAPNP_DECLARE_SCHEMA(bbb7aeae0d097e05);
CAPNP_DECLARE_SCHEMA(c876b729b7d7f6d9);
CAPNP_DECLARE_SCHEMA(cca7748d367db151);

}  // namespace schemas
}  // namespace capnp

namespace mas {
namespace schema {
namespace management {

typedef ::capnp::schemas::EventType_82a74595175b71a3 EventType;

typedef ::capnp::schemas::PlantOrgan_c2d50914b83d42de PlantOrgan;

struct Event {
  Event() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    AT,
    BETWEEN,
    AFTER,
  };
  typedef ::capnp::schemas::ExternalType_f082ec2d0eb50c9b ExternalType;

  typedef ::capnp::schemas::PhenoStage_8fa09457bc1bfc34 PhenoStage;

  struct Type;
  struct At;
  struct Between;
  struct After;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9c5dedfd679ac842, 1, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Event::Type {
  Type() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    EXTERNAL,
    INTERNAL,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e1ed73d59c8ce359, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Event::At {
  At() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c6c4991fe51b272f, 1, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Event::Between {
  Between() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9539b8e14ac7d5a9, 1, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Event::After {
  After() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c58610b90af83811, 1, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Params {
  Params() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Sowing;
  struct AutomaticSowing;
  struct Harvest;
  struct AutomaticHarvest;
  struct Cutting;
  struct MineralFertilization;
  struct NDemandFertilization;
  struct OrganicFertilization;
  struct Tillage;
  struct Irrigation;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9d247c812334c917, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Params::Sowing {
  Sowing() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(80ce153f3bc9a9e8, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Params::AutomaticSowing {
  AutomaticSowing() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct AvgSoilTemp;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cfcf44997e7ceab4, 8, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Params::AutomaticSowing::AvgSoilTemp {
  AvgSoilTemp() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9d81d2bf4cd0f868, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Params::Harvest {
  Harvest() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::CropUsage_8f0cbec420589373 CropUsage;

  struct OptCarbonMgmtData;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(eed4e55bb04289ef, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Params::Harvest::OptCarbonMgmtData {
  OptCarbonMgmtData() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8cb6b3e3c50d3665, 5, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Params::AutomaticHarvest {
  AutomaticHarvest() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e3a37e340f816cd1, 5, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Params::Cutting {
  Cutting() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::CL_825bb2508c0b37b2 CL;

  typedef ::capnp::schemas::Unit_f0c763e472409ba2 Unit;

  struct Spec;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fec75f2ddd43431d, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Params::Cutting::Spec {
  Spec() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9a221e04faf79efc, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Params::MineralFertilization {
  MineralFertilization() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d3da30ea7b25d921, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Params::NDemandFertilization {
  NDemandFertilization() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(953375ac67d4f573, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Params::OrganicFertilization {
  OrganicFertilization() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e98c76fb0fb0b2cd, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Params::Tillage {
  Tillage() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(88a5848ef8603554, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Params::Irrigation {
  Irrigation() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(87feb816363ff43c, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Nutrient {
  Nutrient() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::Name_bc6b579acf43fb6e Name;

  typedef ::capnp::schemas::Unit_987b68b57edbbdb6 Unit;


  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(aafe4332e17aa43e, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Fertilizer {
  Fertilizer() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct NutrientsParams;
  struct NutrientsResults;
  struct ParametersParams;
  struct ParametersResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(8c4cb8d60ae5aec7)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Fertilizer::NutrientsParams {
  NutrientsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cb5a624fdc982a1b, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Fertilizer::NutrientsResults {
  NutrientsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ae2976259bce5460, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Fertilizer::ParametersParams {
  ParametersParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c0032af5b7bc50e4, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Fertilizer::ParametersResults {
  ParametersResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fd4dbbbb758bb8f7, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct FertilizerService {
  FertilizerService() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE


  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(bbb7aeae0d097e05)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Service {
  Service() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct ManagementAtResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(c876b729b7d7f6d9)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Service::ManagementAtResults {
  ManagementAtResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cca7748d367db151, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Event::Reader {
public:
  typedef Event Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline  ::mas::schema::management::Event::ExternalType getType() const;

  inline bool hasInfo() const;
  inline  ::mas::schema::common::IdInformation::Reader getInfo() const;

  inline bool isAt() const;
  inline typename At::Reader getAt() const;

  inline bool isBetween() const;
  inline typename Between::Reader getBetween() const;

  inline bool isAfter() const;
  inline typename After::Reader getAfter() const;

  inline bool hasParams() const;
  inline ::capnp::AnyPointer::Reader getParams() const;

  inline bool getRunAtStartOfDay() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Event::Builder {
public:
  typedef Event Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline  ::mas::schema::management::Event::ExternalType getType();
  inline void setType( ::mas::schema::management::Event::ExternalType value);

  inline bool hasInfo();
  inline  ::mas::schema::common::IdInformation::Builder getInfo();
  inline void setInfo( ::mas::schema::common::IdInformation::Reader value);
  inline  ::mas::schema::common::IdInformation::Builder initInfo();
  inline void adoptInfo(::capnp::Orphan< ::mas::schema::common::IdInformation>&& value);
  inline ::capnp::Orphan< ::mas::schema::common::IdInformation> disownInfo();

  inline bool isAt();
  inline typename At::Builder getAt();
  inline typename At::Builder initAt();

  inline bool isBetween();
  inline typename Between::Builder getBetween();
  inline typename Between::Builder initBetween();

  inline bool isAfter();
  inline typename After::Builder getAfter();
  inline typename After::Builder initAfter();

  inline bool hasParams();
  inline ::capnp::AnyPointer::Builder getParams();
  inline ::capnp::AnyPointer::Builder initParams();

  inline bool getRunAtStartOfDay();
  inline void setRunAtStartOfDay(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Event::Pipeline {
public:
  typedef Event Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::common::IdInformation::Pipeline getInfo();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Event::Type::Reader {
public:
  typedef Type Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isExternal() const;
  inline  ::mas::schema::management::Event::ExternalType getExternal() const;

  inline bool isInternal() const;
  inline  ::mas::schema::management::Event::PhenoStage getInternal() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Event::Type::Builder {
public:
  typedef Type Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isExternal();
  inline  ::mas::schema::management::Event::ExternalType getExternal();
  inline void setExternal( ::mas::schema::management::Event::ExternalType value);

  inline bool isInternal();
  inline  ::mas::schema::management::Event::PhenoStage getInternal();
  inline void setInternal( ::mas::schema::management::Event::PhenoStage value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Event::Type::Pipeline {
public:
  typedef Type Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Event::At::Reader {
public:
  typedef At Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasDate() const;
  inline  ::mas::schema::common::Date::Reader getDate() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Event::At::Builder {
public:
  typedef At Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasDate();
  inline  ::mas::schema::common::Date::Builder getDate();
  inline void setDate( ::mas::schema::common::Date::Reader value);
  inline  ::mas::schema::common::Date::Builder initDate();
  inline void adoptDate(::capnp::Orphan< ::mas::schema::common::Date>&& value);
  inline ::capnp::Orphan< ::mas::schema::common::Date> disownDate();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Event::At::Pipeline {
public:
  typedef At Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::common::Date::Pipeline getDate();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Event::Between::Reader {
public:
  typedef Between Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasEarliest() const;
  inline  ::mas::schema::common::Date::Reader getEarliest() const;

  inline bool hasLatest() const;
  inline  ::mas::schema::common::Date::Reader getLatest() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Event::Between::Builder {
public:
  typedef Between Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasEarliest();
  inline  ::mas::schema::common::Date::Builder getEarliest();
  inline void setEarliest( ::mas::schema::common::Date::Reader value);
  inline  ::mas::schema::common::Date::Builder initEarliest();
  inline void adoptEarliest(::capnp::Orphan< ::mas::schema::common::Date>&& value);
  inline ::capnp::Orphan< ::mas::schema::common::Date> disownEarliest();

  inline bool hasLatest();
  inline  ::mas::schema::common::Date::Builder getLatest();
  inline void setLatest( ::mas::schema::common::Date::Reader value);
  inline  ::mas::schema::common::Date::Builder initLatest();
  inline void adoptLatest(::capnp::Orphan< ::mas::schema::common::Date>&& value);
  inline ::capnp::Orphan< ::mas::schema::common::Date> disownLatest();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Event::Between::Pipeline {
public:
  typedef Between Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::common::Date::Pipeline getEarliest();
  inline  ::mas::schema::common::Date::Pipeline getLatest();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Event::After::Reader {
public:
  typedef After Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasEvent() const;
  inline  ::mas::schema::management::Event::Type::Reader getEvent() const;

  inline  ::uint16_t getDays() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Event::After::Builder {
public:
  typedef After Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasEvent();
  inline  ::mas::schema::management::Event::Type::Builder getEvent();
  inline void setEvent( ::mas::schema::management::Event::Type::Reader value);
  inline  ::mas::schema::management::Event::Type::Builder initEvent();
  inline void adoptEvent(::capnp::Orphan< ::mas::schema::management::Event::Type>&& value);
  inline ::capnp::Orphan< ::mas::schema::management::Event::Type> disownEvent();

  inline  ::uint16_t getDays();
  inline void setDays( ::uint16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Event::After::Pipeline {
public:
  typedef After Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::management::Event::Type::Pipeline getEvent();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Params::Reader {
public:
  typedef Params Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Params::Builder {
public:
  typedef Params Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Params::Pipeline {
public:
  typedef Params Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Params::Sowing::Reader {
public:
  typedef Sowing Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCultivar() const;
  inline  ::capnp::Text::Reader getCultivar() const;

  inline  ::uint16_t getPlantDensity() const;

  inline bool hasCrop() const;
#if !CAPNP_LITE
  inline  ::mas::schema::crop::Crop::Client getCrop() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Params::Sowing::Builder {
public:
  typedef Sowing Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCultivar();
  inline  ::capnp::Text::Builder getCultivar();
  inline void setCultivar( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initCultivar(unsigned int size);
  inline void adoptCultivar(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownCultivar();

  inline  ::uint16_t getPlantDensity();
  inline void setPlantDensity( ::uint16_t value);

  inline bool hasCrop();
#if !CAPNP_LITE
  inline  ::mas::schema::crop::Crop::Client getCrop();
  inline void setCrop( ::mas::schema::crop::Crop::Client&& value);
  inline void setCrop( ::mas::schema::crop::Crop::Client& value);
  inline void adoptCrop(::capnp::Orphan< ::mas::schema::crop::Crop>&& value);
  inline ::capnp::Orphan< ::mas::schema::crop::Crop> disownCrop();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Params::Sowing::Pipeline {
public:
  typedef Sowing Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::crop::Crop::Client getCrop();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Params::AutomaticSowing::Reader {
public:
  typedef AutomaticSowing Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getMinTempThreshold() const;

  inline  ::uint16_t getDaysInTempWindow() const;

  inline double getMinPercentASW() const;

  inline double getMaxPercentASW() const;

  inline double getMax3dayPrecipSum() const;

  inline double getMaxCurrentDayPrecipSum() const;

  inline double getTempSumAboveBaseTemp() const;

  inline double getBaseTemp() const;

  inline bool hasAvgSoilTemp() const;
  inline  ::mas::schema::management::Params::AutomaticSowing::AvgSoilTemp::Reader getAvgSoilTemp() const;

  inline bool hasSowing() const;
  inline  ::mas::schema::management::Params::Sowing::Reader getSowing() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Params::AutomaticSowing::Builder {
public:
  typedef AutomaticSowing Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getMinTempThreshold();
  inline void setMinTempThreshold(double value);

  inline  ::uint16_t getDaysInTempWindow();
  inline void setDaysInTempWindow( ::uint16_t value);

  inline double getMinPercentASW();
  inline void setMinPercentASW(double value);

  inline double getMaxPercentASW();
  inline void setMaxPercentASW(double value);

  inline double getMax3dayPrecipSum();
  inline void setMax3dayPrecipSum(double value);

  inline double getMaxCurrentDayPrecipSum();
  inline void setMaxCurrentDayPrecipSum(double value);

  inline double getTempSumAboveBaseTemp();
  inline void setTempSumAboveBaseTemp(double value);

  inline double getBaseTemp();
  inline void setBaseTemp(double value);

  inline bool hasAvgSoilTemp();
  inline  ::mas::schema::management::Params::AutomaticSowing::AvgSoilTemp::Builder getAvgSoilTemp();
  inline void setAvgSoilTemp( ::mas::schema::management::Params::AutomaticSowing::AvgSoilTemp::Reader value);
  inline  ::mas::schema::management::Params::AutomaticSowing::AvgSoilTemp::Builder initAvgSoilTemp();
  inline void adoptAvgSoilTemp(::capnp::Orphan< ::mas::schema::management::Params::AutomaticSowing::AvgSoilTemp>&& value);
  inline ::capnp::Orphan< ::mas::schema::management::Params::AutomaticSowing::AvgSoilTemp> disownAvgSoilTemp();

  inline bool hasSowing();
  inline  ::mas::schema::management::Params::Sowing::Builder getSowing();
  inline void setSowing( ::mas::schema::management::Params::Sowing::Reader value);
  inline  ::mas::schema::management::Params::Sowing::Builder initSowing();
  inline void adoptSowing(::capnp::Orphan< ::mas::schema::management::Params::Sowing>&& value);
  inline ::capnp::Orphan< ::mas::schema::management::Params::Sowing> disownSowing();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Params::AutomaticSowing::Pipeline {
public:
  typedef AutomaticSowing Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::management::Params::AutomaticSowing::AvgSoilTemp::Pipeline getAvgSoilTemp();
  inline  ::mas::schema::management::Params::Sowing::Pipeline getSowing();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Params::AutomaticSowing::AvgSoilTemp::Reader {
public:
  typedef AvgSoilTemp Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getSoilDepthForAveraging() const;

  inline  ::uint16_t getDaysInSoilTempWindow() const;

  inline double getSowingIfAboveAvgSoilTemp() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Params::AutomaticSowing::AvgSoilTemp::Builder {
public:
  typedef AvgSoilTemp Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getSoilDepthForAveraging();
  inline void setSoilDepthForAveraging(double value);

  inline  ::uint16_t getDaysInSoilTempWindow();
  inline void setDaysInSoilTempWindow( ::uint16_t value);

  inline double getSowingIfAboveAvgSoilTemp();
  inline void setSowingIfAboveAvgSoilTemp(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Params::AutomaticSowing::AvgSoilTemp::Pipeline {
public:
  typedef AvgSoilTemp Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Params::Harvest::Reader {
public:
  typedef Harvest Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getExported() const;

  inline bool hasOptCarbMgmtData() const;
  inline  ::mas::schema::management::Params::Harvest::OptCarbonMgmtData::Reader getOptCarbMgmtData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Params::Harvest::Builder {
public:
  typedef Harvest Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getExported();
  inline void setExported(bool value);

  inline bool hasOptCarbMgmtData();
  inline  ::mas::schema::management::Params::Harvest::OptCarbonMgmtData::Builder getOptCarbMgmtData();
  inline void setOptCarbMgmtData( ::mas::schema::management::Params::Harvest::OptCarbonMgmtData::Reader value);
  inline  ::mas::schema::management::Params::Harvest::OptCarbonMgmtData::Builder initOptCarbMgmtData();
  inline void adoptOptCarbMgmtData(::capnp::Orphan< ::mas::schema::management::Params::Harvest::OptCarbonMgmtData>&& value);
  inline ::capnp::Orphan< ::mas::schema::management::Params::Harvest::OptCarbonMgmtData> disownOptCarbMgmtData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Params::Harvest::Pipeline {
public:
  typedef Harvest Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::management::Params::Harvest::OptCarbonMgmtData::Pipeline getOptCarbMgmtData();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Params::Harvest::OptCarbonMgmtData::Reader {
public:
  typedef OptCarbonMgmtData Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getOptCarbonConservation() const;

  inline double getCropImpactOnHumusBalance() const;

  inline  ::mas::schema::management::Params::Harvest::CropUsage getCropUsage() const;

  inline double getResidueHeq() const;

  inline double getOrganicFertilizerHeq() const;

  inline double getMaxResidueRecoverFraction() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Params::Harvest::OptCarbonMgmtData::Builder {
public:
  typedef OptCarbonMgmtData Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getOptCarbonConservation();
  inline void setOptCarbonConservation(bool value);

  inline double getCropImpactOnHumusBalance();
  inline void setCropImpactOnHumusBalance(double value);

  inline  ::mas::schema::management::Params::Harvest::CropUsage getCropUsage();
  inline void setCropUsage( ::mas::schema::management::Params::Harvest::CropUsage value);

  inline double getResidueHeq();
  inline void setResidueHeq(double value);

  inline double getOrganicFertilizerHeq();
  inline void setOrganicFertilizerHeq(double value);

  inline double getMaxResidueRecoverFraction();
  inline void setMaxResidueRecoverFraction(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Params::Harvest::OptCarbonMgmtData::Pipeline {
public:
  typedef OptCarbonMgmtData Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Params::AutomaticHarvest::Reader {
public:
  typedef AutomaticHarvest Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getMinPercentASW() const;

  inline double getMaxPercentASW() const;

  inline double getMax3dayPrecipSum() const;

  inline double getMaxCurrentDayPrecipSum() const;

  inline  ::mas::schema::management::Event::PhenoStage getHarvestTime() const;

  inline bool hasHarvest() const;
  inline  ::mas::schema::management::Params::Harvest::Reader getHarvest() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Params::AutomaticHarvest::Builder {
public:
  typedef AutomaticHarvest Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getMinPercentASW();
  inline void setMinPercentASW(double value);

  inline double getMaxPercentASW();
  inline void setMaxPercentASW(double value);

  inline double getMax3dayPrecipSum();
  inline void setMax3dayPrecipSum(double value);

  inline double getMaxCurrentDayPrecipSum();
  inline void setMaxCurrentDayPrecipSum(double value);

  inline  ::mas::schema::management::Event::PhenoStage getHarvestTime();
  inline void setHarvestTime( ::mas::schema::management::Event::PhenoStage value);

  inline bool hasHarvest();
  inline  ::mas::schema::management::Params::Harvest::Builder getHarvest();
  inline void setHarvest( ::mas::schema::management::Params::Harvest::Reader value);
  inline  ::mas::schema::management::Params::Harvest::Builder initHarvest();
  inline void adoptHarvest(::capnp::Orphan< ::mas::schema::management::Params::Harvest>&& value);
  inline ::capnp::Orphan< ::mas::schema::management::Params::Harvest> disownHarvest();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Params::AutomaticHarvest::Pipeline {
public:
  typedef AutomaticHarvest Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::management::Params::Harvest::Pipeline getHarvest();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Params::Cutting::Reader {
public:
  typedef Cutting Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCuttingSpec() const;
  inline  ::capnp::List< ::mas::schema::management::Params::Cutting::Spec,  ::capnp::Kind::STRUCT>::Reader getCuttingSpec() const;

  inline double getCutMaxAssimilationRatePercentage() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Params::Cutting::Builder {
public:
  typedef Cutting Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCuttingSpec();
  inline  ::capnp::List< ::mas::schema::management::Params::Cutting::Spec,  ::capnp::Kind::STRUCT>::Builder getCuttingSpec();
  inline void setCuttingSpec( ::capnp::List< ::mas::schema::management::Params::Cutting::Spec,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::management::Params::Cutting::Spec,  ::capnp::Kind::STRUCT>::Builder initCuttingSpec(unsigned int size);
  inline void adoptCuttingSpec(::capnp::Orphan< ::capnp::List< ::mas::schema::management::Params::Cutting::Spec,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::management::Params::Cutting::Spec,  ::capnp::Kind::STRUCT>> disownCuttingSpec();

  inline double getCutMaxAssimilationRatePercentage();
  inline void setCutMaxAssimilationRatePercentage(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Params::Cutting::Pipeline {
public:
  typedef Cutting Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Params::Cutting::Spec::Reader {
public:
  typedef Spec Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::mas::schema::management::PlantOrgan getOrgan() const;

  inline double getValue() const;

  inline  ::mas::schema::management::Params::Cutting::Unit getUnit() const;

  inline  ::mas::schema::management::Params::Cutting::CL getCutOrLeft() const;

  inline double getExportPercentage() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Params::Cutting::Spec::Builder {
public:
  typedef Spec Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::mas::schema::management::PlantOrgan getOrgan();
  inline void setOrgan( ::mas::schema::management::PlantOrgan value);

  inline double getValue();
  inline void setValue(double value);

  inline  ::mas::schema::management::Params::Cutting::Unit getUnit();
  inline void setUnit( ::mas::schema::management::Params::Cutting::Unit value);

  inline  ::mas::schema::management::Params::Cutting::CL getCutOrLeft();
  inline void setCutOrLeft( ::mas::schema::management::Params::Cutting::CL value);

  inline double getExportPercentage();
  inline void setExportPercentage(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Params::Cutting::Spec::Pipeline {
public:
  typedef Spec Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Params::MineralFertilization::Reader {
public:
  typedef MineralFertilization Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasFertilizer() const;
#if !CAPNP_LITE
  inline  ::mas::schema::management::Fertilizer::Client getFertilizer() const;
#endif  // !CAPNP_LITE

  inline double getAmount() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Params::MineralFertilization::Builder {
public:
  typedef MineralFertilization Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasFertilizer();
#if !CAPNP_LITE
  inline  ::mas::schema::management::Fertilizer::Client getFertilizer();
  inline void setFertilizer( ::mas::schema::management::Fertilizer::Client&& value);
  inline void setFertilizer( ::mas::schema::management::Fertilizer::Client& value);
  inline void adoptFertilizer(::capnp::Orphan< ::mas::schema::management::Fertilizer>&& value);
  inline ::capnp::Orphan< ::mas::schema::management::Fertilizer> disownFertilizer();
#endif  // !CAPNP_LITE

  inline double getAmount();
  inline void setAmount(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Params::MineralFertilization::Pipeline {
public:
  typedef MineralFertilization Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::management::Fertilizer::Client getFertilizer();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Params::NDemandFertilization::Reader {
public:
  typedef NDemandFertilization Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getNDemand() const;

  inline bool hasFertilizer() const;
#if !CAPNP_LITE
  inline  ::mas::schema::management::Fertilizer::Client getFertilizer() const;
#endif  // !CAPNP_LITE

  inline double getDepth() const;

  inline  ::uint8_t getStage() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Params::NDemandFertilization::Builder {
public:
  typedef NDemandFertilization Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getNDemand();
  inline void setNDemand(double value);

  inline bool hasFertilizer();
#if !CAPNP_LITE
  inline  ::mas::schema::management::Fertilizer::Client getFertilizer();
  inline void setFertilizer( ::mas::schema::management::Fertilizer::Client&& value);
  inline void setFertilizer( ::mas::schema::management::Fertilizer::Client& value);
  inline void adoptFertilizer(::capnp::Orphan< ::mas::schema::management::Fertilizer>&& value);
  inline ::capnp::Orphan< ::mas::schema::management::Fertilizer> disownFertilizer();
#endif  // !CAPNP_LITE

  inline double getDepth();
  inline void setDepth(double value);

  inline  ::uint8_t getStage();
  inline void setStage( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Params::NDemandFertilization::Pipeline {
public:
  typedef NDemandFertilization Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::management::Fertilizer::Client getFertilizer();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Params::OrganicFertilization::Reader {
public:
  typedef OrganicFertilization Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasFertilizer() const;
#if !CAPNP_LITE
  inline  ::mas::schema::management::Fertilizer::Client getFertilizer() const;
#endif  // !CAPNP_LITE

  inline double getAmount() const;

  inline bool getIncorporation() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Params::OrganicFertilization::Builder {
public:
  typedef OrganicFertilization Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasFertilizer();
#if !CAPNP_LITE
  inline  ::mas::schema::management::Fertilizer::Client getFertilizer();
  inline void setFertilizer( ::mas::schema::management::Fertilizer::Client&& value);
  inline void setFertilizer( ::mas::schema::management::Fertilizer::Client& value);
  inline void adoptFertilizer(::capnp::Orphan< ::mas::schema::management::Fertilizer>&& value);
  inline ::capnp::Orphan< ::mas::schema::management::Fertilizer> disownFertilizer();
#endif  // !CAPNP_LITE

  inline double getAmount();
  inline void setAmount(double value);

  inline bool getIncorporation();
  inline void setIncorporation(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Params::OrganicFertilization::Pipeline {
public:
  typedef OrganicFertilization Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::management::Fertilizer::Client getFertilizer();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Params::Tillage::Reader {
public:
  typedef Tillage Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getDepth() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Params::Tillage::Builder {
public:
  typedef Tillage Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getDepth();
  inline void setDepth(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Params::Tillage::Pipeline {
public:
  typedef Tillage Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Params::Irrigation::Reader {
public:
  typedef Irrigation Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getAmount() const;

  inline bool hasNutrientConcentrations() const;
  inline  ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>::Reader getNutrientConcentrations() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Params::Irrigation::Builder {
public:
  typedef Irrigation Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getAmount();
  inline void setAmount(double value);

  inline bool hasNutrientConcentrations();
  inline  ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>::Builder getNutrientConcentrations();
  inline void setNutrientConcentrations( ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>::Builder initNutrientConcentrations(unsigned int size);
  inline void adoptNutrientConcentrations(::capnp::Orphan< ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>> disownNutrientConcentrations();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Params::Irrigation::Pipeline {
public:
  typedef Irrigation Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Nutrient::Reader {
public:
  typedef Nutrient Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::mas::schema::management::Nutrient::Name getNutrient() const;

  inline double getValue() const;

  inline  ::mas::schema::management::Nutrient::Unit getUnit() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Nutrient::Builder {
public:
  typedef Nutrient Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::mas::schema::management::Nutrient::Name getNutrient();
  inline void setNutrient( ::mas::schema::management::Nutrient::Name value);

  inline double getValue();
  inline void setValue(double value);

  inline  ::mas::schema::management::Nutrient::Unit getUnit();
  inline void setUnit( ::mas::schema::management::Nutrient::Unit value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Nutrient::Pipeline {
public:
  typedef Nutrient Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Fertilizer::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client,
      public virtual  ::mas::schema::persistence::Persistent::Client {
public:
  typedef Fertilizer Calls;
  typedef Fertilizer Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::management::Fertilizer::NutrientsParams,  ::mas::schema::management::Fertilizer::NutrientsResults> nutrientsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::management::Fertilizer::ParametersParams,  ::mas::schema::management::Fertilizer::ParametersResults> parametersRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Fertilizer::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server,
      public virtual  ::mas::schema::persistence::Persistent::Server {
public:
  typedef Fertilizer Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::management::Fertilizer::NutrientsParams NutrientsParams;
  typedef  ::mas::schema::management::Fertilizer::NutrientsResults NutrientsResults;
  typedef ::capnp::CallContext<NutrientsParams, NutrientsResults> NutrientsContext;
  virtual ::kj::Promise<void> nutrients(NutrientsContext context);
  typedef  ::mas::schema::management::Fertilizer::ParametersParams ParametersParams;
  typedef  ::mas::schema::management::Fertilizer::ParametersResults ParametersResults;
  typedef ::capnp::CallContext<ParametersParams, ParametersResults> ParametersContext;
  virtual ::kj::Promise<void> parameters(ParametersContext context);

  inline  ::mas::schema::management::Fertilizer::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::management::Fertilizer>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Fertilizer::NutrientsParams::Reader {
public:
  typedef NutrientsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Fertilizer::NutrientsParams::Builder {
public:
  typedef NutrientsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Fertilizer::NutrientsParams::Pipeline {
public:
  typedef NutrientsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Fertilizer::NutrientsResults::Reader {
public:
  typedef NutrientsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasNutrients() const;
  inline  ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>::Reader getNutrients() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Fertilizer::NutrientsResults::Builder {
public:
  typedef NutrientsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasNutrients();
  inline  ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>::Builder getNutrients();
  inline void setNutrients( ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>::Builder initNutrients(unsigned int size);
  inline void adoptNutrients(::capnp::Orphan< ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>> disownNutrients();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Fertilizer::NutrientsResults::Pipeline {
public:
  typedef NutrientsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Fertilizer::ParametersParams::Reader {
public:
  typedef ParametersParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Fertilizer::ParametersParams::Builder {
public:
  typedef ParametersParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Fertilizer::ParametersParams::Pipeline {
public:
  typedef ParametersParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Fertilizer::ParametersResults::Reader {
public:
  typedef ParametersResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasParams() const;
  inline ::capnp::AnyPointer::Reader getParams() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Fertilizer::ParametersResults::Builder {
public:
  typedef ParametersResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasParams();
  inline ::capnp::AnyPointer::Builder getParams();
  inline ::capnp::AnyPointer::Builder initParams();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Fertilizer::ParametersResults::Pipeline {
public:
  typedef ParametersResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class FertilizerService::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::registry::Registry::Client {
public:
  typedef FertilizerService Calls;
  typedef FertilizerService Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);


protected:
  Client() = default;
};

class FertilizerService::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::registry::Registry::Server {
public:
  typedef FertilizerService Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:

  inline  ::mas::schema::management::FertilizerService::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::management::FertilizerService>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Service::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client {
public:
  typedef Service Calls;
  typedef Service Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::geo::LatLonCoord,  ::mas::schema::management::Service::ManagementAtResults> managementAtRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Service::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server {
public:
  typedef Service Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::management::Service::ManagementAtResults ManagementAtResults;
  typedef ::capnp::CallContext< ::mas::schema::geo::LatLonCoord, ManagementAtResults> ManagementAtContext;
  virtual ::kj::Promise<void> managementAt(ManagementAtContext context);

  inline  ::mas::schema::management::Service::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::management::Service>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Service::ManagementAtResults::Reader {
public:
  typedef ManagementAtResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasMgmt() const;
  inline  ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>::Reader getMgmt() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Service::ManagementAtResults::Builder {
public:
  typedef ManagementAtResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMgmt();
  inline  ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>::Builder getMgmt();
  inline void setMgmt( ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>::Builder initMgmt(unsigned int size);
  inline void adoptMgmt(::capnp::Orphan< ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>> disownMgmt();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Service::ManagementAtResults::Pipeline {
public:
  typedef ManagementAtResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::mas::schema::management::Event::Which Event::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline  ::mas::schema::management::Event::Which Event::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::management::Event::ExternalType Event::Reader::getType() const {
  return _reader.getDataField< ::mas::schema::management::Event::ExternalType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::management::Event::ExternalType Event::Builder::getType() {
  return _builder.getDataField< ::mas::schema::management::Event::ExternalType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Event::Builder::setType( ::mas::schema::management::Event::ExternalType value) {
  _builder.setDataField< ::mas::schema::management::Event::ExternalType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Event::Reader::hasInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Event::Builder::hasInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::common::IdInformation::Reader Event::Reader::getInfo() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::IdInformation::Builder Event::Builder::getInfo() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::common::IdInformation::Pipeline Event::Pipeline::getInfo() {
  return  ::mas::schema::common::IdInformation::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Event::Builder::setInfo( ::mas::schema::common::IdInformation::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::common::IdInformation::Builder Event::Builder::initInfo() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Event::Builder::adoptInfo(
    ::capnp::Orphan< ::mas::schema::common::IdInformation>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::common::IdInformation> Event::Builder::disownInfo() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Event::Reader::isAt() const {
  return which() == Event::AT;
}
inline bool Event::Builder::isAt() {
  return which() == Event::AT;
}
inline typename Event::At::Reader Event::Reader::getAt() const {
  KJ_IREQUIRE((which() == Event::AT),
              "Must check which() before get()ing a union member.");
  return typename Event::At::Reader(_reader);
}
inline typename Event::At::Builder Event::Builder::getAt() {
  KJ_IREQUIRE((which() == Event::AT),
              "Must check which() before get()ing a union member.");
  return typename Event::At::Builder(_builder);
}
inline typename Event::At::Builder Event::Builder::initAt() {
  _builder.setDataField<Event::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Event::AT);
  _builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS).clear();
  return typename Event::At::Builder(_builder);
}
inline bool Event::Reader::isBetween() const {
  return which() == Event::BETWEEN;
}
inline bool Event::Builder::isBetween() {
  return which() == Event::BETWEEN;
}
inline typename Event::Between::Reader Event::Reader::getBetween() const {
  KJ_IREQUIRE((which() == Event::BETWEEN),
              "Must check which() before get()ing a union member.");
  return typename Event::Between::Reader(_reader);
}
inline typename Event::Between::Builder Event::Builder::getBetween() {
  KJ_IREQUIRE((which() == Event::BETWEEN),
              "Must check which() before get()ing a union member.");
  return typename Event::Between::Builder(_builder);
}
inline typename Event::Between::Builder Event::Builder::initBetween() {
  _builder.setDataField<Event::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Event::BETWEEN);
  _builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS).clear();
  _builder.getPointerField(::capnp::bounded<2>() * ::capnp::POINTERS).clear();
  return typename Event::Between::Builder(_builder);
}
inline bool Event::Reader::isAfter() const {
  return which() == Event::AFTER;
}
inline bool Event::Builder::isAfter() {
  return which() == Event::AFTER;
}
inline typename Event::After::Reader Event::Reader::getAfter() const {
  KJ_IREQUIRE((which() == Event::AFTER),
              "Must check which() before get()ing a union member.");
  return typename Event::After::Reader(_reader);
}
inline typename Event::After::Builder Event::Builder::getAfter() {
  KJ_IREQUIRE((which() == Event::AFTER),
              "Must check which() before get()ing a union member.");
  return typename Event::After::Builder(_builder);
}
inline typename Event::After::Builder Event::Builder::initAfter() {
  _builder.setDataField<Event::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Event::AFTER);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<2>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS).clear();
  return typename Event::After::Builder(_builder);
}
inline bool Event::Reader::hasParams() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Event::Builder::hasParams() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline ::capnp::AnyPointer::Reader Event::Reader::getParams() const {
  return ::capnp::AnyPointer::Reader(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder Event::Builder::getParams() {
  return ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder Event::Builder::initParams() {
  auto result = ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
  result.clear();
  return result;
}

inline bool Event::Reader::getRunAtStartOfDay() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<48>() * ::capnp::ELEMENTS);
}

inline bool Event::Builder::getRunAtStartOfDay() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<48>() * ::capnp::ELEMENTS);
}
inline void Event::Builder::setRunAtStartOfDay(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<48>() * ::capnp::ELEMENTS, value);
}

inline  ::mas::schema::management::Event::Type::Which Event::Type::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline  ::mas::schema::management::Event::Type::Which Event::Type::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool Event::Type::Reader::isExternal() const {
  return which() == Event::Type::EXTERNAL;
}
inline bool Event::Type::Builder::isExternal() {
  return which() == Event::Type::EXTERNAL;
}
inline  ::mas::schema::management::Event::ExternalType Event::Type::Reader::getExternal() const {
  KJ_IREQUIRE((which() == Event::Type::EXTERNAL),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::mas::schema::management::Event::ExternalType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::management::Event::ExternalType Event::Type::Builder::getExternal() {
  KJ_IREQUIRE((which() == Event::Type::EXTERNAL),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::mas::schema::management::Event::ExternalType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Event::Type::Builder::setExternal( ::mas::schema::management::Event::ExternalType value) {
  _builder.setDataField<Event::Type::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Event::Type::EXTERNAL);
  _builder.setDataField< ::mas::schema::management::Event::ExternalType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Event::Type::Reader::isInternal() const {
  return which() == Event::Type::INTERNAL;
}
inline bool Event::Type::Builder::isInternal() {
  return which() == Event::Type::INTERNAL;
}
inline  ::mas::schema::management::Event::PhenoStage Event::Type::Reader::getInternal() const {
  KJ_IREQUIRE((which() == Event::Type::INTERNAL),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::mas::schema::management::Event::PhenoStage>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::management::Event::PhenoStage Event::Type::Builder::getInternal() {
  KJ_IREQUIRE((which() == Event::Type::INTERNAL),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::mas::schema::management::Event::PhenoStage>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Event::Type::Builder::setInternal( ::mas::schema::management::Event::PhenoStage value) {
  _builder.setDataField<Event::Type::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Event::Type::INTERNAL);
  _builder.setDataField< ::mas::schema::management::Event::PhenoStage>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Event::At::Reader::hasDate() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Event::At::Builder::hasDate() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::common::Date::Reader Event::At::Reader::getDate() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::Date::Builder Event::At::Builder::getDate() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::common::Date::Pipeline Event::At::Pipeline::getDate() {
  return  ::mas::schema::common::Date::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Event::At::Builder::setDate( ::mas::schema::common::Date::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::common::Date::Builder Event::At::Builder::initDate() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Event::At::Builder::adoptDate(
    ::capnp::Orphan< ::mas::schema::common::Date>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::common::Date> Event::At::Builder::disownDate() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Event::Between::Reader::hasEarliest() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Event::Between::Builder::hasEarliest() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::common::Date::Reader Event::Between::Reader::getEarliest() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::Date::Builder Event::Between::Builder::getEarliest() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::common::Date::Pipeline Event::Between::Pipeline::getEarliest() {
  return  ::mas::schema::common::Date::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Event::Between::Builder::setEarliest( ::mas::schema::common::Date::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::common::Date::Builder Event::Between::Builder::initEarliest() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Event::Between::Builder::adoptEarliest(
    ::capnp::Orphan< ::mas::schema::common::Date>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::common::Date> Event::Between::Builder::disownEarliest() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Event::Between::Reader::hasLatest() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Event::Between::Builder::hasLatest() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::common::Date::Reader Event::Between::Reader::getLatest() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::Date::Builder Event::Between::Builder::getLatest() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::common::Date::Pipeline Event::Between::Pipeline::getLatest() {
  return  ::mas::schema::common::Date::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Event::Between::Builder::setLatest( ::mas::schema::common::Date::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::common::Date::Builder Event::Between::Builder::initLatest() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Event::Between::Builder::adoptLatest(
    ::capnp::Orphan< ::mas::schema::common::Date>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::common::Date> Event::Between::Builder::disownLatest() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Date>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Event::After::Reader::hasEvent() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Event::After::Builder::hasEvent() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::management::Event::Type::Reader Event::After::Reader::getEvent() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Event::Type>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::management::Event::Type::Builder Event::After::Builder::getEvent() {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Event::Type>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::management::Event::Type::Pipeline Event::After::Pipeline::getEvent() {
  return  ::mas::schema::management::Event::Type::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Event::After::Builder::setEvent( ::mas::schema::management::Event::Type::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::management::Event::Type>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::management::Event::Type::Builder Event::After::Builder::initEvent() {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Event::Type>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Event::After::Builder::adoptEvent(
    ::capnp::Orphan< ::mas::schema::management::Event::Type>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::management::Event::Type>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::management::Event::Type> Event::After::Builder::disownEvent() {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Event::Type>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint16_t Event::After::Reader::getDays() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Event::After::Builder::getDays() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Event::After::Builder::setDays( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Params::Sowing::Reader::hasCultivar() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Params::Sowing::Builder::hasCultivar() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Params::Sowing::Reader::getCultivar() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Params::Sowing::Builder::getCultivar() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Params::Sowing::Builder::setCultivar( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Params::Sowing::Builder::initCultivar(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Params::Sowing::Builder::adoptCultivar(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Params::Sowing::Builder::disownCultivar() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint16_t Params::Sowing::Reader::getPlantDensity() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Params::Sowing::Builder::getPlantDensity() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Params::Sowing::Builder::setPlantDensity( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Params::Sowing::Reader::hasCrop() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Params::Sowing::Builder::hasCrop() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::crop::Crop::Client Params::Sowing::Reader::getCrop() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::crop::Crop>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::crop::Crop::Client Params::Sowing::Builder::getCrop() {
  return ::capnp::_::PointerHelpers< ::mas::schema::crop::Crop>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::crop::Crop::Client Params::Sowing::Pipeline::getCrop() {
  return  ::mas::schema::crop::Crop::Client(_typeless.getPointerField(1).asCap());
}
inline void Params::Sowing::Builder::setCrop( ::mas::schema::crop::Crop::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::crop::Crop>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Params::Sowing::Builder::setCrop( ::mas::schema::crop::Crop::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::crop::Crop>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), cap);
}
inline void Params::Sowing::Builder::adoptCrop(
    ::capnp::Orphan< ::mas::schema::crop::Crop>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::crop::Crop>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::crop::Crop> Params::Sowing::Builder::disownCrop() {
  return ::capnp::_::PointerHelpers< ::mas::schema::crop::Crop>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline double Params::AutomaticSowing::Reader::getMinTempThreshold() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Params::AutomaticSowing::Builder::getMinTempThreshold() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Params::AutomaticSowing::Builder::setMinTempThreshold(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t Params::AutomaticSowing::Reader::getDaysInTempWindow() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Params::AutomaticSowing::Builder::getDaysInTempWindow() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void Params::AutomaticSowing::Builder::setDaysInTempWindow( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline double Params::AutomaticSowing::Reader::getMinPercentASW() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline double Params::AutomaticSowing::Builder::getMinPercentASW() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Params::AutomaticSowing::Builder::setMinPercentASW(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline double Params::AutomaticSowing::Reader::getMaxPercentASW() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, 4636737291354636288ull);
}

inline double Params::AutomaticSowing::Builder::getMaxPercentASW() {
  return _builder.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, 4636737291354636288ull);
}
inline void Params::AutomaticSowing::Builder::setMaxPercentASW(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value, 4636737291354636288ull);
}

inline double Params::AutomaticSowing::Reader::getMax3dayPrecipSum() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline double Params::AutomaticSowing::Builder::getMax3dayPrecipSum() {
  return _builder.getDataField<double>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void Params::AutomaticSowing::Builder::setMax3dayPrecipSum(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline double Params::AutomaticSowing::Reader::getMaxCurrentDayPrecipSum() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline double Params::AutomaticSowing::Builder::getMaxCurrentDayPrecipSum() {
  return _builder.getDataField<double>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void Params::AutomaticSowing::Builder::setMaxCurrentDayPrecipSum(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline double Params::AutomaticSowing::Reader::getTempSumAboveBaseTemp() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline double Params::AutomaticSowing::Builder::getTempSumAboveBaseTemp() {
  return _builder.getDataField<double>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void Params::AutomaticSowing::Builder::setTempSumAboveBaseTemp(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline double Params::AutomaticSowing::Reader::getBaseTemp() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}

inline double Params::AutomaticSowing::Builder::getBaseTemp() {
  return _builder.getDataField<double>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}
inline void Params::AutomaticSowing::Builder::setBaseTemp(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS, value);
}

inline bool Params::AutomaticSowing::Reader::hasAvgSoilTemp() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Params::AutomaticSowing::Builder::hasAvgSoilTemp() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::management::Params::AutomaticSowing::AvgSoilTemp::Reader Params::AutomaticSowing::Reader::getAvgSoilTemp() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Params::AutomaticSowing::AvgSoilTemp>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::management::Params::AutomaticSowing::AvgSoilTemp::Builder Params::AutomaticSowing::Builder::getAvgSoilTemp() {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Params::AutomaticSowing::AvgSoilTemp>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::management::Params::AutomaticSowing::AvgSoilTemp::Pipeline Params::AutomaticSowing::Pipeline::getAvgSoilTemp() {
  return  ::mas::schema::management::Params::AutomaticSowing::AvgSoilTemp::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Params::AutomaticSowing::Builder::setAvgSoilTemp( ::mas::schema::management::Params::AutomaticSowing::AvgSoilTemp::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::management::Params::AutomaticSowing::AvgSoilTemp>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::management::Params::AutomaticSowing::AvgSoilTemp::Builder Params::AutomaticSowing::Builder::initAvgSoilTemp() {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Params::AutomaticSowing::AvgSoilTemp>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Params::AutomaticSowing::Builder::adoptAvgSoilTemp(
    ::capnp::Orphan< ::mas::schema::management::Params::AutomaticSowing::AvgSoilTemp>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::management::Params::AutomaticSowing::AvgSoilTemp>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::management::Params::AutomaticSowing::AvgSoilTemp> Params::AutomaticSowing::Builder::disownAvgSoilTemp() {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Params::AutomaticSowing::AvgSoilTemp>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Params::AutomaticSowing::Reader::hasSowing() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Params::AutomaticSowing::Builder::hasSowing() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::management::Params::Sowing::Reader Params::AutomaticSowing::Reader::getSowing() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Params::Sowing>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::management::Params::Sowing::Builder Params::AutomaticSowing::Builder::getSowing() {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Params::Sowing>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::management::Params::Sowing::Pipeline Params::AutomaticSowing::Pipeline::getSowing() {
  return  ::mas::schema::management::Params::Sowing::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Params::AutomaticSowing::Builder::setSowing( ::mas::schema::management::Params::Sowing::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::management::Params::Sowing>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::management::Params::Sowing::Builder Params::AutomaticSowing::Builder::initSowing() {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Params::Sowing>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Params::AutomaticSowing::Builder::adoptSowing(
    ::capnp::Orphan< ::mas::schema::management::Params::Sowing>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::management::Params::Sowing>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::management::Params::Sowing> Params::AutomaticSowing::Builder::disownSowing() {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Params::Sowing>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline double Params::AutomaticSowing::AvgSoilTemp::Reader::getSoilDepthForAveraging() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 4599075939470750515ull);
}

inline double Params::AutomaticSowing::AvgSoilTemp::Builder::getSoilDepthForAveraging() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 4599075939470750515ull);
}
inline void Params::AutomaticSowing::AvgSoilTemp::Builder::setSoilDepthForAveraging(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, 4599075939470750515ull);
}

inline  ::uint16_t Params::AutomaticSowing::AvgSoilTemp::Reader::getDaysInSoilTempWindow() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Params::AutomaticSowing::AvgSoilTemp::Builder::getDaysInSoilTempWindow() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void Params::AutomaticSowing::AvgSoilTemp::Builder::setDaysInSoilTempWindow( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline double Params::AutomaticSowing::AvgSoilTemp::Reader::getSowingIfAboveAvgSoilTemp() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline double Params::AutomaticSowing::AvgSoilTemp::Builder::getSowingIfAboveAvgSoilTemp() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Params::AutomaticSowing::AvgSoilTemp::Builder::setSowingIfAboveAvgSoilTemp(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Params::Harvest::Reader::getExported() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, true);
}

inline bool Params::Harvest::Builder::getExported() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, true);
}
inline void Params::Harvest::Builder::setExported(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, true);
}

inline bool Params::Harvest::Reader::hasOptCarbMgmtData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Params::Harvest::Builder::hasOptCarbMgmtData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::management::Params::Harvest::OptCarbonMgmtData::Reader Params::Harvest::Reader::getOptCarbMgmtData() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Params::Harvest::OptCarbonMgmtData>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::management::Params::Harvest::OptCarbonMgmtData::Builder Params::Harvest::Builder::getOptCarbMgmtData() {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Params::Harvest::OptCarbonMgmtData>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::management::Params::Harvest::OptCarbonMgmtData::Pipeline Params::Harvest::Pipeline::getOptCarbMgmtData() {
  return  ::mas::schema::management::Params::Harvest::OptCarbonMgmtData::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Params::Harvest::Builder::setOptCarbMgmtData( ::mas::schema::management::Params::Harvest::OptCarbonMgmtData::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::management::Params::Harvest::OptCarbonMgmtData>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::management::Params::Harvest::OptCarbonMgmtData::Builder Params::Harvest::Builder::initOptCarbMgmtData() {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Params::Harvest::OptCarbonMgmtData>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Params::Harvest::Builder::adoptOptCarbMgmtData(
    ::capnp::Orphan< ::mas::schema::management::Params::Harvest::OptCarbonMgmtData>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::management::Params::Harvest::OptCarbonMgmtData>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::management::Params::Harvest::OptCarbonMgmtData> Params::Harvest::Builder::disownOptCarbMgmtData() {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Params::Harvest::OptCarbonMgmtData>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Params::Harvest::OptCarbonMgmtData::Reader::getOptCarbonConservation() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Params::Harvest::OptCarbonMgmtData::Builder::getOptCarbonConservation() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Params::Harvest::OptCarbonMgmtData::Builder::setOptCarbonConservation(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Params::Harvest::OptCarbonMgmtData::Reader::getCropImpactOnHumusBalance() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Params::Harvest::OptCarbonMgmtData::Builder::getCropImpactOnHumusBalance() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Params::Harvest::OptCarbonMgmtData::Builder::setCropImpactOnHumusBalance(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::mas::schema::management::Params::Harvest::CropUsage Params::Harvest::OptCarbonMgmtData::Reader::getCropUsage() const {
  return _reader.getDataField< ::mas::schema::management::Params::Harvest::CropUsage>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 1u);
}

inline  ::mas::schema::management::Params::Harvest::CropUsage Params::Harvest::OptCarbonMgmtData::Builder::getCropUsage() {
  return _builder.getDataField< ::mas::schema::management::Params::Harvest::CropUsage>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 1u);
}
inline void Params::Harvest::OptCarbonMgmtData::Builder::setCropUsage( ::mas::schema::management::Params::Harvest::CropUsage value) {
  _builder.setDataField< ::mas::schema::management::Params::Harvest::CropUsage>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value, 1u);
}

inline double Params::Harvest::OptCarbonMgmtData::Reader::getResidueHeq() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline double Params::Harvest::OptCarbonMgmtData::Builder::getResidueHeq() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Params::Harvest::OptCarbonMgmtData::Builder::setResidueHeq(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline double Params::Harvest::OptCarbonMgmtData::Reader::getOrganicFertilizerHeq() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline double Params::Harvest::OptCarbonMgmtData::Builder::getOrganicFertilizerHeq() {
  return _builder.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Params::Harvest::OptCarbonMgmtData::Builder::setOrganicFertilizerHeq(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline double Params::Harvest::OptCarbonMgmtData::Reader::getMaxResidueRecoverFraction() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline double Params::Harvest::OptCarbonMgmtData::Builder::getMaxResidueRecoverFraction() {
  return _builder.getDataField<double>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void Params::Harvest::OptCarbonMgmtData::Builder::setMaxResidueRecoverFraction(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline double Params::AutomaticHarvest::Reader::getMinPercentASW() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Params::AutomaticHarvest::Builder::getMinPercentASW() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Params::AutomaticHarvest::Builder::setMinPercentASW(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Params::AutomaticHarvest::Reader::getMaxPercentASW() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 4636737291354636288ull);
}

inline double Params::AutomaticHarvest::Builder::getMaxPercentASW() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, 4636737291354636288ull);
}
inline void Params::AutomaticHarvest::Builder::setMaxPercentASW(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value, 4636737291354636288ull);
}

inline double Params::AutomaticHarvest::Reader::getMax3dayPrecipSum() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline double Params::AutomaticHarvest::Builder::getMax3dayPrecipSum() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Params::AutomaticHarvest::Builder::setMax3dayPrecipSum(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline double Params::AutomaticHarvest::Reader::getMaxCurrentDayPrecipSum() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline double Params::AutomaticHarvest::Builder::getMaxCurrentDayPrecipSum() {
  return _builder.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Params::AutomaticHarvest::Builder::setMaxCurrentDayPrecipSum(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::mas::schema::management::Event::PhenoStage Params::AutomaticHarvest::Reader::getHarvestTime() const {
  return _reader.getDataField< ::mas::schema::management::Event::PhenoStage>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, 3u);
}

inline  ::mas::schema::management::Event::PhenoStage Params::AutomaticHarvest::Builder::getHarvestTime() {
  return _builder.getDataField< ::mas::schema::management::Event::PhenoStage>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, 3u);
}
inline void Params::AutomaticHarvest::Builder::setHarvestTime( ::mas::schema::management::Event::PhenoStage value) {
  _builder.setDataField< ::mas::schema::management::Event::PhenoStage>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, value, 3u);
}

inline bool Params::AutomaticHarvest::Reader::hasHarvest() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Params::AutomaticHarvest::Builder::hasHarvest() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::management::Params::Harvest::Reader Params::AutomaticHarvest::Reader::getHarvest() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Params::Harvest>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::management::Params::Harvest::Builder Params::AutomaticHarvest::Builder::getHarvest() {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Params::Harvest>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::management::Params::Harvest::Pipeline Params::AutomaticHarvest::Pipeline::getHarvest() {
  return  ::mas::schema::management::Params::Harvest::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Params::AutomaticHarvest::Builder::setHarvest( ::mas::schema::management::Params::Harvest::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::management::Params::Harvest>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::management::Params::Harvest::Builder Params::AutomaticHarvest::Builder::initHarvest() {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Params::Harvest>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Params::AutomaticHarvest::Builder::adoptHarvest(
    ::capnp::Orphan< ::mas::schema::management::Params::Harvest>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::management::Params::Harvest>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::management::Params::Harvest> Params::AutomaticHarvest::Builder::disownHarvest() {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Params::Harvest>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Params::Cutting::Reader::hasCuttingSpec() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Params::Cutting::Builder::hasCuttingSpec() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::management::Params::Cutting::Spec,  ::capnp::Kind::STRUCT>::Reader Params::Cutting::Reader::getCuttingSpec() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Params::Cutting::Spec,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::management::Params::Cutting::Spec,  ::capnp::Kind::STRUCT>::Builder Params::Cutting::Builder::getCuttingSpec() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Params::Cutting::Spec,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Params::Cutting::Builder::setCuttingSpec( ::capnp::List< ::mas::schema::management::Params::Cutting::Spec,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Params::Cutting::Spec,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::management::Params::Cutting::Spec,  ::capnp::Kind::STRUCT>::Builder Params::Cutting::Builder::initCuttingSpec(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Params::Cutting::Spec,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Params::Cutting::Builder::adoptCuttingSpec(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::management::Params::Cutting::Spec,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Params::Cutting::Spec,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::management::Params::Cutting::Spec,  ::capnp::Kind::STRUCT>> Params::Cutting::Builder::disownCuttingSpec() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Params::Cutting::Spec,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double Params::Cutting::Reader::getCutMaxAssimilationRatePercentage() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Params::Cutting::Builder::getCutMaxAssimilationRatePercentage() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Params::Cutting::Builder::setCutMaxAssimilationRatePercentage(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::mas::schema::management::PlantOrgan Params::Cutting::Spec::Reader::getOrgan() const {
  return _reader.getDataField< ::mas::schema::management::PlantOrgan>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::management::PlantOrgan Params::Cutting::Spec::Builder::getOrgan() {
  return _builder.getDataField< ::mas::schema::management::PlantOrgan>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Params::Cutting::Spec::Builder::setOrgan( ::mas::schema::management::PlantOrgan value) {
  _builder.setDataField< ::mas::schema::management::PlantOrgan>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Params::Cutting::Spec::Reader::getValue() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Params::Cutting::Spec::Builder::getValue() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Params::Cutting::Spec::Builder::setValue(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::mas::schema::management::Params::Cutting::Unit Params::Cutting::Spec::Reader::getUnit() const {
  return _reader.getDataField< ::mas::schema::management::Params::Cutting::Unit>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::management::Params::Cutting::Unit Params::Cutting::Spec::Builder::getUnit() {
  return _builder.getDataField< ::mas::schema::management::Params::Cutting::Unit>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Params::Cutting::Spec::Builder::setUnit( ::mas::schema::management::Params::Cutting::Unit value) {
  _builder.setDataField< ::mas::schema::management::Params::Cutting::Unit>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::mas::schema::management::Params::Cutting::CL Params::Cutting::Spec::Reader::getCutOrLeft() const {
  return _reader.getDataField< ::mas::schema::management::Params::Cutting::CL>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::management::Params::Cutting::CL Params::Cutting::Spec::Builder::getCutOrLeft() {
  return _builder.getDataField< ::mas::schema::management::Params::Cutting::CL>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Params::Cutting::Spec::Builder::setCutOrLeft( ::mas::schema::management::Params::Cutting::CL value) {
  _builder.setDataField< ::mas::schema::management::Params::Cutting::CL>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline double Params::Cutting::Spec::Reader::getExportPercentage() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, 4636737291354636288ull);
}

inline double Params::Cutting::Spec::Builder::getExportPercentage() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, 4636737291354636288ull);
}
inline void Params::Cutting::Spec::Builder::setExportPercentage(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value, 4636737291354636288ull);
}

inline bool Params::MineralFertilization::Reader::hasFertilizer() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Params::MineralFertilization::Builder::hasFertilizer() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::management::Fertilizer::Client Params::MineralFertilization::Reader::getFertilizer() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Fertilizer>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::management::Fertilizer::Client Params::MineralFertilization::Builder::getFertilizer() {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Fertilizer>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::management::Fertilizer::Client Params::MineralFertilization::Pipeline::getFertilizer() {
  return  ::mas::schema::management::Fertilizer::Client(_typeless.getPointerField(0).asCap());
}
inline void Params::MineralFertilization::Builder::setFertilizer( ::mas::schema::management::Fertilizer::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::management::Fertilizer>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Params::MineralFertilization::Builder::setFertilizer( ::mas::schema::management::Fertilizer::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::management::Fertilizer>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Params::MineralFertilization::Builder::adoptFertilizer(
    ::capnp::Orphan< ::mas::schema::management::Fertilizer>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::management::Fertilizer>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::management::Fertilizer> Params::MineralFertilization::Builder::disownFertilizer() {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Fertilizer>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline double Params::MineralFertilization::Reader::getAmount() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Params::MineralFertilization::Builder::getAmount() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Params::MineralFertilization::Builder::setAmount(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Params::NDemandFertilization::Reader::getNDemand() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Params::NDemandFertilization::Builder::getNDemand() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Params::NDemandFertilization::Builder::setNDemand(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Params::NDemandFertilization::Reader::hasFertilizer() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Params::NDemandFertilization::Builder::hasFertilizer() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::management::Fertilizer::Client Params::NDemandFertilization::Reader::getFertilizer() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Fertilizer>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::management::Fertilizer::Client Params::NDemandFertilization::Builder::getFertilizer() {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Fertilizer>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::management::Fertilizer::Client Params::NDemandFertilization::Pipeline::getFertilizer() {
  return  ::mas::schema::management::Fertilizer::Client(_typeless.getPointerField(0).asCap());
}
inline void Params::NDemandFertilization::Builder::setFertilizer( ::mas::schema::management::Fertilizer::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::management::Fertilizer>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Params::NDemandFertilization::Builder::setFertilizer( ::mas::schema::management::Fertilizer::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::management::Fertilizer>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Params::NDemandFertilization::Builder::adoptFertilizer(
    ::capnp::Orphan< ::mas::schema::management::Fertilizer>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::management::Fertilizer>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::management::Fertilizer> Params::NDemandFertilization::Builder::disownFertilizer() {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Fertilizer>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline double Params::NDemandFertilization::Reader::getDepth() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Params::NDemandFertilization::Builder::getDepth() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Params::NDemandFertilization::Builder::setDepth(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t Params::NDemandFertilization::Reader::getStage() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, 1u);
}

inline  ::uint8_t Params::NDemandFertilization::Builder::getStage() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, 1u);
}
inline void Params::NDemandFertilization::Builder::setStage( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, value, 1u);
}

inline bool Params::OrganicFertilization::Reader::hasFertilizer() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Params::OrganicFertilization::Builder::hasFertilizer() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::management::Fertilizer::Client Params::OrganicFertilization::Reader::getFertilizer() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Fertilizer>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::management::Fertilizer::Client Params::OrganicFertilization::Builder::getFertilizer() {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Fertilizer>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::management::Fertilizer::Client Params::OrganicFertilization::Pipeline::getFertilizer() {
  return  ::mas::schema::management::Fertilizer::Client(_typeless.getPointerField(0).asCap());
}
inline void Params::OrganicFertilization::Builder::setFertilizer( ::mas::schema::management::Fertilizer::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::management::Fertilizer>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Params::OrganicFertilization::Builder::setFertilizer( ::mas::schema::management::Fertilizer::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::management::Fertilizer>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Params::OrganicFertilization::Builder::adoptFertilizer(
    ::capnp::Orphan< ::mas::schema::management::Fertilizer>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::management::Fertilizer>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::management::Fertilizer> Params::OrganicFertilization::Builder::disownFertilizer() {
  return ::capnp::_::PointerHelpers< ::mas::schema::management::Fertilizer>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline double Params::OrganicFertilization::Reader::getAmount() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Params::OrganicFertilization::Builder::getAmount() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Params::OrganicFertilization::Builder::setAmount(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Params::OrganicFertilization::Reader::getIncorporation() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}

inline bool Params::OrganicFertilization::Builder::getIncorporation() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}
inline void Params::OrganicFertilization::Builder::setIncorporation(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS, value);
}

inline double Params::Tillage::Reader::getDepth() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 4599075939470750515ull);
}

inline double Params::Tillage::Builder::getDepth() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 4599075939470750515ull);
}
inline void Params::Tillage::Builder::setDepth(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, 4599075939470750515ull);
}

inline double Params::Irrigation::Reader::getAmount() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Params::Irrigation::Builder::getAmount() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Params::Irrigation::Builder::setAmount(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Params::Irrigation::Reader::hasNutrientConcentrations() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Params::Irrigation::Builder::hasNutrientConcentrations() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>::Reader Params::Irrigation::Reader::getNutrientConcentrations() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>::Builder Params::Irrigation::Builder::getNutrientConcentrations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Params::Irrigation::Builder::setNutrientConcentrations( ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>::Builder Params::Irrigation::Builder::initNutrientConcentrations(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Params::Irrigation::Builder::adoptNutrientConcentrations(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>> Params::Irrigation::Builder::disownNutrientConcentrations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::mas::schema::management::Nutrient::Name Nutrient::Reader::getNutrient() const {
  return _reader.getDataField< ::mas::schema::management::Nutrient::Name>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::management::Nutrient::Name Nutrient::Builder::getNutrient() {
  return _builder.getDataField< ::mas::schema::management::Nutrient::Name>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Nutrient::Builder::setNutrient( ::mas::schema::management::Nutrient::Name value) {
  _builder.setDataField< ::mas::schema::management::Nutrient::Name>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Nutrient::Reader::getValue() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Nutrient::Builder::getValue() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Nutrient::Builder::setValue(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::mas::schema::management::Nutrient::Unit Nutrient::Reader::getUnit() const {
  return _reader.getDataField< ::mas::schema::management::Nutrient::Unit>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::management::Nutrient::Unit Nutrient::Builder::getUnit() {
  return _builder.getDataField< ::mas::schema::management::Nutrient::Unit>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Nutrient::Builder::setUnit( ::mas::schema::management::Nutrient::Unit value) {
  _builder.setDataField< ::mas::schema::management::Nutrient::Unit>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

#if !CAPNP_LITE
inline Fertilizer::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Fertilizer::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Fertilizer::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Fertilizer::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Fertilizer::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::management::Fertilizer::Client& Fertilizer::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::management::Fertilizer::Client& Fertilizer::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Fertilizer::NutrientsResults::Reader::hasNutrients() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Fertilizer::NutrientsResults::Builder::hasNutrients() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>::Reader Fertilizer::NutrientsResults::Reader::getNutrients() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>::Builder Fertilizer::NutrientsResults::Builder::getNutrients() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Fertilizer::NutrientsResults::Builder::setNutrients( ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>::Builder Fertilizer::NutrientsResults::Builder::initNutrients(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Fertilizer::NutrientsResults::Builder::adoptNutrients(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>> Fertilizer::NutrientsResults::Builder::disownNutrients() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Nutrient,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Fertilizer::ParametersResults::Reader::hasParams() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Fertilizer::ParametersResults::Builder::hasParams() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline ::capnp::AnyPointer::Reader Fertilizer::ParametersResults::Reader::getParams() const {
  return ::capnp::AnyPointer::Reader(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder Fertilizer::ParametersResults::Builder::getParams() {
  return ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder Fertilizer::ParametersResults::Builder::initParams() {
  auto result = ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
  result.clear();
  return result;
}

#if !CAPNP_LITE
inline FertilizerService::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline FertilizerService::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline FertilizerService::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline FertilizerService::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline FertilizerService::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::management::FertilizerService::Client& FertilizerService::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::management::FertilizerService::Client& FertilizerService::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
#if !CAPNP_LITE
inline Service::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Service::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Service::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Service::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Service::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::management::Service::Client& Service::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::management::Service::Client& Service::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Service::ManagementAtResults::Reader::hasMgmt() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Service::ManagementAtResults::Builder::hasMgmt() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>::Reader Service::ManagementAtResults::Reader::getMgmt() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>::Builder Service::ManagementAtResults::Builder::getMgmt() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Service::ManagementAtResults::Builder::setMgmt( ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>::Builder Service::ManagementAtResults::Builder::initMgmt(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Service::ManagementAtResults::Builder::adoptMgmt(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>> Service::ManagementAtResults::Builder::disownMgmt() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::management::Event,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

