// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: storage.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#if CAPNP_VERSION != 10000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "common.capnp.h"
#include "persistence.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(e69f958aa2386f06);
CAPNP_DECLARE_SCHEMA(878131f45567ae62);
CAPNP_DECLARE_SCHEMA(fa1a243e7bf478c0);
CAPNP_DECLARE_SCHEMA(e2185cc449928f5c);
CAPNP_DECLARE_SCHEMA(e0647ffea942d00a);
CAPNP_DECLARE_SCHEMA(dbfb7e9990643f87);
CAPNP_DECLARE_SCHEMA(923c06d58238b290);
CAPNP_DECLARE_SCHEMA(c5e6024b9f05560e);
CAPNP_DECLARE_SCHEMA(a4ff24aa7f0debaf);
CAPNP_DECLARE_SCHEMA(d667b97e089bae01);
CAPNP_DECLARE_SCHEMA(9e138889be22cc5e);
CAPNP_DECLARE_SCHEMA(a914844d7351c9ee);
CAPNP_DECLARE_SCHEMA(93fc14178e630994);
CAPNP_DECLARE_SCHEMA(ffe4319ac401d166);
CAPNP_DECLARE_SCHEMA(dbf70a288c6933b1);
CAPNP_DECLARE_SCHEMA(a028d3ba03083872);
CAPNP_DECLARE_SCHEMA(c4161d5db43ad669);
CAPNP_DECLARE_SCHEMA(9bc1d764a970b846);
CAPNP_DECLARE_SCHEMA(fde99170b27ac5ce);
CAPNP_DECLARE_SCHEMA(fbd938c95f64b7bf);
CAPNP_DECLARE_SCHEMA(c31c71f8d67b827b);
CAPNP_DECLARE_SCHEMA(eb6f27dfc29bffad);
CAPNP_DECLARE_SCHEMA(fbef00fded9c8312);
CAPNP_DECLARE_SCHEMA(883b57737fba9e54);
CAPNP_DECLARE_SCHEMA(847d262cefd2f142);
CAPNP_DECLARE_SCHEMA(bc4cb84d672b9bf6);
CAPNP_DECLARE_SCHEMA(f32349bf3a9997ac);
CAPNP_DECLARE_SCHEMA(f517bec79f8d2744);
CAPNP_DECLARE_SCHEMA(b2af26aeda5445e5);
CAPNP_DECLARE_SCHEMA(a466e92166fcce6e);
CAPNP_DECLARE_SCHEMA(f82426685da256f9);
CAPNP_DECLARE_SCHEMA(bfbe4f9e7fb62452);
CAPNP_DECLARE_SCHEMA(aa0460382685000e);
CAPNP_DECLARE_SCHEMA(ba3e5ec40217ab32);
CAPNP_DECLARE_SCHEMA(898f1a2675ac89cf);

}  // namespace schemas
}  // namespace capnp

namespace mas {
namespace schema {
namespace storage {

struct Store {
  Store() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct Container;
  struct ImportExportData;
  struct NewContainerParams;
  struct NewContainerResults;
  struct ContainerWithIdParams;
  struct ContainerWithIdResults;
  struct ListContainersParams;
  struct ListContainersResults;
  struct RemoveContainerParams;
  struct RemoveContainerResults;
  struct ImportContainerParams;
  struct ImportContainerResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(e69f958aa2386f06)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Store::Container {
  Container() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct Entry;
  struct ExportParams;
  struct ExportResults;
  struct DownloadEntriesParams;
  struct DownloadEntriesResults;
  struct ListEntriesParams;
  struct ListEntriesResults;
  struct GetEntryParams;
  struct GetEntryResults;
  struct RemoveEntryParams;
  struct RemoveEntryResults;
  struct ClearParams;
  struct ClearResults;
  struct AddEntryParams;
  struct AddEntryResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(878131f45567ae62)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Store::Container::Entry {
  Entry() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct Value;
  struct GetKeyParams;
  struct GetKeyResults;
  struct GetValueParams;
  struct GetValueResults;
  struct SetValueParams;
  struct SetValueResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(fa1a243e7bf478c0)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Store::Container::Entry::Value {
  Value() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    BOOL_VALUE,
    BOOL_LIST_VALUE,
    INT8_VALUE,
    INT8_LIST_VALUE,
    INT16_VALUE,
    INT16_LIST_VALUE,
    INT32_VALUE,
    INT32_LIST_VALUE,
    INT64_VALUE,
    INT64_LIST_VALUE,
    UINT8_VALUE,
    UINT8_LIST_VALUE,
    UINT16_VALUE,
    UINT16_LIST_VALUE,
    UINT32_VALUE,
    UINT32_LIST_VALUE,
    UINT64_VALUE,
    UINT64_LIST_VALUE,
    FLOAT32_VALUE,
    FLOAT32_LIST_VALUE,
    FLOAT64_VALUE,
    FLOAT64_LIST_VALUE,
    TEXT_VALUE,
    TEXT_LIST_VALUE,
    DATA_VALUE,
    DATA_LIST_VALUE,
    ANY_VALUE,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e2185cc449928f5c, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::Entry::GetKeyParams {
  GetKeyParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e0647ffea942d00a, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::Entry::GetKeyResults {
  GetKeyResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dbfb7e9990643f87, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::Entry::GetValueParams {
  GetValueParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(923c06d58238b290, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::Entry::GetValueResults {
  GetValueResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c5e6024b9f05560e, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::Entry::SetValueParams {
  SetValueParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a4ff24aa7f0debaf, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::Entry::SetValueResults {
  SetValueResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d667b97e089bae01, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::ExportParams {
  ExportParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9e138889be22cc5e, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::ExportResults {
  ExportResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a914844d7351c9ee, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::DownloadEntriesParams {
  DownloadEntriesParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(93fc14178e630994, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::DownloadEntriesResults {
  DownloadEntriesResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ffe4319ac401d166, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::ListEntriesParams {
  ListEntriesParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dbf70a288c6933b1, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::ListEntriesResults {
  ListEntriesResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a028d3ba03083872, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::GetEntryParams {
  GetEntryParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c4161d5db43ad669, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::GetEntryResults {
  GetEntryResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9bc1d764a970b846, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::RemoveEntryParams {
  RemoveEntryParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fde99170b27ac5ce, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::RemoveEntryResults {
  RemoveEntryResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fbd938c95f64b7bf, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::ClearParams {
  ClearParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c31c71f8d67b827b, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::ClearResults {
  ClearResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(eb6f27dfc29bffad, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::AddEntryParams {
  AddEntryParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fbef00fded9c8312, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::AddEntryResults {
  AddEntryResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(883b57737fba9e54, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::ImportExportData {
  ImportExportData() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(847d262cefd2f142, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::NewContainerParams {
  NewContainerParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bc4cb84d672b9bf6, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::NewContainerResults {
  NewContainerResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f32349bf3a9997ac, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::ContainerWithIdParams {
  ContainerWithIdParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f517bec79f8d2744, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::ContainerWithIdResults {
  ContainerWithIdResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b2af26aeda5445e5, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::ListContainersParams {
  ListContainersParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a466e92166fcce6e, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::ListContainersResults {
  ListContainersResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f82426685da256f9, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::RemoveContainerParams {
  RemoveContainerParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bfbe4f9e7fb62452, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::RemoveContainerResults {
  RemoveContainerResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(aa0460382685000e, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::ImportContainerParams {
  ImportContainerParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ba3e5ec40217ab32, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::ImportContainerResults {
  ImportContainerResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(898f1a2675ac89cf, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

#if !CAPNP_LITE
class Store::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client,
      public virtual  ::mas::schema::persistence::Persistent::Client {
public:
  typedef Store Calls;
  typedef Store Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::storage::Store::NewContainerParams,  ::mas::schema::storage::Store::NewContainerResults> newContainerRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::storage::Store::ContainerWithIdParams,  ::mas::schema::storage::Store::ContainerWithIdResults> containerWithIdRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::storage::Store::ListContainersParams,  ::mas::schema::storage::Store::ListContainersResults> listContainersRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::storage::Store::RemoveContainerParams,  ::mas::schema::storage::Store::RemoveContainerResults> removeContainerRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::storage::Store::ImportContainerParams,  ::mas::schema::storage::Store::ImportContainerResults> importContainerRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Store::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server,
      public virtual  ::mas::schema::persistence::Persistent::Server {
public:
  typedef Store Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::storage::Store::NewContainerParams NewContainerParams;
  typedef  ::mas::schema::storage::Store::NewContainerResults NewContainerResults;
  typedef ::capnp::CallContext<NewContainerParams, NewContainerResults> NewContainerContext;
  virtual ::kj::Promise<void> newContainer(NewContainerContext context);
  typedef  ::mas::schema::storage::Store::ContainerWithIdParams ContainerWithIdParams;
  typedef  ::mas::schema::storage::Store::ContainerWithIdResults ContainerWithIdResults;
  typedef ::capnp::CallContext<ContainerWithIdParams, ContainerWithIdResults> ContainerWithIdContext;
  virtual ::kj::Promise<void> containerWithId(ContainerWithIdContext context);
  typedef  ::mas::schema::storage::Store::ListContainersParams ListContainersParams;
  typedef  ::mas::schema::storage::Store::ListContainersResults ListContainersResults;
  typedef ::capnp::CallContext<ListContainersParams, ListContainersResults> ListContainersContext;
  virtual ::kj::Promise<void> listContainers(ListContainersContext context);
  typedef  ::mas::schema::storage::Store::RemoveContainerParams RemoveContainerParams;
  typedef  ::mas::schema::storage::Store::RemoveContainerResults RemoveContainerResults;
  typedef ::capnp::CallContext<RemoveContainerParams, RemoveContainerResults> RemoveContainerContext;
  virtual ::kj::Promise<void> removeContainer(RemoveContainerContext context);
  typedef  ::mas::schema::storage::Store::ImportContainerParams ImportContainerParams;
  typedef  ::mas::schema::storage::Store::ImportContainerResults ImportContainerResults;
  typedef ::capnp::CallContext<ImportContainerParams, ImportContainerResults> ImportContainerContext;
  virtual ::kj::Promise<void> importContainer(ImportContainerContext context);

  inline  ::mas::schema::storage::Store::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::storage::Store>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Store::Container::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client,
      public virtual  ::mas::schema::persistence::Persistent::Client {
public:
  typedef Container Calls;
  typedef Container Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::storage::Store::Container::ExportParams,  ::mas::schema::storage::Store::Container::ExportResults> exportRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::storage::Store::Container::DownloadEntriesParams,  ::mas::schema::storage::Store::Container::DownloadEntriesResults> downloadEntriesRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::storage::Store::Container::ListEntriesParams,  ::mas::schema::storage::Store::Container::ListEntriesResults> listEntriesRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::storage::Store::Container::GetEntryParams,  ::mas::schema::storage::Store::Container::GetEntryResults> getEntryRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::storage::Store::Container::RemoveEntryParams,  ::mas::schema::storage::Store::Container::RemoveEntryResults> removeEntryRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::storage::Store::Container::ClearParams,  ::mas::schema::storage::Store::Container::ClearResults> clearRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::storage::Store::Container::AddEntryParams,  ::mas::schema::storage::Store::Container::AddEntryResults> addEntryRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Store::Container::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server,
      public virtual  ::mas::schema::persistence::Persistent::Server {
public:
  typedef Container Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::storage::Store::Container::ExportParams ExportParams;
  typedef  ::mas::schema::storage::Store::Container::ExportResults ExportResults;
  typedef ::capnp::CallContext<ExportParams, ExportResults> ExportContext;
  virtual ::kj::Promise<void> export_(ExportContext context);
  typedef  ::mas::schema::storage::Store::Container::DownloadEntriesParams DownloadEntriesParams;
  typedef  ::mas::schema::storage::Store::Container::DownloadEntriesResults DownloadEntriesResults;
  typedef ::capnp::CallContext<DownloadEntriesParams, DownloadEntriesResults> DownloadEntriesContext;
  virtual ::kj::Promise<void> downloadEntries(DownloadEntriesContext context);
  typedef  ::mas::schema::storage::Store::Container::ListEntriesParams ListEntriesParams;
  typedef  ::mas::schema::storage::Store::Container::ListEntriesResults ListEntriesResults;
  typedef ::capnp::CallContext<ListEntriesParams, ListEntriesResults> ListEntriesContext;
  virtual ::kj::Promise<void> listEntries(ListEntriesContext context);
  typedef  ::mas::schema::storage::Store::Container::GetEntryParams GetEntryParams;
  typedef  ::mas::schema::storage::Store::Container::GetEntryResults GetEntryResults;
  typedef ::capnp::CallContext<GetEntryParams, GetEntryResults> GetEntryContext;
  virtual ::kj::Promise<void> getEntry(GetEntryContext context);
  typedef  ::mas::schema::storage::Store::Container::RemoveEntryParams RemoveEntryParams;
  typedef  ::mas::schema::storage::Store::Container::RemoveEntryResults RemoveEntryResults;
  typedef ::capnp::CallContext<RemoveEntryParams, RemoveEntryResults> RemoveEntryContext;
  virtual ::kj::Promise<void> removeEntry(RemoveEntryContext context);
  typedef  ::mas::schema::storage::Store::Container::ClearParams ClearParams;
  typedef  ::mas::schema::storage::Store::Container::ClearResults ClearResults;
  typedef ::capnp::CallContext<ClearParams, ClearResults> ClearContext;
  virtual ::kj::Promise<void> clear(ClearContext context);
  typedef  ::mas::schema::storage::Store::Container::AddEntryParams AddEntryParams;
  typedef  ::mas::schema::storage::Store::Container::AddEntryResults AddEntryResults;
  typedef ::capnp::CallContext<AddEntryParams, AddEntryResults> AddEntryContext;
  virtual ::kj::Promise<void> addEntry(AddEntryContext context);

  inline  ::mas::schema::storage::Store::Container::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::storage::Store::Container>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Store::Container::Entry::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Entry Calls;
  typedef Entry Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::storage::Store::Container::Entry::GetKeyParams,  ::mas::schema::storage::Store::Container::Entry::GetKeyResults> getKeyRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::storage::Store::Container::Entry::GetValueParams,  ::mas::schema::storage::Store::Container::Entry::GetValueResults> getValueRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::storage::Store::Container::Entry::SetValueParams,  ::mas::schema::storage::Store::Container::Entry::SetValueResults> setValueRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Store::Container::Entry::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Entry Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::storage::Store::Container::Entry::GetKeyParams GetKeyParams;
  typedef  ::mas::schema::storage::Store::Container::Entry::GetKeyResults GetKeyResults;
  typedef ::capnp::CallContext<GetKeyParams, GetKeyResults> GetKeyContext;
  virtual ::kj::Promise<void> getKey(GetKeyContext context);
  typedef  ::mas::schema::storage::Store::Container::Entry::GetValueParams GetValueParams;
  typedef  ::mas::schema::storage::Store::Container::Entry::GetValueResults GetValueResults;
  typedef ::capnp::CallContext<GetValueParams, GetValueResults> GetValueContext;
  virtual ::kj::Promise<void> getValue(GetValueContext context);
  typedef  ::mas::schema::storage::Store::Container::Entry::SetValueParams SetValueParams;
  typedef  ::mas::schema::storage::Store::Container::Entry::SetValueResults SetValueResults;
  typedef ::capnp::CallContext<SetValueParams, SetValueResults> SetValueContext;
  virtual ::kj::Promise<void> setValue(SetValueContext context);

  inline  ::mas::schema::storage::Store::Container::Entry::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::storage::Store::Container::Entry>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Store::Container::Entry::Value::Reader {
public:
  typedef Value Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isBoolValue() const;
  inline bool getBoolValue() const;

  inline bool isBoolListValue() const;
  inline bool hasBoolListValue() const;
  inline  ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Reader getBoolListValue() const;

  inline bool isInt8Value() const;
  inline  ::int8_t getInt8Value() const;

  inline bool isInt8ListValue() const;
  inline bool hasInt8ListValue() const;
  inline  ::capnp::List< ::int8_t,  ::capnp::Kind::PRIMITIVE>::Reader getInt8ListValue() const;

  inline bool isInt16Value() const;
  inline  ::int16_t getInt16Value() const;

  inline bool isInt16ListValue() const;
  inline bool hasInt16ListValue() const;
  inline  ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>::Reader getInt16ListValue() const;

  inline bool isInt32Value() const;
  inline  ::int32_t getInt32Value() const;

  inline bool isInt32ListValue() const;
  inline bool hasInt32ListValue() const;
  inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Reader getInt32ListValue() const;

  inline bool isInt64Value() const;
  inline  ::int64_t getInt64Value() const;

  inline bool isInt64ListValue() const;
  inline bool hasInt64ListValue() const;
  inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Reader getInt64ListValue() const;

  inline bool isUint8Value() const;
  inline  ::uint8_t getUint8Value() const;

  inline bool isUint8ListValue() const;
  inline bool hasUint8ListValue() const;
  inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Reader getUint8ListValue() const;

  inline bool isUint16Value() const;
  inline  ::uint16_t getUint16Value() const;

  inline bool isUint16ListValue() const;
  inline bool hasUint16ListValue() const;
  inline  ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>::Reader getUint16ListValue() const;

  inline bool isUint32Value() const;
  inline  ::uint32_t getUint32Value() const;

  inline bool isUint32ListValue() const;
  inline bool hasUint32ListValue() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getUint32ListValue() const;

  inline bool isUint64Value() const;
  inline  ::uint64_t getUint64Value() const;

  inline bool isUint64ListValue() const;
  inline bool hasUint64ListValue() const;
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader getUint64ListValue() const;

  inline bool isFloat32Value() const;
  inline float getFloat32Value() const;

  inline bool isFloat32ListValue() const;
  inline bool hasFloat32ListValue() const;
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader getFloat32ListValue() const;

  inline bool isFloat64Value() const;
  inline double getFloat64Value() const;

  inline bool isFloat64ListValue() const;
  inline bool hasFloat64ListValue() const;
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader getFloat64ListValue() const;

  inline bool isTextValue() const;
  inline bool hasTextValue() const;
  inline  ::capnp::Text::Reader getTextValue() const;

  inline bool isTextListValue() const;
  inline bool hasTextListValue() const;
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader getTextListValue() const;

  inline bool isDataValue() const;
  inline bool hasDataValue() const;
  inline  ::capnp::Data::Reader getDataValue() const;

  inline bool isDataListValue() const;
  inline bool hasDataListValue() const;
  inline  ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Reader getDataListValue() const;

  inline bool isAnyValue() const;
  inline bool hasAnyValue() const;
  inline  ::capnp::AnyStruct::Reader getAnyValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::Entry::Value::Builder {
public:
  typedef Value Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isBoolValue();
  inline bool getBoolValue();
  inline void setBoolValue(bool value);

  inline bool isBoolListValue();
  inline bool hasBoolListValue();
  inline  ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Builder getBoolListValue();
  inline void setBoolListValue( ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setBoolListValue(::kj::ArrayPtr<const bool> value);
  inline  ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Builder initBoolListValue(unsigned int size);
  inline void adoptBoolListValue(::capnp::Orphan< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>> disownBoolListValue();

  inline bool isInt8Value();
  inline  ::int8_t getInt8Value();
  inline void setInt8Value( ::int8_t value);

  inline bool isInt8ListValue();
  inline bool hasInt8ListValue();
  inline  ::capnp::List< ::int8_t,  ::capnp::Kind::PRIMITIVE>::Builder getInt8ListValue();
  inline void setInt8ListValue( ::capnp::List< ::int8_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setInt8ListValue(::kj::ArrayPtr<const  ::int8_t> value);
  inline  ::capnp::List< ::int8_t,  ::capnp::Kind::PRIMITIVE>::Builder initInt8ListValue(unsigned int size);
  inline void adoptInt8ListValue(::capnp::Orphan< ::capnp::List< ::int8_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int8_t,  ::capnp::Kind::PRIMITIVE>> disownInt8ListValue();

  inline bool isInt16Value();
  inline  ::int16_t getInt16Value();
  inline void setInt16Value( ::int16_t value);

  inline bool isInt16ListValue();
  inline bool hasInt16ListValue();
  inline  ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>::Builder getInt16ListValue();
  inline void setInt16ListValue( ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setInt16ListValue(::kj::ArrayPtr<const  ::int16_t> value);
  inline  ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>::Builder initInt16ListValue(unsigned int size);
  inline void adoptInt16ListValue(::capnp::Orphan< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>> disownInt16ListValue();

  inline bool isInt32Value();
  inline  ::int32_t getInt32Value();
  inline void setInt32Value( ::int32_t value);

  inline bool isInt32ListValue();
  inline bool hasInt32ListValue();
  inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Builder getInt32ListValue();
  inline void setInt32ListValue( ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setInt32ListValue(::kj::ArrayPtr<const  ::int32_t> value);
  inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Builder initInt32ListValue(unsigned int size);
  inline void adoptInt32ListValue(::capnp::Orphan< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>> disownInt32ListValue();

  inline bool isInt64Value();
  inline  ::int64_t getInt64Value();
  inline void setInt64Value( ::int64_t value);

  inline bool isInt64ListValue();
  inline bool hasInt64ListValue();
  inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Builder getInt64ListValue();
  inline void setInt64ListValue( ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setInt64ListValue(::kj::ArrayPtr<const  ::int64_t> value);
  inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Builder initInt64ListValue(unsigned int size);
  inline void adoptInt64ListValue(::capnp::Orphan< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>> disownInt64ListValue();

  inline bool isUint8Value();
  inline  ::uint8_t getUint8Value();
  inline void setUint8Value( ::uint8_t value);

  inline bool isUint8ListValue();
  inline bool hasUint8ListValue();
  inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Builder getUint8ListValue();
  inline void setUint8ListValue( ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setUint8ListValue(::kj::ArrayPtr<const  ::uint8_t> value);
  inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Builder initUint8ListValue(unsigned int size);
  inline void adoptUint8ListValue(::capnp::Orphan< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>> disownUint8ListValue();

  inline bool isUint16Value();
  inline  ::uint16_t getUint16Value();
  inline void setUint16Value( ::uint16_t value);

  inline bool isUint16ListValue();
  inline bool hasUint16ListValue();
  inline  ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>::Builder getUint16ListValue();
  inline void setUint16ListValue( ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setUint16ListValue(::kj::ArrayPtr<const  ::uint16_t> value);
  inline  ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>::Builder initUint16ListValue(unsigned int size);
  inline void adoptUint16ListValue(::capnp::Orphan< ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>> disownUint16ListValue();

  inline bool isUint32Value();
  inline  ::uint32_t getUint32Value();
  inline void setUint32Value( ::uint32_t value);

  inline bool isUint32ListValue();
  inline bool hasUint32ListValue();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getUint32ListValue();
  inline void setUint32ListValue( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setUint32ListValue(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initUint32ListValue(unsigned int size);
  inline void adoptUint32ListValue(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownUint32ListValue();

  inline bool isUint64Value();
  inline  ::uint64_t getUint64Value();
  inline void setUint64Value( ::uint64_t value);

  inline bool isUint64ListValue();
  inline bool hasUint64ListValue();
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder getUint64ListValue();
  inline void setUint64ListValue( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setUint64ListValue(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder initUint64ListValue(unsigned int size);
  inline void adoptUint64ListValue(::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> disownUint64ListValue();

  inline bool isFloat32Value();
  inline float getFloat32Value();
  inline void setFloat32Value(float value);

  inline bool isFloat32ListValue();
  inline bool hasFloat32ListValue();
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder getFloat32ListValue();
  inline void setFloat32ListValue( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setFloat32ListValue(::kj::ArrayPtr<const float> value);
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder initFloat32ListValue(unsigned int size);
  inline void adoptFloat32ListValue(::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> disownFloat32ListValue();

  inline bool isFloat64Value();
  inline double getFloat64Value();
  inline void setFloat64Value(double value);

  inline bool isFloat64ListValue();
  inline bool hasFloat64ListValue();
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder getFloat64ListValue();
  inline void setFloat64ListValue( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setFloat64ListValue(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder initFloat64ListValue(unsigned int size);
  inline void adoptFloat64ListValue(::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> disownFloat64ListValue();

  inline bool isTextValue();
  inline bool hasTextValue();
  inline  ::capnp::Text::Builder getTextValue();
  inline void setTextValue( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initTextValue(unsigned int size);
  inline void adoptTextValue(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownTextValue();

  inline bool isTextListValue();
  inline bool hasTextListValue();
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder getTextListValue();
  inline void setTextListValue( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value);
  inline void setTextListValue(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder initTextListValue(unsigned int size);
  inline void adoptTextListValue(::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> disownTextListValue();

  inline bool isDataValue();
  inline bool hasDataValue();
  inline  ::capnp::Data::Builder getDataValue();
  inline void setDataValue( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initDataValue(unsigned int size);
  inline void adoptDataValue(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownDataValue();

  inline bool isDataListValue();
  inline bool hasDataListValue();
  inline  ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Builder getDataListValue();
  inline void setDataListValue( ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Reader value);
  inline void setDataListValue(::kj::ArrayPtr<const  ::capnp::Data::Reader> value);
  inline  ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Builder initDataListValue(unsigned int size);
  inline void adoptDataListValue(::capnp::Orphan< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>> disownDataListValue();

  inline bool isAnyValue();
  inline bool hasAnyValue();
  inline  ::capnp::AnyStruct::Builder getAnyValue();
  inline void setAnyValue( ::capnp::AnyStruct::Reader value);
  template <typename T_>
  inline ::capnp::BuilderFor<T_> initAnyValueAs();
  inline void adoptAnyValue(::capnp::Orphan< ::capnp::AnyStruct>&& value);
  inline ::capnp::Orphan< ::capnp::AnyStruct> disownAnyValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::Entry::Value::Pipeline {
public:
  typedef Value Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::Entry::GetKeyParams::Reader {
public:
  typedef GetKeyParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::Entry::GetKeyParams::Builder {
public:
  typedef GetKeyParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::Entry::GetKeyParams::Pipeline {
public:
  typedef GetKeyParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::Entry::GetKeyResults::Reader {
public:
  typedef GetKeyResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasKey() const;
  inline  ::capnp::Text::Reader getKey() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::Entry::GetKeyResults::Builder {
public:
  typedef GetKeyResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasKey();
  inline  ::capnp::Text::Builder getKey();
  inline void setKey( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initKey(unsigned int size);
  inline void adoptKey(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownKey();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::Entry::GetKeyResults::Pipeline {
public:
  typedef GetKeyResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::Entry::GetValueParams::Reader {
public:
  typedef GetValueParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::Entry::GetValueParams::Builder {
public:
  typedef GetValueParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::Entry::GetValueParams::Pipeline {
public:
  typedef GetValueParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::Entry::GetValueResults::Reader {
public:
  typedef GetValueResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasValue() const;
  inline  ::mas::schema::storage::Store::Container::Entry::Value::Reader getValue() const;

  inline bool getIsUnset() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::Entry::GetValueResults::Builder {
public:
  typedef GetValueResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasValue();
  inline  ::mas::schema::storage::Store::Container::Entry::Value::Builder getValue();
  inline void setValue( ::mas::schema::storage::Store::Container::Entry::Value::Reader value);
  inline  ::mas::schema::storage::Store::Container::Entry::Value::Builder initValue();
  inline void adoptValue(::capnp::Orphan< ::mas::schema::storage::Store::Container::Entry::Value>&& value);
  inline ::capnp::Orphan< ::mas::schema::storage::Store::Container::Entry::Value> disownValue();

  inline bool getIsUnset();
  inline void setIsUnset(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::Entry::GetValueResults::Pipeline {
public:
  typedef GetValueResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::storage::Store::Container::Entry::Value::Pipeline getValue();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::Entry::SetValueParams::Reader {
public:
  typedef SetValueParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasValue() const;
  inline  ::mas::schema::storage::Store::Container::Entry::Value::Reader getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::Entry::SetValueParams::Builder {
public:
  typedef SetValueParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasValue();
  inline  ::mas::schema::storage::Store::Container::Entry::Value::Builder getValue();
  inline void setValue( ::mas::schema::storage::Store::Container::Entry::Value::Reader value);
  inline  ::mas::schema::storage::Store::Container::Entry::Value::Builder initValue();
  inline void adoptValue(::capnp::Orphan< ::mas::schema::storage::Store::Container::Entry::Value>&& value);
  inline ::capnp::Orphan< ::mas::schema::storage::Store::Container::Entry::Value> disownValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::Entry::SetValueParams::Pipeline {
public:
  typedef SetValueParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::storage::Store::Container::Entry::Value::Pipeline getValue();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::Entry::SetValueResults::Reader {
public:
  typedef SetValueResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getSuccess() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::Entry::SetValueResults::Builder {
public:
  typedef SetValueResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getSuccess();
  inline void setSuccess(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::Entry::SetValueResults::Pipeline {
public:
  typedef SetValueResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::ExportParams::Reader {
public:
  typedef ExportParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::ExportParams::Builder {
public:
  typedef ExportParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::ExportParams::Pipeline {
public:
  typedef ExportParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::ExportResults::Reader {
public:
  typedef ExportResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasJson() const;
  inline  ::capnp::Text::Reader getJson() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::ExportResults::Builder {
public:
  typedef ExportResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasJson();
  inline  ::capnp::Text::Builder getJson();
  inline void setJson( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initJson(unsigned int size);
  inline void adoptJson(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownJson();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::ExportResults::Pipeline {
public:
  typedef ExportResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::DownloadEntriesParams::Reader {
public:
  typedef DownloadEntriesParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::DownloadEntriesParams::Builder {
public:
  typedef DownloadEntriesParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::DownloadEntriesParams::Pipeline {
public:
  typedef DownloadEntriesParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::DownloadEntriesResults::Reader {
public:
  typedef DownloadEntriesResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasEntries() const;
  inline  ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>::Reader getEntries() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::DownloadEntriesResults::Builder {
public:
  typedef DownloadEntriesResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasEntries();
  inline  ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>::Builder getEntries();
  inline void setEntries( ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>::Builder initEntries(unsigned int size);
  inline void adoptEntries(::capnp::Orphan< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>> disownEntries();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::DownloadEntriesResults::Pipeline {
public:
  typedef DownloadEntriesResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::ListEntriesParams::Reader {
public:
  typedef ListEntriesParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::ListEntriesParams::Builder {
public:
  typedef ListEntriesParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::ListEntriesParams::Pipeline {
public:
  typedef ListEntriesParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::ListEntriesResults::Reader {
public:
  typedef ListEntriesResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasEntries() const;
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::storage::Store::Container::Entry,  ::capnp::Kind::INTERFACE>::Reader getEntries() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::ListEntriesResults::Builder {
public:
  typedef ListEntriesResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasEntries();
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::storage::Store::Container::Entry,  ::capnp::Kind::INTERFACE>::Builder getEntries();
  inline void setEntries( ::capnp::List< ::mas::schema::storage::Store::Container::Entry,  ::capnp::Kind::INTERFACE>::Reader value);
  inline  ::capnp::List< ::mas::schema::storage::Store::Container::Entry,  ::capnp::Kind::INTERFACE>::Builder initEntries(unsigned int size);
  inline void adoptEntries(::capnp::Orphan< ::capnp::List< ::mas::schema::storage::Store::Container::Entry,  ::capnp::Kind::INTERFACE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::storage::Store::Container::Entry,  ::capnp::Kind::INTERFACE>> disownEntries();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::ListEntriesResults::Pipeline {
public:
  typedef ListEntriesResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::GetEntryParams::Reader {
public:
  typedef GetEntryParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasKey() const;
  inline  ::capnp::Text::Reader getKey() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::GetEntryParams::Builder {
public:
  typedef GetEntryParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasKey();
  inline  ::capnp::Text::Builder getKey();
  inline void setKey( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initKey(unsigned int size);
  inline void adoptKey(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownKey();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::GetEntryParams::Pipeline {
public:
  typedef GetEntryParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::GetEntryResults::Reader {
public:
  typedef GetEntryResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasEntry() const;
#if !CAPNP_LITE
  inline  ::mas::schema::storage::Store::Container::Entry::Client getEntry() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::GetEntryResults::Builder {
public:
  typedef GetEntryResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasEntry();
#if !CAPNP_LITE
  inline  ::mas::schema::storage::Store::Container::Entry::Client getEntry();
  inline void setEntry( ::mas::schema::storage::Store::Container::Entry::Client&& value);
  inline void setEntry( ::mas::schema::storage::Store::Container::Entry::Client& value);
  inline void adoptEntry(::capnp::Orphan< ::mas::schema::storage::Store::Container::Entry>&& value);
  inline ::capnp::Orphan< ::mas::schema::storage::Store::Container::Entry> disownEntry();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::GetEntryResults::Pipeline {
public:
  typedef GetEntryResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::storage::Store::Container::Entry::Client getEntry();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::RemoveEntryParams::Reader {
public:
  typedef RemoveEntryParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasKey() const;
  inline  ::capnp::Text::Reader getKey() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::RemoveEntryParams::Builder {
public:
  typedef RemoveEntryParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasKey();
  inline  ::capnp::Text::Builder getKey();
  inline void setKey( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initKey(unsigned int size);
  inline void adoptKey(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownKey();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::RemoveEntryParams::Pipeline {
public:
  typedef RemoveEntryParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::RemoveEntryResults::Reader {
public:
  typedef RemoveEntryResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getSuccess() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::RemoveEntryResults::Builder {
public:
  typedef RemoveEntryResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getSuccess();
  inline void setSuccess(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::RemoveEntryResults::Pipeline {
public:
  typedef RemoveEntryResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::ClearParams::Reader {
public:
  typedef ClearParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::ClearParams::Builder {
public:
  typedef ClearParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::ClearParams::Pipeline {
public:
  typedef ClearParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::ClearResults::Reader {
public:
  typedef ClearResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getSuccess() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::ClearResults::Builder {
public:
  typedef ClearResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getSuccess();
  inline void setSuccess(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::ClearResults::Pipeline {
public:
  typedef ClearResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::AddEntryParams::Reader {
public:
  typedef AddEntryParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasKey() const;
  inline  ::capnp::Text::Reader getKey() const;

  inline bool hasValue() const;
  inline  ::mas::schema::storage::Store::Container::Entry::Value::Reader getValue() const;

  inline bool getReplaceExisting() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::AddEntryParams::Builder {
public:
  typedef AddEntryParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasKey();
  inline  ::capnp::Text::Builder getKey();
  inline void setKey( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initKey(unsigned int size);
  inline void adoptKey(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownKey();

  inline bool hasValue();
  inline  ::mas::schema::storage::Store::Container::Entry::Value::Builder getValue();
  inline void setValue( ::mas::schema::storage::Store::Container::Entry::Value::Reader value);
  inline  ::mas::schema::storage::Store::Container::Entry::Value::Builder initValue();
  inline void adoptValue(::capnp::Orphan< ::mas::schema::storage::Store::Container::Entry::Value>&& value);
  inline ::capnp::Orphan< ::mas::schema::storage::Store::Container::Entry::Value> disownValue();

  inline bool getReplaceExisting();
  inline void setReplaceExisting(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::AddEntryParams::Pipeline {
public:
  typedef AddEntryParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::storage::Store::Container::Entry::Value::Pipeline getValue();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::AddEntryResults::Reader {
public:
  typedef AddEntryResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasEntry() const;
#if !CAPNP_LITE
  inline  ::mas::schema::storage::Store::Container::Entry::Client getEntry() const;
#endif  // !CAPNP_LITE

  inline bool getSuccess() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::AddEntryResults::Builder {
public:
  typedef AddEntryResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasEntry();
#if !CAPNP_LITE
  inline  ::mas::schema::storage::Store::Container::Entry::Client getEntry();
  inline void setEntry( ::mas::schema::storage::Store::Container::Entry::Client&& value);
  inline void setEntry( ::mas::schema::storage::Store::Container::Entry::Client& value);
  inline void adoptEntry(::capnp::Orphan< ::mas::schema::storage::Store::Container::Entry>&& value);
  inline ::capnp::Orphan< ::mas::schema::storage::Store::Container::Entry> disownEntry();
#endif  // !CAPNP_LITE

  inline bool getSuccess();
  inline void setSuccess(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::AddEntryResults::Pipeline {
public:
  typedef AddEntryResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::storage::Store::Container::Entry::Client getEntry();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::ImportExportData::Reader {
public:
  typedef ImportExportData Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasInfo() const;
  inline  ::mas::schema::common::IdInformation::Reader getInfo() const;

  inline bool hasEntries() const;
  inline  ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>::Reader getEntries() const;

  inline bool hasIsAnyValue() const;
  inline  ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Reader getIsAnyValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::ImportExportData::Builder {
public:
  typedef ImportExportData Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasInfo();
  inline  ::mas::schema::common::IdInformation::Builder getInfo();
  inline void setInfo( ::mas::schema::common::IdInformation::Reader value);
  inline  ::mas::schema::common::IdInformation::Builder initInfo();
  inline void adoptInfo(::capnp::Orphan< ::mas::schema::common::IdInformation>&& value);
  inline ::capnp::Orphan< ::mas::schema::common::IdInformation> disownInfo();

  inline bool hasEntries();
  inline  ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>::Builder getEntries();
  inline void setEntries( ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>::Builder initEntries(unsigned int size);
  inline void adoptEntries(::capnp::Orphan< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>> disownEntries();

  inline bool hasIsAnyValue();
  inline  ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Builder getIsAnyValue();
  inline void setIsAnyValue( ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setIsAnyValue(::kj::ArrayPtr<const bool> value);
  inline  ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Builder initIsAnyValue(unsigned int size);
  inline void adoptIsAnyValue(::capnp::Orphan< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>> disownIsAnyValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::ImportExportData::Pipeline {
public:
  typedef ImportExportData Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::common::IdInformation::Pipeline getInfo();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::NewContainerParams::Reader {
public:
  typedef NewContainerParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasDescription() const;
  inline  ::capnp::Text::Reader getDescription() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::NewContainerParams::Builder {
public:
  typedef NewContainerParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasDescription();
  inline  ::capnp::Text::Builder getDescription();
  inline void setDescription( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initDescription(unsigned int size);
  inline void adoptDescription(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownDescription();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::NewContainerParams::Pipeline {
public:
  typedef NewContainerParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::NewContainerResults::Reader {
public:
  typedef NewContainerResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasContainer() const;
#if !CAPNP_LITE
  inline  ::mas::schema::storage::Store::Container::Client getContainer() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::NewContainerResults::Builder {
public:
  typedef NewContainerResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContainer();
#if !CAPNP_LITE
  inline  ::mas::schema::storage::Store::Container::Client getContainer();
  inline void setContainer( ::mas::schema::storage::Store::Container::Client&& value);
  inline void setContainer( ::mas::schema::storage::Store::Container::Client& value);
  inline void adoptContainer(::capnp::Orphan< ::mas::schema::storage::Store::Container>&& value);
  inline ::capnp::Orphan< ::mas::schema::storage::Store::Container> disownContainer();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::NewContainerResults::Pipeline {
public:
  typedef NewContainerResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::storage::Store::Container::Client getContainer();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::ContainerWithIdParams::Reader {
public:
  typedef ContainerWithIdParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasId() const;
  inline  ::capnp::Text::Reader getId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::ContainerWithIdParams::Builder {
public:
  typedef ContainerWithIdParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasId();
  inline  ::capnp::Text::Builder getId();
  inline void setId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initId(unsigned int size);
  inline void adoptId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownId();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::ContainerWithIdParams::Pipeline {
public:
  typedef ContainerWithIdParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::ContainerWithIdResults::Reader {
public:
  typedef ContainerWithIdResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasContainer() const;
#if !CAPNP_LITE
  inline  ::mas::schema::storage::Store::Container::Client getContainer() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::ContainerWithIdResults::Builder {
public:
  typedef ContainerWithIdResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContainer();
#if !CAPNP_LITE
  inline  ::mas::schema::storage::Store::Container::Client getContainer();
  inline void setContainer( ::mas::schema::storage::Store::Container::Client&& value);
  inline void setContainer( ::mas::schema::storage::Store::Container::Client& value);
  inline void adoptContainer(::capnp::Orphan< ::mas::schema::storage::Store::Container>&& value);
  inline ::capnp::Orphan< ::mas::schema::storage::Store::Container> disownContainer();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::ContainerWithIdResults::Pipeline {
public:
  typedef ContainerWithIdResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::storage::Store::Container::Client getContainer();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::ListContainersParams::Reader {
public:
  typedef ListContainersParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::ListContainersParams::Builder {
public:
  typedef ListContainersParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::ListContainersParams::Pipeline {
public:
  typedef ListContainersParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::ListContainersResults::Reader {
public:
  typedef ListContainersResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasContainers() const;
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>::Reader getContainers() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::ListContainersResults::Builder {
public:
  typedef ListContainersResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContainers();
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>::Builder getContainers();
  inline void setContainers( ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>::Reader value);
  inline  ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>::Builder initContainers(unsigned int size);
  inline void adoptContainers(::capnp::Orphan< ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>> disownContainers();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::ListContainersResults::Pipeline {
public:
  typedef ListContainersResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::RemoveContainerParams::Reader {
public:
  typedef RemoveContainerParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasId() const;
  inline  ::capnp::Text::Reader getId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::RemoveContainerParams::Builder {
public:
  typedef RemoveContainerParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasId();
  inline  ::capnp::Text::Builder getId();
  inline void setId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initId(unsigned int size);
  inline void adoptId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownId();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::RemoveContainerParams::Pipeline {
public:
  typedef RemoveContainerParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::RemoveContainerResults::Reader {
public:
  typedef RemoveContainerResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getSuccess() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::RemoveContainerResults::Builder {
public:
  typedef RemoveContainerResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getSuccess();
  inline void setSuccess(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::RemoveContainerResults::Pipeline {
public:
  typedef RemoveContainerResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::ImportContainerParams::Reader {
public:
  typedef ImportContainerParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasJson() const;
  inline  ::capnp::Text::Reader getJson() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::ImportContainerParams::Builder {
public:
  typedef ImportContainerParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasJson();
  inline  ::capnp::Text::Builder getJson();
  inline void setJson( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initJson(unsigned int size);
  inline void adoptJson(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownJson();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::ImportContainerParams::Pipeline {
public:
  typedef ImportContainerParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::ImportContainerResults::Reader {
public:
  typedef ImportContainerResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasContainer() const;
#if !CAPNP_LITE
  inline  ::mas::schema::storage::Store::Container::Client getContainer() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::ImportContainerResults::Builder {
public:
  typedef ImportContainerResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContainer();
#if !CAPNP_LITE
  inline  ::mas::schema::storage::Store::Container::Client getContainer();
  inline void setContainer( ::mas::schema::storage::Store::Container::Client&& value);
  inline void setContainer( ::mas::schema::storage::Store::Container::Client& value);
  inline void adoptContainer(::capnp::Orphan< ::mas::schema::storage::Store::Container>&& value);
  inline ::capnp::Orphan< ::mas::schema::storage::Store::Container> disownContainer();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::ImportContainerResults::Pipeline {
public:
  typedef ImportContainerResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::storage::Store::Container::Client getContainer();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

#if !CAPNP_LITE
inline Store::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Store::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Store::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Store::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Store::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::storage::Store::Client& Store::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::storage::Store::Client& Store::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
#if !CAPNP_LITE
inline Store::Container::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Store::Container::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Store::Container::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Store::Container::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Store::Container::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::storage::Store::Container::Client& Store::Container::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::storage::Store::Container::Client& Store::Container::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
#if !CAPNP_LITE
inline Store::Container::Entry::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Store::Container::Entry::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Store::Container::Entry::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Store::Container::Entry::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Store::Container::Entry::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::storage::Store::Container::Entry::Client& Store::Container::Entry::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::storage::Store::Container::Entry::Client& Store::Container::Entry::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline  ::mas::schema::storage::Store::Container::Entry::Value::Which Store::Container::Entry::Value::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline  ::mas::schema::storage::Store::Container::Entry::Value::Which Store::Container::Entry::Value::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool Store::Container::Entry::Value::Reader::isBoolValue() const {
  return which() == Store::Container::Entry::Value::BOOL_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isBoolValue() {
  return which() == Store::Container::Entry::Value::BOOL_VALUE;
}
inline bool Store::Container::Entry::Value::Reader::getBoolValue() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::BOOL_VALUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Store::Container::Entry::Value::Builder::getBoolValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::BOOL_VALUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Store::Container::Entry::Value::Builder::setBoolValue(bool value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::BOOL_VALUE);
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Store::Container::Entry::Value::Reader::isBoolListValue() const {
  return which() == Store::Container::Entry::Value::BOOL_LIST_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isBoolListValue() {
  return which() == Store::Container::Entry::Value::BOOL_LIST_VALUE;
}
inline bool Store::Container::Entry::Value::Reader::hasBoolListValue() const {
  if (which() != Store::Container::Entry::Value::BOOL_LIST_VALUE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::Entry::Value::Builder::hasBoolListValue() {
  if (which() != Store::Container::Entry::Value::BOOL_LIST_VALUE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Reader Store::Container::Entry::Value::Reader::getBoolListValue() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::BOOL_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Builder Store::Container::Entry::Value::Builder::getBoolListValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::BOOL_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::Entry::Value::Builder::setBoolListValue( ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::BOOL_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Store::Container::Entry::Value::Builder::setBoolListValue(::kj::ArrayPtr<const bool> value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::BOOL_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Builder Store::Container::Entry::Value::Builder::initBoolListValue(unsigned int size) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::BOOL_LIST_VALUE);
  return ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::Entry::Value::Builder::adoptBoolListValue(
    ::capnp::Orphan< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>&& value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::BOOL_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>> Store::Container::Entry::Value::Builder::disownBoolListValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::BOOL_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::Entry::Value::Reader::isInt8Value() const {
  return which() == Store::Container::Entry::Value::INT8_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isInt8Value() {
  return which() == Store::Container::Entry::Value::INT8_VALUE;
}
inline  ::int8_t Store::Container::Entry::Value::Reader::getInt8Value() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::INT8_VALUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int8_t Store::Container::Entry::Value::Builder::getInt8Value() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::INT8_VALUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Store::Container::Entry::Value::Builder::setInt8Value( ::int8_t value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::INT8_VALUE);
  _builder.setDataField< ::int8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Store::Container::Entry::Value::Reader::isInt8ListValue() const {
  return which() == Store::Container::Entry::Value::INT8_LIST_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isInt8ListValue() {
  return which() == Store::Container::Entry::Value::INT8_LIST_VALUE;
}
inline bool Store::Container::Entry::Value::Reader::hasInt8ListValue() const {
  if (which() != Store::Container::Entry::Value::INT8_LIST_VALUE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::Entry::Value::Builder::hasInt8ListValue() {
  if (which() != Store::Container::Entry::Value::INT8_LIST_VALUE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int8_t,  ::capnp::Kind::PRIMITIVE>::Reader Store::Container::Entry::Value::Reader::getInt8ListValue() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::INT8_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int8_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::int8_t,  ::capnp::Kind::PRIMITIVE>::Builder Store::Container::Entry::Value::Builder::getInt8ListValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::INT8_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int8_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::Entry::Value::Builder::setInt8ListValue( ::capnp::List< ::int8_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::INT8_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::int8_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Store::Container::Entry::Value::Builder::setInt8ListValue(::kj::ArrayPtr<const  ::int8_t> value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::INT8_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::int8_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int8_t,  ::capnp::Kind::PRIMITIVE>::Builder Store::Container::Entry::Value::Builder::initInt8ListValue(unsigned int size) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::INT8_LIST_VALUE);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int8_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::Entry::Value::Builder::adoptInt8ListValue(
    ::capnp::Orphan< ::capnp::List< ::int8_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::INT8_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::int8_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int8_t,  ::capnp::Kind::PRIMITIVE>> Store::Container::Entry::Value::Builder::disownInt8ListValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::INT8_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int8_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::Entry::Value::Reader::isInt16Value() const {
  return which() == Store::Container::Entry::Value::INT16_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isInt16Value() {
  return which() == Store::Container::Entry::Value::INT16_VALUE;
}
inline  ::int16_t Store::Container::Entry::Value::Reader::getInt16Value() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::INT16_VALUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int16_t Store::Container::Entry::Value::Builder::getInt16Value() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::INT16_VALUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Store::Container::Entry::Value::Builder::setInt16Value( ::int16_t value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::INT16_VALUE);
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Store::Container::Entry::Value::Reader::isInt16ListValue() const {
  return which() == Store::Container::Entry::Value::INT16_LIST_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isInt16ListValue() {
  return which() == Store::Container::Entry::Value::INT16_LIST_VALUE;
}
inline bool Store::Container::Entry::Value::Reader::hasInt16ListValue() const {
  if (which() != Store::Container::Entry::Value::INT16_LIST_VALUE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::Entry::Value::Builder::hasInt16ListValue() {
  if (which() != Store::Container::Entry::Value::INT16_LIST_VALUE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>::Reader Store::Container::Entry::Value::Reader::getInt16ListValue() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::INT16_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>::Builder Store::Container::Entry::Value::Builder::getInt16ListValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::INT16_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::Entry::Value::Builder::setInt16ListValue( ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::INT16_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Store::Container::Entry::Value::Builder::setInt16ListValue(::kj::ArrayPtr<const  ::int16_t> value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::INT16_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>::Builder Store::Container::Entry::Value::Builder::initInt16ListValue(unsigned int size) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::INT16_LIST_VALUE);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::Entry::Value::Builder::adoptInt16ListValue(
    ::capnp::Orphan< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::INT16_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>> Store::Container::Entry::Value::Builder::disownInt16ListValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::INT16_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int16_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::Entry::Value::Reader::isInt32Value() const {
  return which() == Store::Container::Entry::Value::INT32_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isInt32Value() {
  return which() == Store::Container::Entry::Value::INT32_VALUE;
}
inline  ::int32_t Store::Container::Entry::Value::Reader::getInt32Value() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::INT32_VALUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Store::Container::Entry::Value::Builder::getInt32Value() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::INT32_VALUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Store::Container::Entry::Value::Builder::setInt32Value( ::int32_t value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::INT32_VALUE);
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Store::Container::Entry::Value::Reader::isInt32ListValue() const {
  return which() == Store::Container::Entry::Value::INT32_LIST_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isInt32ListValue() {
  return which() == Store::Container::Entry::Value::INT32_LIST_VALUE;
}
inline bool Store::Container::Entry::Value::Reader::hasInt32ListValue() const {
  if (which() != Store::Container::Entry::Value::INT32_LIST_VALUE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::Entry::Value::Builder::hasInt32ListValue() {
  if (which() != Store::Container::Entry::Value::INT32_LIST_VALUE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Reader Store::Container::Entry::Value::Reader::getInt32ListValue() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::INT32_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Builder Store::Container::Entry::Value::Builder::getInt32ListValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::INT32_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::Entry::Value::Builder::setInt32ListValue( ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::INT32_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Store::Container::Entry::Value::Builder::setInt32ListValue(::kj::ArrayPtr<const  ::int32_t> value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::INT32_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>::Builder Store::Container::Entry::Value::Builder::initInt32ListValue(unsigned int size) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::INT32_LIST_VALUE);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::Entry::Value::Builder::adoptInt32ListValue(
    ::capnp::Orphan< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::INT32_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>> Store::Container::Entry::Value::Builder::disownInt32ListValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::INT32_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::Entry::Value::Reader::isInt64Value() const {
  return which() == Store::Container::Entry::Value::INT64_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isInt64Value() {
  return which() == Store::Container::Entry::Value::INT64_VALUE;
}
inline  ::int64_t Store::Container::Entry::Value::Reader::getInt64Value() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::INT64_VALUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int64_t Store::Container::Entry::Value::Builder::getInt64Value() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::INT64_VALUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Store::Container::Entry::Value::Builder::setInt64Value( ::int64_t value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::INT64_VALUE);
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Store::Container::Entry::Value::Reader::isInt64ListValue() const {
  return which() == Store::Container::Entry::Value::INT64_LIST_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isInt64ListValue() {
  return which() == Store::Container::Entry::Value::INT64_LIST_VALUE;
}
inline bool Store::Container::Entry::Value::Reader::hasInt64ListValue() const {
  if (which() != Store::Container::Entry::Value::INT64_LIST_VALUE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::Entry::Value::Builder::hasInt64ListValue() {
  if (which() != Store::Container::Entry::Value::INT64_LIST_VALUE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Reader Store::Container::Entry::Value::Reader::getInt64ListValue() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::INT64_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Builder Store::Container::Entry::Value::Builder::getInt64ListValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::INT64_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::Entry::Value::Builder::setInt64ListValue( ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::INT64_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Store::Container::Entry::Value::Builder::setInt64ListValue(::kj::ArrayPtr<const  ::int64_t> value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::INT64_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Builder Store::Container::Entry::Value::Builder::initInt64ListValue(unsigned int size) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::INT64_LIST_VALUE);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::Entry::Value::Builder::adoptInt64ListValue(
    ::capnp::Orphan< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::INT64_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>> Store::Container::Entry::Value::Builder::disownInt64ListValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::INT64_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::Entry::Value::Reader::isUint8Value() const {
  return which() == Store::Container::Entry::Value::UINT8_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isUint8Value() {
  return which() == Store::Container::Entry::Value::UINT8_VALUE;
}
inline  ::uint8_t Store::Container::Entry::Value::Reader::getUint8Value() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::UINT8_VALUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Store::Container::Entry::Value::Builder::getUint8Value() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::UINT8_VALUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Store::Container::Entry::Value::Builder::setUint8Value( ::uint8_t value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::UINT8_VALUE);
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Store::Container::Entry::Value::Reader::isUint8ListValue() const {
  return which() == Store::Container::Entry::Value::UINT8_LIST_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isUint8ListValue() {
  return which() == Store::Container::Entry::Value::UINT8_LIST_VALUE;
}
inline bool Store::Container::Entry::Value::Reader::hasUint8ListValue() const {
  if (which() != Store::Container::Entry::Value::UINT8_LIST_VALUE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::Entry::Value::Builder::hasUint8ListValue() {
  if (which() != Store::Container::Entry::Value::UINT8_LIST_VALUE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Reader Store::Container::Entry::Value::Reader::getUint8ListValue() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::UINT8_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Builder Store::Container::Entry::Value::Builder::getUint8ListValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::UINT8_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::Entry::Value::Builder::setUint8ListValue( ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::UINT8_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Store::Container::Entry::Value::Builder::setUint8ListValue(::kj::ArrayPtr<const  ::uint8_t> value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::UINT8_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Builder Store::Container::Entry::Value::Builder::initUint8ListValue(unsigned int size) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::UINT8_LIST_VALUE);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::Entry::Value::Builder::adoptUint8ListValue(
    ::capnp::Orphan< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::UINT8_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>> Store::Container::Entry::Value::Builder::disownUint8ListValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::UINT8_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::Entry::Value::Reader::isUint16Value() const {
  return which() == Store::Container::Entry::Value::UINT16_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isUint16Value() {
  return which() == Store::Container::Entry::Value::UINT16_VALUE;
}
inline  ::uint16_t Store::Container::Entry::Value::Reader::getUint16Value() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::UINT16_VALUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Store::Container::Entry::Value::Builder::getUint16Value() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::UINT16_VALUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Store::Container::Entry::Value::Builder::setUint16Value( ::uint16_t value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::UINT16_VALUE);
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Store::Container::Entry::Value::Reader::isUint16ListValue() const {
  return which() == Store::Container::Entry::Value::UINT16_LIST_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isUint16ListValue() {
  return which() == Store::Container::Entry::Value::UINT16_LIST_VALUE;
}
inline bool Store::Container::Entry::Value::Reader::hasUint16ListValue() const {
  if (which() != Store::Container::Entry::Value::UINT16_LIST_VALUE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::Entry::Value::Builder::hasUint16ListValue() {
  if (which() != Store::Container::Entry::Value::UINT16_LIST_VALUE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>::Reader Store::Container::Entry::Value::Reader::getUint16ListValue() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::UINT16_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>::Builder Store::Container::Entry::Value::Builder::getUint16ListValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::UINT16_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::Entry::Value::Builder::setUint16ListValue( ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::UINT16_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Store::Container::Entry::Value::Builder::setUint16ListValue(::kj::ArrayPtr<const  ::uint16_t> value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::UINT16_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>::Builder Store::Container::Entry::Value::Builder::initUint16ListValue(unsigned int size) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::UINT16_LIST_VALUE);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::Entry::Value::Builder::adoptUint16ListValue(
    ::capnp::Orphan< ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::UINT16_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>> Store::Container::Entry::Value::Builder::disownUint16ListValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::UINT16_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::Entry::Value::Reader::isUint32Value() const {
  return which() == Store::Container::Entry::Value::UINT32_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isUint32Value() {
  return which() == Store::Container::Entry::Value::UINT32_VALUE;
}
inline  ::uint32_t Store::Container::Entry::Value::Reader::getUint32Value() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::UINT32_VALUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Store::Container::Entry::Value::Builder::getUint32Value() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::UINT32_VALUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Store::Container::Entry::Value::Builder::setUint32Value( ::uint32_t value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::UINT32_VALUE);
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Store::Container::Entry::Value::Reader::isUint32ListValue() const {
  return which() == Store::Container::Entry::Value::UINT32_LIST_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isUint32ListValue() {
  return which() == Store::Container::Entry::Value::UINT32_LIST_VALUE;
}
inline bool Store::Container::Entry::Value::Reader::hasUint32ListValue() const {
  if (which() != Store::Container::Entry::Value::UINT32_LIST_VALUE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::Entry::Value::Builder::hasUint32ListValue() {
  if (which() != Store::Container::Entry::Value::UINT32_LIST_VALUE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader Store::Container::Entry::Value::Reader::getUint32ListValue() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::UINT32_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Store::Container::Entry::Value::Builder::getUint32ListValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::UINT32_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::Entry::Value::Builder::setUint32ListValue( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::UINT32_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Store::Container::Entry::Value::Builder::setUint32ListValue(::kj::ArrayPtr<const  ::uint32_t> value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::UINT32_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Store::Container::Entry::Value::Builder::initUint32ListValue(unsigned int size) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::UINT32_LIST_VALUE);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::Entry::Value::Builder::adoptUint32ListValue(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::UINT32_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> Store::Container::Entry::Value::Builder::disownUint32ListValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::UINT32_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::Entry::Value::Reader::isUint64Value() const {
  return which() == Store::Container::Entry::Value::UINT64_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isUint64Value() {
  return which() == Store::Container::Entry::Value::UINT64_VALUE;
}
inline  ::uint64_t Store::Container::Entry::Value::Reader::getUint64Value() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::UINT64_VALUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Store::Container::Entry::Value::Builder::getUint64Value() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::UINT64_VALUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Store::Container::Entry::Value::Builder::setUint64Value( ::uint64_t value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::UINT64_VALUE);
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Store::Container::Entry::Value::Reader::isUint64ListValue() const {
  return which() == Store::Container::Entry::Value::UINT64_LIST_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isUint64ListValue() {
  return which() == Store::Container::Entry::Value::UINT64_LIST_VALUE;
}
inline bool Store::Container::Entry::Value::Reader::hasUint64ListValue() const {
  if (which() != Store::Container::Entry::Value::UINT64_LIST_VALUE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::Entry::Value::Builder::hasUint64ListValue() {
  if (which() != Store::Container::Entry::Value::UINT64_LIST_VALUE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader Store::Container::Entry::Value::Reader::getUint64ListValue() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::UINT64_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder Store::Container::Entry::Value::Builder::getUint64ListValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::UINT64_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::Entry::Value::Builder::setUint64ListValue( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::UINT64_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Store::Container::Entry::Value::Builder::setUint64ListValue(::kj::ArrayPtr<const  ::uint64_t> value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::UINT64_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder Store::Container::Entry::Value::Builder::initUint64ListValue(unsigned int size) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::UINT64_LIST_VALUE);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::Entry::Value::Builder::adoptUint64ListValue(
    ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::UINT64_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> Store::Container::Entry::Value::Builder::disownUint64ListValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::UINT64_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::Entry::Value::Reader::isFloat32Value() const {
  return which() == Store::Container::Entry::Value::FLOAT32_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isFloat32Value() {
  return which() == Store::Container::Entry::Value::FLOAT32_VALUE;
}
inline float Store::Container::Entry::Value::Reader::getFloat32Value() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::FLOAT32_VALUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Store::Container::Entry::Value::Builder::getFloat32Value() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::FLOAT32_VALUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Store::Container::Entry::Value::Builder::setFloat32Value(float value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::FLOAT32_VALUE);
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Store::Container::Entry::Value::Reader::isFloat32ListValue() const {
  return which() == Store::Container::Entry::Value::FLOAT32_LIST_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isFloat32ListValue() {
  return which() == Store::Container::Entry::Value::FLOAT32_LIST_VALUE;
}
inline bool Store::Container::Entry::Value::Reader::hasFloat32ListValue() const {
  if (which() != Store::Container::Entry::Value::FLOAT32_LIST_VALUE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::Entry::Value::Builder::hasFloat32ListValue() {
  if (which() != Store::Container::Entry::Value::FLOAT32_LIST_VALUE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader Store::Container::Entry::Value::Reader::getFloat32ListValue() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::FLOAT32_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder Store::Container::Entry::Value::Builder::getFloat32ListValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::FLOAT32_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::Entry::Value::Builder::setFloat32ListValue( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::FLOAT32_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Store::Container::Entry::Value::Builder::setFloat32ListValue(::kj::ArrayPtr<const float> value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::FLOAT32_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder Store::Container::Entry::Value::Builder::initFloat32ListValue(unsigned int size) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::FLOAT32_LIST_VALUE);
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::Entry::Value::Builder::adoptFloat32ListValue(
    ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::FLOAT32_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> Store::Container::Entry::Value::Builder::disownFloat32ListValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::FLOAT32_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::Entry::Value::Reader::isFloat64Value() const {
  return which() == Store::Container::Entry::Value::FLOAT64_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isFloat64Value() {
  return which() == Store::Container::Entry::Value::FLOAT64_VALUE;
}
inline double Store::Container::Entry::Value::Reader::getFloat64Value() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::FLOAT64_VALUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Store::Container::Entry::Value::Builder::getFloat64Value() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::FLOAT64_VALUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Store::Container::Entry::Value::Builder::setFloat64Value(double value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::FLOAT64_VALUE);
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Store::Container::Entry::Value::Reader::isFloat64ListValue() const {
  return which() == Store::Container::Entry::Value::FLOAT64_LIST_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isFloat64ListValue() {
  return which() == Store::Container::Entry::Value::FLOAT64_LIST_VALUE;
}
inline bool Store::Container::Entry::Value::Reader::hasFloat64ListValue() const {
  if (which() != Store::Container::Entry::Value::FLOAT64_LIST_VALUE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::Entry::Value::Builder::hasFloat64ListValue() {
  if (which() != Store::Container::Entry::Value::FLOAT64_LIST_VALUE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader Store::Container::Entry::Value::Reader::getFloat64ListValue() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::FLOAT64_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder Store::Container::Entry::Value::Builder::getFloat64ListValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::FLOAT64_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::Entry::Value::Builder::setFloat64ListValue( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::FLOAT64_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Store::Container::Entry::Value::Builder::setFloat64ListValue(::kj::ArrayPtr<const double> value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::FLOAT64_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder Store::Container::Entry::Value::Builder::initFloat64ListValue(unsigned int size) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::FLOAT64_LIST_VALUE);
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::Entry::Value::Builder::adoptFloat64ListValue(
    ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::FLOAT64_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> Store::Container::Entry::Value::Builder::disownFloat64ListValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::FLOAT64_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::Entry::Value::Reader::isTextValue() const {
  return which() == Store::Container::Entry::Value::TEXT_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isTextValue() {
  return which() == Store::Container::Entry::Value::TEXT_VALUE;
}
inline bool Store::Container::Entry::Value::Reader::hasTextValue() const {
  if (which() != Store::Container::Entry::Value::TEXT_VALUE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::Entry::Value::Builder::hasTextValue() {
  if (which() != Store::Container::Entry::Value::TEXT_VALUE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Store::Container::Entry::Value::Reader::getTextValue() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::TEXT_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Store::Container::Entry::Value::Builder::getTextValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::TEXT_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::Entry::Value::Builder::setTextValue( ::capnp::Text::Reader value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::TEXT_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Store::Container::Entry::Value::Builder::initTextValue(unsigned int size) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::TEXT_VALUE);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::Entry::Value::Builder::adoptTextValue(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::TEXT_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Store::Container::Entry::Value::Builder::disownTextValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::TEXT_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::Entry::Value::Reader::isTextListValue() const {
  return which() == Store::Container::Entry::Value::TEXT_LIST_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isTextListValue() {
  return which() == Store::Container::Entry::Value::TEXT_LIST_VALUE;
}
inline bool Store::Container::Entry::Value::Reader::hasTextListValue() const {
  if (which() != Store::Container::Entry::Value::TEXT_LIST_VALUE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::Entry::Value::Builder::hasTextListValue() {
  if (which() != Store::Container::Entry::Value::TEXT_LIST_VALUE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader Store::Container::Entry::Value::Reader::getTextListValue() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::TEXT_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Store::Container::Entry::Value::Builder::getTextListValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::TEXT_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::Entry::Value::Builder::setTextListValue( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::TEXT_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Store::Container::Entry::Value::Builder::setTextListValue(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::TEXT_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Store::Container::Entry::Value::Builder::initTextListValue(unsigned int size) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::TEXT_LIST_VALUE);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::Entry::Value::Builder::adoptTextListValue(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::TEXT_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> Store::Container::Entry::Value::Builder::disownTextListValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::TEXT_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::Entry::Value::Reader::isDataValue() const {
  return which() == Store::Container::Entry::Value::DATA_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isDataValue() {
  return which() == Store::Container::Entry::Value::DATA_VALUE;
}
inline bool Store::Container::Entry::Value::Reader::hasDataValue() const {
  if (which() != Store::Container::Entry::Value::DATA_VALUE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::Entry::Value::Builder::hasDataValue() {
  if (which() != Store::Container::Entry::Value::DATA_VALUE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader Store::Container::Entry::Value::Reader::getDataValue() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::DATA_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder Store::Container::Entry::Value::Builder::getDataValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::DATA_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::Entry::Value::Builder::setDataValue( ::capnp::Data::Reader value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::DATA_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder Store::Container::Entry::Value::Builder::initDataValue(unsigned int size) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::DATA_VALUE);
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::Entry::Value::Builder::adoptDataValue(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::DATA_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> Store::Container::Entry::Value::Builder::disownDataValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::DATA_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::Entry::Value::Reader::isDataListValue() const {
  return which() == Store::Container::Entry::Value::DATA_LIST_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isDataListValue() {
  return which() == Store::Container::Entry::Value::DATA_LIST_VALUE;
}
inline bool Store::Container::Entry::Value::Reader::hasDataListValue() const {
  if (which() != Store::Container::Entry::Value::DATA_LIST_VALUE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::Entry::Value::Builder::hasDataListValue() {
  if (which() != Store::Container::Entry::Value::DATA_LIST_VALUE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Reader Store::Container::Entry::Value::Reader::getDataListValue() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::DATA_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Builder Store::Container::Entry::Value::Builder::getDataListValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::DATA_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::Entry::Value::Builder::setDataListValue( ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Reader value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::DATA_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Store::Container::Entry::Value::Builder::setDataListValue(::kj::ArrayPtr<const  ::capnp::Data::Reader> value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::DATA_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Builder Store::Container::Entry::Value::Builder::initDataListValue(unsigned int size) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::DATA_LIST_VALUE);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::Entry::Value::Builder::adoptDataListValue(
    ::capnp::Orphan< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>&& value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::DATA_LIST_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>> Store::Container::Entry::Value::Builder::disownDataListValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::DATA_LIST_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::Entry::Value::Reader::isAnyValue() const {
  return which() == Store::Container::Entry::Value::ANY_VALUE;
}
inline bool Store::Container::Entry::Value::Builder::isAnyValue() {
  return which() == Store::Container::Entry::Value::ANY_VALUE;
}
inline bool Store::Container::Entry::Value::Reader::hasAnyValue() const {
  if (which() != Store::Container::Entry::Value::ANY_VALUE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::Entry::Value::Builder::hasAnyValue() {
  if (which() != Store::Container::Entry::Value::ANY_VALUE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::AnyStruct::Reader Store::Container::Entry::Value::Reader::getAnyValue() const {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::ANY_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::AnyStruct>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::AnyStruct::Builder Store::Container::Entry::Value::Builder::getAnyValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::ANY_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::AnyStruct>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::Entry::Value::Builder::setAnyValue( ::capnp::AnyStruct::Reader value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::ANY_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::AnyStruct>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename T_>
inline ::capnp::BuilderFor<T_> Store::Container::Entry::Value::Builder::initAnyValueAs() {
  static_assert(::capnp::kind<T_>() == ::capnp::Kind::STRUCT,
                "anyValue must be a struct");
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::ANY_VALUE);
  return ::capnp::_::PointerHelpers<T_>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::Entry::Value::Builder::adoptAnyValue(
    ::capnp::Orphan< ::capnp::AnyStruct>&& value) {
  _builder.setDataField<Store::Container::Entry::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Entry::Value::ANY_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::AnyStruct>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::AnyStruct> Store::Container::Entry::Value::Builder::disownAnyValue() {
  KJ_IREQUIRE((which() == Store::Container::Entry::Value::ANY_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::AnyStruct>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::Entry::GetKeyResults::Reader::hasKey() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::Entry::GetKeyResults::Builder::hasKey() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Store::Container::Entry::GetKeyResults::Reader::getKey() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Store::Container::Entry::GetKeyResults::Builder::getKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::Entry::GetKeyResults::Builder::setKey( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Store::Container::Entry::GetKeyResults::Builder::initKey(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::Entry::GetKeyResults::Builder::adoptKey(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Store::Container::Entry::GetKeyResults::Builder::disownKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::Entry::GetValueResults::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::Entry::GetValueResults::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::storage::Store::Container::Entry::Value::Reader Store::Container::Entry::GetValueResults::Reader::getValue() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry::Value>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::storage::Store::Container::Entry::Value::Builder Store::Container::Entry::GetValueResults::Builder::getValue() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry::Value>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::storage::Store::Container::Entry::Value::Pipeline Store::Container::Entry::GetValueResults::Pipeline::getValue() {
  return  ::mas::schema::storage::Store::Container::Entry::Value::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Store::Container::Entry::GetValueResults::Builder::setValue( ::mas::schema::storage::Store::Container::Entry::Value::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry::Value>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::storage::Store::Container::Entry::Value::Builder Store::Container::Entry::GetValueResults::Builder::initValue() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry::Value>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::Entry::GetValueResults::Builder::adoptValue(
    ::capnp::Orphan< ::mas::schema::storage::Store::Container::Entry::Value>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry::Value>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::storage::Store::Container::Entry::Value> Store::Container::Entry::GetValueResults::Builder::disownValue() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry::Value>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::Entry::GetValueResults::Reader::getIsUnset() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Store::Container::Entry::GetValueResults::Builder::getIsUnset() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Store::Container::Entry::GetValueResults::Builder::setIsUnset(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Store::Container::Entry::SetValueParams::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::Entry::SetValueParams::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::storage::Store::Container::Entry::Value::Reader Store::Container::Entry::SetValueParams::Reader::getValue() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry::Value>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::storage::Store::Container::Entry::Value::Builder Store::Container::Entry::SetValueParams::Builder::getValue() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry::Value>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::storage::Store::Container::Entry::Value::Pipeline Store::Container::Entry::SetValueParams::Pipeline::getValue() {
  return  ::mas::schema::storage::Store::Container::Entry::Value::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Store::Container::Entry::SetValueParams::Builder::setValue( ::mas::schema::storage::Store::Container::Entry::Value::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry::Value>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::storage::Store::Container::Entry::Value::Builder Store::Container::Entry::SetValueParams::Builder::initValue() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry::Value>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::Entry::SetValueParams::Builder::adoptValue(
    ::capnp::Orphan< ::mas::schema::storage::Store::Container::Entry::Value>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry::Value>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::storage::Store::Container::Entry::Value> Store::Container::Entry::SetValueParams::Builder::disownValue() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry::Value>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::Entry::SetValueResults::Reader::getSuccess() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Store::Container::Entry::SetValueResults::Builder::getSuccess() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Store::Container::Entry::SetValueResults::Builder::setSuccess(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Store::Container::ExportResults::Reader::hasJson() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::ExportResults::Builder::hasJson() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Store::Container::ExportResults::Reader::getJson() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Store::Container::ExportResults::Builder::getJson() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::ExportResults::Builder::setJson( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Store::Container::ExportResults::Builder::initJson(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::ExportResults::Builder::adoptJson(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Store::Container::ExportResults::Builder::disownJson() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::DownloadEntriesResults::Reader::hasEntries() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::DownloadEntriesResults::Builder::hasEntries() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>::Reader Store::Container::DownloadEntriesResults::Reader::getEntries() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>::Builder Store::Container::DownloadEntriesResults::Builder::getEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::DownloadEntriesResults::Builder::setEntries( ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>::Builder Store::Container::DownloadEntriesResults::Builder::initEntries(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::DownloadEntriesResults::Builder::adoptEntries(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>> Store::Container::DownloadEntriesResults::Builder::disownEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::ListEntriesResults::Reader::hasEntries() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::ListEntriesResults::Builder::hasEntries() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnp::List< ::mas::schema::storage::Store::Container::Entry,  ::capnp::Kind::INTERFACE>::Reader Store::Container::ListEntriesResults::Reader::getEntries() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::storage::Store::Container::Entry,  ::capnp::Kind::INTERFACE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::storage::Store::Container::Entry,  ::capnp::Kind::INTERFACE>::Builder Store::Container::ListEntriesResults::Builder::getEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::storage::Store::Container::Entry,  ::capnp::Kind::INTERFACE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::ListEntriesResults::Builder::setEntries( ::capnp::List< ::mas::schema::storage::Store::Container::Entry,  ::capnp::Kind::INTERFACE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::storage::Store::Container::Entry,  ::capnp::Kind::INTERFACE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::storage::Store::Container::Entry,  ::capnp::Kind::INTERFACE>::Builder Store::Container::ListEntriesResults::Builder::initEntries(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::storage::Store::Container::Entry,  ::capnp::Kind::INTERFACE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::ListEntriesResults::Builder::adoptEntries(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::storage::Store::Container::Entry,  ::capnp::Kind::INTERFACE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::storage::Store::Container::Entry,  ::capnp::Kind::INTERFACE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::storage::Store::Container::Entry,  ::capnp::Kind::INTERFACE>> Store::Container::ListEntriesResults::Builder::disownEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::storage::Store::Container::Entry,  ::capnp::Kind::INTERFACE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Store::Container::GetEntryParams::Reader::hasKey() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::GetEntryParams::Builder::hasKey() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Store::Container::GetEntryParams::Reader::getKey() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Store::Container::GetEntryParams::Builder::getKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::GetEntryParams::Builder::setKey( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Store::Container::GetEntryParams::Builder::initKey(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::GetEntryParams::Builder::adoptKey(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Store::Container::GetEntryParams::Builder::disownKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::GetEntryResults::Reader::hasEntry() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::GetEntryResults::Builder::hasEntry() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::storage::Store::Container::Entry::Client Store::Container::GetEntryResults::Reader::getEntry() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::storage::Store::Container::Entry::Client Store::Container::GetEntryResults::Builder::getEntry() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::storage::Store::Container::Entry::Client Store::Container::GetEntryResults::Pipeline::getEntry() {
  return  ::mas::schema::storage::Store::Container::Entry::Client(_typeless.getPointerField(0).asCap());
}
inline void Store::Container::GetEntryResults::Builder::setEntry( ::mas::schema::storage::Store::Container::Entry::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Store::Container::GetEntryResults::Builder::setEntry( ::mas::schema::storage::Store::Container::Entry::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Store::Container::GetEntryResults::Builder::adoptEntry(
    ::capnp::Orphan< ::mas::schema::storage::Store::Container::Entry>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::storage::Store::Container::Entry> Store::Container::GetEntryResults::Builder::disownEntry() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Store::Container::RemoveEntryParams::Reader::hasKey() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::RemoveEntryParams::Builder::hasKey() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Store::Container::RemoveEntryParams::Reader::getKey() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Store::Container::RemoveEntryParams::Builder::getKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::RemoveEntryParams::Builder::setKey( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Store::Container::RemoveEntryParams::Builder::initKey(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::RemoveEntryParams::Builder::adoptKey(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Store::Container::RemoveEntryParams::Builder::disownKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::RemoveEntryResults::Reader::getSuccess() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Store::Container::RemoveEntryResults::Builder::getSuccess() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Store::Container::RemoveEntryResults::Builder::setSuccess(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Store::Container::ClearResults::Reader::getSuccess() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Store::Container::ClearResults::Builder::getSuccess() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Store::Container::ClearResults::Builder::setSuccess(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Store::Container::AddEntryParams::Reader::hasKey() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::AddEntryParams::Builder::hasKey() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Store::Container::AddEntryParams::Reader::getKey() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Store::Container::AddEntryParams::Builder::getKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::AddEntryParams::Builder::setKey( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Store::Container::AddEntryParams::Builder::initKey(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::AddEntryParams::Builder::adoptKey(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Store::Container::AddEntryParams::Builder::disownKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::AddEntryParams::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::AddEntryParams::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::storage::Store::Container::Entry::Value::Reader Store::Container::AddEntryParams::Reader::getValue() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry::Value>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::storage::Store::Container::Entry::Value::Builder Store::Container::AddEntryParams::Builder::getValue() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry::Value>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::storage::Store::Container::Entry::Value::Pipeline Store::Container::AddEntryParams::Pipeline::getValue() {
  return  ::mas::schema::storage::Store::Container::Entry::Value::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Store::Container::AddEntryParams::Builder::setValue( ::mas::schema::storage::Store::Container::Entry::Value::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry::Value>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::storage::Store::Container::Entry::Value::Builder Store::Container::AddEntryParams::Builder::initValue() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry::Value>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Store::Container::AddEntryParams::Builder::adoptValue(
    ::capnp::Orphan< ::mas::schema::storage::Store::Container::Entry::Value>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry::Value>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::storage::Store::Container::Entry::Value> Store::Container::AddEntryParams::Builder::disownValue() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry::Value>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Store::Container::AddEntryParams::Reader::getReplaceExisting() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Store::Container::AddEntryParams::Builder::getReplaceExisting() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Store::Container::AddEntryParams::Builder::setReplaceExisting(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Store::Container::AddEntryResults::Reader::hasEntry() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::AddEntryResults::Builder::hasEntry() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::storage::Store::Container::Entry::Client Store::Container::AddEntryResults::Reader::getEntry() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::storage::Store::Container::Entry::Client Store::Container::AddEntryResults::Builder::getEntry() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::storage::Store::Container::Entry::Client Store::Container::AddEntryResults::Pipeline::getEntry() {
  return  ::mas::schema::storage::Store::Container::Entry::Client(_typeless.getPointerField(0).asCap());
}
inline void Store::Container::AddEntryResults::Builder::setEntry( ::mas::schema::storage::Store::Container::Entry::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Store::Container::AddEntryResults::Builder::setEntry( ::mas::schema::storage::Store::Container::Entry::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Store::Container::AddEntryResults::Builder::adoptEntry(
    ::capnp::Orphan< ::mas::schema::storage::Store::Container::Entry>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::storage::Store::Container::Entry> Store::Container::AddEntryResults::Builder::disownEntry() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Entry>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Store::Container::AddEntryResults::Reader::getSuccess() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Store::Container::AddEntryResults::Builder::getSuccess() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Store::Container::AddEntryResults::Builder::setSuccess(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Store::ImportExportData::Reader::hasInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::ImportExportData::Builder::hasInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::common::IdInformation::Reader Store::ImportExportData::Reader::getInfo() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::IdInformation::Builder Store::ImportExportData::Builder::getInfo() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::common::IdInformation::Pipeline Store::ImportExportData::Pipeline::getInfo() {
  return  ::mas::schema::common::IdInformation::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Store::ImportExportData::Builder::setInfo( ::mas::schema::common::IdInformation::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::common::IdInformation::Builder Store::ImportExportData::Builder::initInfo() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::ImportExportData::Builder::adoptInfo(
    ::capnp::Orphan< ::mas::schema::common::IdInformation>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::common::IdInformation> Store::ImportExportData::Builder::disownInfo() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::ImportExportData::Reader::hasEntries() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Store::ImportExportData::Builder::hasEntries() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>::Reader Store::ImportExportData::Reader::getEntries() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>::Builder Store::ImportExportData::Builder::getEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Store::ImportExportData::Builder::setEntries( ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>::Builder Store::ImportExportData::Builder::initEntries(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Store::ImportExportData::Builder::adoptEntries(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>> Store::ImportExportData::Builder::disownEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::mas::schema::storage::Store::Container::Entry::Value>,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Store::ImportExportData::Reader::hasIsAnyValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Store::ImportExportData::Builder::hasIsAnyValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Reader Store::ImportExportData::Reader::getIsAnyValue() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Builder Store::ImportExportData::Builder::getIsAnyValue() {
  return ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Store::ImportExportData::Builder::setIsAnyValue( ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline void Store::ImportExportData::Builder::setIsAnyValue(::kj::ArrayPtr<const bool> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Builder Store::ImportExportData::Builder::initIsAnyValue(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Store::ImportExportData::Builder::adoptIsAnyValue(
    ::capnp::Orphan< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>> Store::ImportExportData::Builder::disownIsAnyValue() {
  return ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Store::NewContainerParams::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::NewContainerParams::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Store::NewContainerParams::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Store::NewContainerParams::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::NewContainerParams::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Store::NewContainerParams::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::NewContainerParams::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Store::NewContainerParams::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::NewContainerParams::Reader::hasDescription() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Store::NewContainerParams::Builder::hasDescription() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Store::NewContainerParams::Reader::getDescription() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Store::NewContainerParams::Builder::getDescription() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Store::NewContainerParams::Builder::setDescription( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Store::NewContainerParams::Builder::initDescription(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Store::NewContainerParams::Builder::adoptDescription(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Store::NewContainerParams::Builder::disownDescription() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Store::NewContainerResults::Reader::hasContainer() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::NewContainerResults::Builder::hasContainer() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::storage::Store::Container::Client Store::NewContainerResults::Reader::getContainer() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::storage::Store::Container::Client Store::NewContainerResults::Builder::getContainer() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::storage::Store::Container::Client Store::NewContainerResults::Pipeline::getContainer() {
  return  ::mas::schema::storage::Store::Container::Client(_typeless.getPointerField(0).asCap());
}
inline void Store::NewContainerResults::Builder::setContainer( ::mas::schema::storage::Store::Container::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Store::NewContainerResults::Builder::setContainer( ::mas::schema::storage::Store::Container::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Store::NewContainerResults::Builder::adoptContainer(
    ::capnp::Orphan< ::mas::schema::storage::Store::Container>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::storage::Store::Container> Store::NewContainerResults::Builder::disownContainer() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Store::ContainerWithIdParams::Reader::hasId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::ContainerWithIdParams::Builder::hasId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Store::ContainerWithIdParams::Reader::getId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Store::ContainerWithIdParams::Builder::getId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::ContainerWithIdParams::Builder::setId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Store::ContainerWithIdParams::Builder::initId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::ContainerWithIdParams::Builder::adoptId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Store::ContainerWithIdParams::Builder::disownId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::ContainerWithIdResults::Reader::hasContainer() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::ContainerWithIdResults::Builder::hasContainer() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::storage::Store::Container::Client Store::ContainerWithIdResults::Reader::getContainer() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::storage::Store::Container::Client Store::ContainerWithIdResults::Builder::getContainer() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::storage::Store::Container::Client Store::ContainerWithIdResults::Pipeline::getContainer() {
  return  ::mas::schema::storage::Store::Container::Client(_typeless.getPointerField(0).asCap());
}
inline void Store::ContainerWithIdResults::Builder::setContainer( ::mas::schema::storage::Store::Container::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Store::ContainerWithIdResults::Builder::setContainer( ::mas::schema::storage::Store::Container::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Store::ContainerWithIdResults::Builder::adoptContainer(
    ::capnp::Orphan< ::mas::schema::storage::Store::Container>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::storage::Store::Container> Store::ContainerWithIdResults::Builder::disownContainer() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Store::ListContainersResults::Reader::hasContainers() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::ListContainersResults::Builder::hasContainers() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>::Reader Store::ListContainersResults::Reader::getContainers() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>::Builder Store::ListContainersResults::Builder::getContainers() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::ListContainersResults::Builder::setContainers( ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>::Builder Store::ListContainersResults::Builder::initContainers(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::ListContainersResults::Builder::adoptContainers(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>> Store::ListContainersResults::Builder::disownContainers() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Store::RemoveContainerParams::Reader::hasId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::RemoveContainerParams::Builder::hasId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Store::RemoveContainerParams::Reader::getId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Store::RemoveContainerParams::Builder::getId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::RemoveContainerParams::Builder::setId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Store::RemoveContainerParams::Builder::initId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::RemoveContainerParams::Builder::adoptId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Store::RemoveContainerParams::Builder::disownId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::RemoveContainerResults::Reader::getSuccess() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Store::RemoveContainerResults::Builder::getSuccess() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Store::RemoveContainerResults::Builder::setSuccess(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Store::ImportContainerParams::Reader::hasJson() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::ImportContainerParams::Builder::hasJson() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Store::ImportContainerParams::Reader::getJson() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Store::ImportContainerParams::Builder::getJson() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::ImportContainerParams::Builder::setJson( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Store::ImportContainerParams::Builder::initJson(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::ImportContainerParams::Builder::adoptJson(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Store::ImportContainerParams::Builder::disownJson() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::ImportContainerResults::Reader::hasContainer() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::ImportContainerResults::Builder::hasContainer() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::storage::Store::Container::Client Store::ImportContainerResults::Reader::getContainer() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::storage::Store::Container::Client Store::ImportContainerResults::Builder::getContainer() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::storage::Store::Container::Client Store::ImportContainerResults::Pipeline::getContainer() {
  return  ::mas::schema::storage::Store::Container::Client(_typeless.getPointerField(0).asCap());
}
inline void Store::ImportContainerResults::Builder::setContainer( ::mas::schema::storage::Store::Container::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Store::ImportContainerResults::Builder::setContainer( ::mas::schema::storage::Store::Container::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Store::ImportContainerResults::Builder::adoptContainer(
    ::capnp::Orphan< ::mas::schema::storage::Store::Container>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::storage::Store::Container> Store::ImportContainerResults::Builder::disownContainer() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

