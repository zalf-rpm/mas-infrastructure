// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: storage.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#if CAPNP_VERSION != 10000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "common.capnp.h"
#include "persistence.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(e69f958aa2386f06);
CAPNP_DECLARE_SCHEMA(878131f45567ae62);
CAPNP_DECLARE_SCHEMA(aa5c23f54650f8ae);
CAPNP_DECLARE_SCHEMA(e73a3ffcf21b4e5f);
CAPNP_DECLARE_SCHEMA(9e138889be22cc5e);
CAPNP_DECLARE_SCHEMA(a914844d7351c9ee);
CAPNP_DECLARE_SCHEMA(93fc14178e630994);
CAPNP_DECLARE_SCHEMA(ffe4319ac401d166);
CAPNP_DECLARE_SCHEMA(dbf70a288c6933b1);
CAPNP_DECLARE_SCHEMA(a028d3ba03083872);
CAPNP_DECLARE_SCHEMA(c4161d5db43ad669);
CAPNP_DECLARE_SCHEMA(9bc1d764a970b846);
CAPNP_DECLARE_SCHEMA(fde99170b27ac5ce);
CAPNP_DECLARE_SCHEMA(fbd938c95f64b7bf);
CAPNP_DECLARE_SCHEMA(c31c71f8d67b827b);
CAPNP_DECLARE_SCHEMA(eb6f27dfc29bffad);
CAPNP_DECLARE_SCHEMA(fbef00fded9c8312);
CAPNP_DECLARE_SCHEMA(883b57737fba9e54);
CAPNP_DECLARE_SCHEMA(f32349bf3a9997ac);
CAPNP_DECLARE_SCHEMA(f517bec79f8d2744);
CAPNP_DECLARE_SCHEMA(b2af26aeda5445e5);
CAPNP_DECLARE_SCHEMA(a466e92166fcce6e);
CAPNP_DECLARE_SCHEMA(f82426685da256f9);
CAPNP_DECLARE_SCHEMA(bfbe4f9e7fb62452);
CAPNP_DECLARE_SCHEMA(aa0460382685000e);

}  // namespace schemas
}  // namespace capnp

namespace mas {
namespace schema {
namespace storage {

struct Store {
  Store() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct Container;
  struct NewContainerResults;
  struct ContainerWithIdParams;
  struct ContainerWithIdResults;
  struct ListContainersParams;
  struct ListContainersResults;
  struct RemoveContainerParams;
  struct RemoveContainerResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(e69f958aa2386f06)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Store::Container {
  Container() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct Object;
  struct ImportDataParams;
  struct ImportDataResults;
  struct ExportDataParams;
  struct ExportDataResults;
  struct ListObjectsParams;
  struct ListObjectsResults;
  struct GetObjectParams;
  struct GetObjectResults;
  struct AddObjectParams;
  struct AddObjectResults;
  struct RemoveObjectParams;
  struct RemoveObjectResults;
  struct ClearParams;
  struct ClearResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(878131f45567ae62)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Store::Container::Object {
  Object() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Value;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(aa5c23f54650f8ae, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::Object::Value {
  Value() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    BOOL_VALUE,
    INT_VALUE,
    FLOAT_VALUE,
    TEXT_VALUE,
    DATA_VALUE,
    ANY_VALUE,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e73a3ffcf21b4e5f, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::ImportDataParams {
  ImportDataParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9e138889be22cc5e, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::ImportDataResults {
  ImportDataResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a914844d7351c9ee, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::ExportDataParams {
  ExportDataParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(93fc14178e630994, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::ExportDataResults {
  ExportDataResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ffe4319ac401d166, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::ListObjectsParams {
  ListObjectsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dbf70a288c6933b1, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::ListObjectsResults {
  ListObjectsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a028d3ba03083872, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::GetObjectParams {
  GetObjectParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c4161d5db43ad669, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::GetObjectResults {
  GetObjectResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9bc1d764a970b846, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::AddObjectParams {
  AddObjectParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fde99170b27ac5ce, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::AddObjectResults {
  AddObjectResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fbd938c95f64b7bf, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::RemoveObjectParams {
  RemoveObjectParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c31c71f8d67b827b, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::RemoveObjectResults {
  RemoveObjectResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(eb6f27dfc29bffad, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::ClearParams {
  ClearParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fbef00fded9c8312, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::Container::ClearResults {
  ClearResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(883b57737fba9e54, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::NewContainerResults {
  NewContainerResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f32349bf3a9997ac, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::ContainerWithIdParams {
  ContainerWithIdParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f517bec79f8d2744, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::ContainerWithIdResults {
  ContainerWithIdResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b2af26aeda5445e5, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::ListContainersParams {
  ListContainersParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a466e92166fcce6e, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::ListContainersResults {
  ListContainersResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f82426685da256f9, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::RemoveContainerParams {
  RemoveContainerParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bfbe4f9e7fb62452, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Store::RemoveContainerResults {
  RemoveContainerResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(aa0460382685000e, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

#if !CAPNP_LITE
class Store::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Store Calls;
  typedef Store Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::common::IdInformation,  ::mas::schema::storage::Store::NewContainerResults> newContainerRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::storage::Store::ContainerWithIdParams,  ::mas::schema::storage::Store::ContainerWithIdResults> containerWithIdRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::storage::Store::ListContainersParams,  ::mas::schema::storage::Store::ListContainersResults> listContainersRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::storage::Store::RemoveContainerParams,  ::mas::schema::storage::Store::RemoveContainerResults> removeContainerRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Store::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Store Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::storage::Store::NewContainerResults NewContainerResults;
  typedef ::capnp::CallContext< ::mas::schema::common::IdInformation, NewContainerResults> NewContainerContext;
  virtual ::kj::Promise<void> newContainer(NewContainerContext context);
  typedef  ::mas::schema::storage::Store::ContainerWithIdParams ContainerWithIdParams;
  typedef  ::mas::schema::storage::Store::ContainerWithIdResults ContainerWithIdResults;
  typedef ::capnp::CallContext<ContainerWithIdParams, ContainerWithIdResults> ContainerWithIdContext;
  virtual ::kj::Promise<void> containerWithId(ContainerWithIdContext context);
  typedef  ::mas::schema::storage::Store::ListContainersParams ListContainersParams;
  typedef  ::mas::schema::storage::Store::ListContainersResults ListContainersResults;
  typedef ::capnp::CallContext<ListContainersParams, ListContainersResults> ListContainersContext;
  virtual ::kj::Promise<void> listContainers(ListContainersContext context);
  typedef  ::mas::schema::storage::Store::RemoveContainerParams RemoveContainerParams;
  typedef  ::mas::schema::storage::Store::RemoveContainerResults RemoveContainerResults;
  typedef ::capnp::CallContext<RemoveContainerParams, RemoveContainerResults> RemoveContainerContext;
  virtual ::kj::Promise<void> removeContainer(RemoveContainerContext context);

  inline  ::mas::schema::storage::Store::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::storage::Store>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Store::Container::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client,
      public virtual  ::mas::schema::persistence::Persistent::Client {
public:
  typedef Container Calls;
  typedef Container Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::storage::Store::Container::ImportDataParams,  ::mas::schema::storage::Store::Container::ImportDataResults> importDataRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::storage::Store::Container::ExportDataParams,  ::mas::schema::storage::Store::Container::ExportDataResults> exportDataRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::storage::Store::Container::ListObjectsParams,  ::mas::schema::storage::Store::Container::ListObjectsResults> listObjectsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::storage::Store::Container::GetObjectParams,  ::mas::schema::storage::Store::Container::GetObjectResults> getObjectRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::storage::Store::Container::AddObjectParams,  ::mas::schema::storage::Store::Container::AddObjectResults> addObjectRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::storage::Store::Container::RemoveObjectParams,  ::mas::schema::storage::Store::Container::RemoveObjectResults> removeObjectRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::storage::Store::Container::ClearParams,  ::mas::schema::storage::Store::Container::ClearResults> clearRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Store::Container::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server,
      public virtual  ::mas::schema::persistence::Persistent::Server {
public:
  typedef Container Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::storage::Store::Container::ImportDataParams ImportDataParams;
  typedef  ::mas::schema::storage::Store::Container::ImportDataResults ImportDataResults;
  typedef ::capnp::CallContext<ImportDataParams, ImportDataResults> ImportDataContext;
  virtual ::kj::Promise<void> importData(ImportDataContext context);
  typedef  ::mas::schema::storage::Store::Container::ExportDataParams ExportDataParams;
  typedef  ::mas::schema::storage::Store::Container::ExportDataResults ExportDataResults;
  typedef ::capnp::CallContext<ExportDataParams, ExportDataResults> ExportDataContext;
  virtual ::kj::Promise<void> exportData(ExportDataContext context);
  typedef  ::mas::schema::storage::Store::Container::ListObjectsParams ListObjectsParams;
  typedef  ::mas::schema::storage::Store::Container::ListObjectsResults ListObjectsResults;
  typedef ::capnp::CallContext<ListObjectsParams, ListObjectsResults> ListObjectsContext;
  virtual ::kj::Promise<void> listObjects(ListObjectsContext context);
  typedef  ::mas::schema::storage::Store::Container::GetObjectParams GetObjectParams;
  typedef  ::mas::schema::storage::Store::Container::GetObjectResults GetObjectResults;
  typedef ::capnp::CallContext<GetObjectParams, GetObjectResults> GetObjectContext;
  virtual ::kj::Promise<void> getObject(GetObjectContext context);
  typedef  ::mas::schema::storage::Store::Container::AddObjectParams AddObjectParams;
  typedef  ::mas::schema::storage::Store::Container::AddObjectResults AddObjectResults;
  typedef ::capnp::CallContext<AddObjectParams, AddObjectResults> AddObjectContext;
  virtual ::kj::Promise<void> addObject(AddObjectContext context);
  typedef  ::mas::schema::storage::Store::Container::RemoveObjectParams RemoveObjectParams;
  typedef  ::mas::schema::storage::Store::Container::RemoveObjectResults RemoveObjectResults;
  typedef ::capnp::CallContext<RemoveObjectParams, RemoveObjectResults> RemoveObjectContext;
  virtual ::kj::Promise<void> removeObject(RemoveObjectContext context);
  typedef  ::mas::schema::storage::Store::Container::ClearParams ClearParams;
  typedef  ::mas::schema::storage::Store::Container::ClearResults ClearResults;
  typedef ::capnp::CallContext<ClearParams, ClearResults> ClearContext;
  virtual ::kj::Promise<void> clear(ClearContext context);

  inline  ::mas::schema::storage::Store::Container::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::storage::Store::Container>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Store::Container::Object::Reader {
public:
  typedef Object Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasKey() const;
  inline  ::capnp::Text::Reader getKey() const;

  inline typename Value::Reader getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::Object::Builder {
public:
  typedef Object Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasKey();
  inline  ::capnp::Text::Builder getKey();
  inline void setKey( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initKey(unsigned int size);
  inline void adoptKey(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownKey();

  inline typename Value::Builder getValue();
  inline typename Value::Builder initValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::Object::Pipeline {
public:
  typedef Object Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename Value::Pipeline getValue();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::Object::Value::Reader {
public:
  typedef Value Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isBoolValue() const;
  inline bool getBoolValue() const;

  inline bool isIntValue() const;
  inline  ::int64_t getIntValue() const;

  inline bool isFloatValue() const;
  inline double getFloatValue() const;

  inline bool isTextValue() const;
  inline bool hasTextValue() const;
  inline  ::capnp::Text::Reader getTextValue() const;

  inline bool isDataValue() const;
  inline bool hasDataValue() const;
  inline  ::capnp::Data::Reader getDataValue() const;

  inline bool isAnyValue() const;
  inline bool hasAnyValue() const;
  inline  ::capnp::AnyStruct::Reader getAnyValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::Object::Value::Builder {
public:
  typedef Value Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isBoolValue();
  inline bool getBoolValue();
  inline void setBoolValue(bool value);

  inline bool isIntValue();
  inline  ::int64_t getIntValue();
  inline void setIntValue( ::int64_t value);

  inline bool isFloatValue();
  inline double getFloatValue();
  inline void setFloatValue(double value);

  inline bool isTextValue();
  inline bool hasTextValue();
  inline  ::capnp::Text::Builder getTextValue();
  inline void setTextValue( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initTextValue(unsigned int size);
  inline void adoptTextValue(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownTextValue();

  inline bool isDataValue();
  inline bool hasDataValue();
  inline  ::capnp::Data::Builder getDataValue();
  inline void setDataValue( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initDataValue(unsigned int size);
  inline void adoptDataValue(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownDataValue();

  inline bool isAnyValue();
  inline bool hasAnyValue();
  inline  ::capnp::AnyStruct::Builder getAnyValue();
  inline void setAnyValue( ::capnp::AnyStruct::Reader value);
  template <typename T_>
  inline ::capnp::BuilderFor<T_> initAnyValueAs();
  inline void adoptAnyValue(::capnp::Orphan< ::capnp::AnyStruct>&& value);
  inline ::capnp::Orphan< ::capnp::AnyStruct> disownAnyValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::Object::Value::Pipeline {
public:
  typedef Value Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::ImportDataParams::Reader {
public:
  typedef ImportDataParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::Data::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::ImportDataParams::Builder {
public:
  typedef ImportDataParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::Data::Builder getData();
  inline void setData( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::ImportDataParams::Pipeline {
public:
  typedef ImportDataParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::ImportDataResults::Reader {
public:
  typedef ImportDataResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getSuccess() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::ImportDataResults::Builder {
public:
  typedef ImportDataResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getSuccess();
  inline void setSuccess(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::ImportDataResults::Pipeline {
public:
  typedef ImportDataResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::ExportDataParams::Reader {
public:
  typedef ExportDataParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::ExportDataParams::Builder {
public:
  typedef ExportDataParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::ExportDataParams::Pipeline {
public:
  typedef ExportDataParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::ExportDataResults::Reader {
public:
  typedef ExportDataResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasData() const;
  inline  ::capnp::Data::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::ExportDataResults::Builder {
public:
  typedef ExportDataResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasData();
  inline  ::capnp::Data::Builder getData();
  inline void setData( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::ExportDataResults::Pipeline {
public:
  typedef ExportDataResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::ListObjectsParams::Reader {
public:
  typedef ListObjectsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::ListObjectsParams::Builder {
public:
  typedef ListObjectsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::ListObjectsParams::Pipeline {
public:
  typedef ListObjectsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::ListObjectsResults::Reader {
public:
  typedef ListObjectsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasObjects() const;
  inline  ::capnp::List< ::mas::schema::storage::Store::Container::Object,  ::capnp::Kind::STRUCT>::Reader getObjects() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::ListObjectsResults::Builder {
public:
  typedef ListObjectsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasObjects();
  inline  ::capnp::List< ::mas::schema::storage::Store::Container::Object,  ::capnp::Kind::STRUCT>::Builder getObjects();
  inline void setObjects( ::capnp::List< ::mas::schema::storage::Store::Container::Object,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::storage::Store::Container::Object,  ::capnp::Kind::STRUCT>::Builder initObjects(unsigned int size);
  inline void adoptObjects(::capnp::Orphan< ::capnp::List< ::mas::schema::storage::Store::Container::Object,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::storage::Store::Container::Object,  ::capnp::Kind::STRUCT>> disownObjects();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::ListObjectsResults::Pipeline {
public:
  typedef ListObjectsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::GetObjectParams::Reader {
public:
  typedef GetObjectParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasKey() const;
  inline  ::capnp::Text::Reader getKey() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::GetObjectParams::Builder {
public:
  typedef GetObjectParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasKey();
  inline  ::capnp::Text::Builder getKey();
  inline void setKey( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initKey(unsigned int size);
  inline void adoptKey(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownKey();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::GetObjectParams::Pipeline {
public:
  typedef GetObjectParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::GetObjectResults::Reader {
public:
  typedef GetObjectResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasObject() const;
  inline  ::mas::schema::storage::Store::Container::Object::Reader getObject() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::GetObjectResults::Builder {
public:
  typedef GetObjectResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasObject();
  inline  ::mas::schema::storage::Store::Container::Object::Builder getObject();
  inline void setObject( ::mas::schema::storage::Store::Container::Object::Reader value);
  inline  ::mas::schema::storage::Store::Container::Object::Builder initObject();
  inline void adoptObject(::capnp::Orphan< ::mas::schema::storage::Store::Container::Object>&& value);
  inline ::capnp::Orphan< ::mas::schema::storage::Store::Container::Object> disownObject();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::GetObjectResults::Pipeline {
public:
  typedef GetObjectResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::storage::Store::Container::Object::Pipeline getObject();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::AddObjectParams::Reader {
public:
  typedef AddObjectParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasObject() const;
  inline  ::mas::schema::storage::Store::Container::Object::Reader getObject() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::AddObjectParams::Builder {
public:
  typedef AddObjectParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasObject();
  inline  ::mas::schema::storage::Store::Container::Object::Builder getObject();
  inline void setObject( ::mas::schema::storage::Store::Container::Object::Reader value);
  inline  ::mas::schema::storage::Store::Container::Object::Builder initObject();
  inline void adoptObject(::capnp::Orphan< ::mas::schema::storage::Store::Container::Object>&& value);
  inline ::capnp::Orphan< ::mas::schema::storage::Store::Container::Object> disownObject();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::AddObjectParams::Pipeline {
public:
  typedef AddObjectParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::storage::Store::Container::Object::Pipeline getObject();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::AddObjectResults::Reader {
public:
  typedef AddObjectResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getSuccess() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::AddObjectResults::Builder {
public:
  typedef AddObjectResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getSuccess();
  inline void setSuccess(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::AddObjectResults::Pipeline {
public:
  typedef AddObjectResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::RemoveObjectParams::Reader {
public:
  typedef RemoveObjectParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasKey() const;
  inline  ::capnp::Text::Reader getKey() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::RemoveObjectParams::Builder {
public:
  typedef RemoveObjectParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasKey();
  inline  ::capnp::Text::Builder getKey();
  inline void setKey( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initKey(unsigned int size);
  inline void adoptKey(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownKey();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::RemoveObjectParams::Pipeline {
public:
  typedef RemoveObjectParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::RemoveObjectResults::Reader {
public:
  typedef RemoveObjectResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getSuccess() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::RemoveObjectResults::Builder {
public:
  typedef RemoveObjectResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getSuccess();
  inline void setSuccess(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::RemoveObjectResults::Pipeline {
public:
  typedef RemoveObjectResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::ClearParams::Reader {
public:
  typedef ClearParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::ClearParams::Builder {
public:
  typedef ClearParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::ClearParams::Pipeline {
public:
  typedef ClearParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::Container::ClearResults::Reader {
public:
  typedef ClearResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getSuccess() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::Container::ClearResults::Builder {
public:
  typedef ClearResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getSuccess();
  inline void setSuccess(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::Container::ClearResults::Pipeline {
public:
  typedef ClearResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::NewContainerResults::Reader {
public:
  typedef NewContainerResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasContainer() const;
#if !CAPNP_LITE
  inline  ::mas::schema::storage::Store::Container::Client getContainer() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::NewContainerResults::Builder {
public:
  typedef NewContainerResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContainer();
#if !CAPNP_LITE
  inline  ::mas::schema::storage::Store::Container::Client getContainer();
  inline void setContainer( ::mas::schema::storage::Store::Container::Client&& value);
  inline void setContainer( ::mas::schema::storage::Store::Container::Client& value);
  inline void adoptContainer(::capnp::Orphan< ::mas::schema::storage::Store::Container>&& value);
  inline ::capnp::Orphan< ::mas::schema::storage::Store::Container> disownContainer();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::NewContainerResults::Pipeline {
public:
  typedef NewContainerResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::storage::Store::Container::Client getContainer();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::ContainerWithIdParams::Reader {
public:
  typedef ContainerWithIdParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasId() const;
  inline  ::capnp::Text::Reader getId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::ContainerWithIdParams::Builder {
public:
  typedef ContainerWithIdParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasId();
  inline  ::capnp::Text::Builder getId();
  inline void setId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initId(unsigned int size);
  inline void adoptId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownId();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::ContainerWithIdParams::Pipeline {
public:
  typedef ContainerWithIdParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::ContainerWithIdResults::Reader {
public:
  typedef ContainerWithIdResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasContainer() const;
#if !CAPNP_LITE
  inline  ::mas::schema::storage::Store::Container::Client getContainer() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::ContainerWithIdResults::Builder {
public:
  typedef ContainerWithIdResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContainer();
#if !CAPNP_LITE
  inline  ::mas::schema::storage::Store::Container::Client getContainer();
  inline void setContainer( ::mas::schema::storage::Store::Container::Client&& value);
  inline void setContainer( ::mas::schema::storage::Store::Container::Client& value);
  inline void adoptContainer(::capnp::Orphan< ::mas::schema::storage::Store::Container>&& value);
  inline ::capnp::Orphan< ::mas::schema::storage::Store::Container> disownContainer();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::ContainerWithIdResults::Pipeline {
public:
  typedef ContainerWithIdResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::storage::Store::Container::Client getContainer();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::ListContainersParams::Reader {
public:
  typedef ListContainersParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::ListContainersParams::Builder {
public:
  typedef ListContainersParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::ListContainersParams::Pipeline {
public:
  typedef ListContainersParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::ListContainersResults::Reader {
public:
  typedef ListContainersResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasContainers() const;
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>::Reader getContainers() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::ListContainersResults::Builder {
public:
  typedef ListContainersResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContainers();
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>::Builder getContainers();
  inline void setContainers( ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>::Reader value);
  inline  ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>::Builder initContainers(unsigned int size);
  inline void adoptContainers(::capnp::Orphan< ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>> disownContainers();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::ListContainersResults::Pipeline {
public:
  typedef ListContainersResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::RemoveContainerParams::Reader {
public:
  typedef RemoveContainerParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasId() const;
  inline  ::capnp::Text::Reader getId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::RemoveContainerParams::Builder {
public:
  typedef RemoveContainerParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasId();
  inline  ::capnp::Text::Builder getId();
  inline void setId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initId(unsigned int size);
  inline void adoptId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownId();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::RemoveContainerParams::Pipeline {
public:
  typedef RemoveContainerParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Store::RemoveContainerResults::Reader {
public:
  typedef RemoveContainerResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getSuccess() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Store::RemoveContainerResults::Builder {
public:
  typedef RemoveContainerResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getSuccess();
  inline void setSuccess(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Store::RemoveContainerResults::Pipeline {
public:
  typedef RemoveContainerResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

#if !CAPNP_LITE
inline Store::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Store::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Store::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Store::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Store::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::storage::Store::Client& Store::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::storage::Store::Client& Store::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
#if !CAPNP_LITE
inline Store::Container::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Store::Container::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Store::Container::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Store::Container::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Store::Container::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::storage::Store::Container::Client& Store::Container::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::storage::Store::Container::Client& Store::Container::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Store::Container::Object::Reader::hasKey() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::Object::Builder::hasKey() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Store::Container::Object::Reader::getKey() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Store::Container::Object::Builder::getKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::Object::Builder::setKey( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Store::Container::Object::Builder::initKey(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::Object::Builder::adoptKey(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Store::Container::Object::Builder::disownKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline typename Store::Container::Object::Value::Reader Store::Container::Object::Reader::getValue() const {
  return typename Store::Container::Object::Value::Reader(_reader);
}
inline typename Store::Container::Object::Value::Builder Store::Container::Object::Builder::getValue() {
  return typename Store::Container::Object::Value::Builder(_builder);
}
#if !CAPNP_LITE
inline typename Store::Container::Object::Value::Pipeline Store::Container::Object::Pipeline::getValue() {
  return typename Store::Container::Object::Value::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename Store::Container::Object::Value::Builder Store::Container::Object::Builder::initValue() {
  _builder.setDataField<bool>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS).clear();
  return typename Store::Container::Object::Value::Builder(_builder);
}
inline  ::mas::schema::storage::Store::Container::Object::Value::Which Store::Container::Object::Value::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline  ::mas::schema::storage::Store::Container::Object::Value::Which Store::Container::Object::Value::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool Store::Container::Object::Value::Reader::isBoolValue() const {
  return which() == Store::Container::Object::Value::BOOL_VALUE;
}
inline bool Store::Container::Object::Value::Builder::isBoolValue() {
  return which() == Store::Container::Object::Value::BOOL_VALUE;
}
inline bool Store::Container::Object::Value::Reader::getBoolValue() const {
  KJ_IREQUIRE((which() == Store::Container::Object::Value::BOOL_VALUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Store::Container::Object::Value::Builder::getBoolValue() {
  KJ_IREQUIRE((which() == Store::Container::Object::Value::BOOL_VALUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Store::Container::Object::Value::Builder::setBoolValue(bool value) {
  _builder.setDataField<Store::Container::Object::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Object::Value::BOOL_VALUE);
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Store::Container::Object::Value::Reader::isIntValue() const {
  return which() == Store::Container::Object::Value::INT_VALUE;
}
inline bool Store::Container::Object::Value::Builder::isIntValue() {
  return which() == Store::Container::Object::Value::INT_VALUE;
}
inline  ::int64_t Store::Container::Object::Value::Reader::getIntValue() const {
  KJ_IREQUIRE((which() == Store::Container::Object::Value::INT_VALUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int64_t Store::Container::Object::Value::Builder::getIntValue() {
  KJ_IREQUIRE((which() == Store::Container::Object::Value::INT_VALUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Store::Container::Object::Value::Builder::setIntValue( ::int64_t value) {
  _builder.setDataField<Store::Container::Object::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Object::Value::INT_VALUE);
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Store::Container::Object::Value::Reader::isFloatValue() const {
  return which() == Store::Container::Object::Value::FLOAT_VALUE;
}
inline bool Store::Container::Object::Value::Builder::isFloatValue() {
  return which() == Store::Container::Object::Value::FLOAT_VALUE;
}
inline double Store::Container::Object::Value::Reader::getFloatValue() const {
  KJ_IREQUIRE((which() == Store::Container::Object::Value::FLOAT_VALUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Store::Container::Object::Value::Builder::getFloatValue() {
  KJ_IREQUIRE((which() == Store::Container::Object::Value::FLOAT_VALUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Store::Container::Object::Value::Builder::setFloatValue(double value) {
  _builder.setDataField<Store::Container::Object::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Object::Value::FLOAT_VALUE);
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Store::Container::Object::Value::Reader::isTextValue() const {
  return which() == Store::Container::Object::Value::TEXT_VALUE;
}
inline bool Store::Container::Object::Value::Builder::isTextValue() {
  return which() == Store::Container::Object::Value::TEXT_VALUE;
}
inline bool Store::Container::Object::Value::Reader::hasTextValue() const {
  if (which() != Store::Container::Object::Value::TEXT_VALUE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::Object::Value::Builder::hasTextValue() {
  if (which() != Store::Container::Object::Value::TEXT_VALUE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Store::Container::Object::Value::Reader::getTextValue() const {
  KJ_IREQUIRE((which() == Store::Container::Object::Value::TEXT_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Store::Container::Object::Value::Builder::getTextValue() {
  KJ_IREQUIRE((which() == Store::Container::Object::Value::TEXT_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Store::Container::Object::Value::Builder::setTextValue( ::capnp::Text::Reader value) {
  _builder.setDataField<Store::Container::Object::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Object::Value::TEXT_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Store::Container::Object::Value::Builder::initTextValue(unsigned int size) {
  _builder.setDataField<Store::Container::Object::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Object::Value::TEXT_VALUE);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Store::Container::Object::Value::Builder::adoptTextValue(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<Store::Container::Object::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Object::Value::TEXT_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Store::Container::Object::Value::Builder::disownTextValue() {
  KJ_IREQUIRE((which() == Store::Container::Object::Value::TEXT_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Store::Container::Object::Value::Reader::isDataValue() const {
  return which() == Store::Container::Object::Value::DATA_VALUE;
}
inline bool Store::Container::Object::Value::Builder::isDataValue() {
  return which() == Store::Container::Object::Value::DATA_VALUE;
}
inline bool Store::Container::Object::Value::Reader::hasDataValue() const {
  if (which() != Store::Container::Object::Value::DATA_VALUE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::Object::Value::Builder::hasDataValue() {
  if (which() != Store::Container::Object::Value::DATA_VALUE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader Store::Container::Object::Value::Reader::getDataValue() const {
  KJ_IREQUIRE((which() == Store::Container::Object::Value::DATA_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder Store::Container::Object::Value::Builder::getDataValue() {
  KJ_IREQUIRE((which() == Store::Container::Object::Value::DATA_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Store::Container::Object::Value::Builder::setDataValue( ::capnp::Data::Reader value) {
  _builder.setDataField<Store::Container::Object::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Object::Value::DATA_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder Store::Container::Object::Value::Builder::initDataValue(unsigned int size) {
  _builder.setDataField<Store::Container::Object::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Object::Value::DATA_VALUE);
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Store::Container::Object::Value::Builder::adoptDataValue(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  _builder.setDataField<Store::Container::Object::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Object::Value::DATA_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> Store::Container::Object::Value::Builder::disownDataValue() {
  KJ_IREQUIRE((which() == Store::Container::Object::Value::DATA_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Store::Container::Object::Value::Reader::isAnyValue() const {
  return which() == Store::Container::Object::Value::ANY_VALUE;
}
inline bool Store::Container::Object::Value::Builder::isAnyValue() {
  return which() == Store::Container::Object::Value::ANY_VALUE;
}
inline bool Store::Container::Object::Value::Reader::hasAnyValue() const {
  if (which() != Store::Container::Object::Value::ANY_VALUE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::Object::Value::Builder::hasAnyValue() {
  if (which() != Store::Container::Object::Value::ANY_VALUE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::AnyStruct::Reader Store::Container::Object::Value::Reader::getAnyValue() const {
  KJ_IREQUIRE((which() == Store::Container::Object::Value::ANY_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::AnyStruct>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::AnyStruct::Builder Store::Container::Object::Value::Builder::getAnyValue() {
  KJ_IREQUIRE((which() == Store::Container::Object::Value::ANY_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::AnyStruct>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Store::Container::Object::Value::Builder::setAnyValue( ::capnp::AnyStruct::Reader value) {
  _builder.setDataField<Store::Container::Object::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Object::Value::ANY_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::AnyStruct>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename T_>
inline ::capnp::BuilderFor<T_> Store::Container::Object::Value::Builder::initAnyValueAs() {
  static_assert(::capnp::kind<T_>() == ::capnp::Kind::STRUCT,
                "anyValue must be a struct");
  _builder.setDataField<Store::Container::Object::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Object::Value::ANY_VALUE);
  return ::capnp::_::PointerHelpers<T_>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Store::Container::Object::Value::Builder::adoptAnyValue(
    ::capnp::Orphan< ::capnp::AnyStruct>&& value) {
  _builder.setDataField<Store::Container::Object::Value::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Store::Container::Object::Value::ANY_VALUE);
  ::capnp::_::PointerHelpers< ::capnp::AnyStruct>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::AnyStruct> Store::Container::Object::Value::Builder::disownAnyValue() {
  KJ_IREQUIRE((which() == Store::Container::Object::Value::ANY_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::AnyStruct>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Store::Container::ImportDataParams::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::ImportDataParams::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader Store::Container::ImportDataParams::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder Store::Container::ImportDataParams::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::ImportDataParams::Builder::setData( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder Store::Container::ImportDataParams::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::ImportDataParams::Builder::adoptData(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> Store::Container::ImportDataParams::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::ImportDataResults::Reader::getSuccess() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Store::Container::ImportDataResults::Builder::getSuccess() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Store::Container::ImportDataResults::Builder::setSuccess(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Store::Container::ExportDataResults::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::ExportDataResults::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader Store::Container::ExportDataResults::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder Store::Container::ExportDataResults::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::ExportDataResults::Builder::setData( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder Store::Container::ExportDataResults::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::ExportDataResults::Builder::adoptData(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> Store::Container::ExportDataResults::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::ListObjectsResults::Reader::hasObjects() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::ListObjectsResults::Builder::hasObjects() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::storage::Store::Container::Object,  ::capnp::Kind::STRUCT>::Reader Store::Container::ListObjectsResults::Reader::getObjects() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::storage::Store::Container::Object,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::storage::Store::Container::Object,  ::capnp::Kind::STRUCT>::Builder Store::Container::ListObjectsResults::Builder::getObjects() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::storage::Store::Container::Object,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::ListObjectsResults::Builder::setObjects( ::capnp::List< ::mas::schema::storage::Store::Container::Object,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::storage::Store::Container::Object,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::storage::Store::Container::Object,  ::capnp::Kind::STRUCT>::Builder Store::Container::ListObjectsResults::Builder::initObjects(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::storage::Store::Container::Object,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::ListObjectsResults::Builder::adoptObjects(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::storage::Store::Container::Object,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::storage::Store::Container::Object,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::storage::Store::Container::Object,  ::capnp::Kind::STRUCT>> Store::Container::ListObjectsResults::Builder::disownObjects() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::storage::Store::Container::Object,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::GetObjectParams::Reader::hasKey() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::GetObjectParams::Builder::hasKey() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Store::Container::GetObjectParams::Reader::getKey() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Store::Container::GetObjectParams::Builder::getKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::GetObjectParams::Builder::setKey( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Store::Container::GetObjectParams::Builder::initKey(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::GetObjectParams::Builder::adoptKey(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Store::Container::GetObjectParams::Builder::disownKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::GetObjectResults::Reader::hasObject() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::GetObjectResults::Builder::hasObject() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::storage::Store::Container::Object::Reader Store::Container::GetObjectResults::Reader::getObject() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Object>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::storage::Store::Container::Object::Builder Store::Container::GetObjectResults::Builder::getObject() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Object>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::storage::Store::Container::Object::Pipeline Store::Container::GetObjectResults::Pipeline::getObject() {
  return  ::mas::schema::storage::Store::Container::Object::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Store::Container::GetObjectResults::Builder::setObject( ::mas::schema::storage::Store::Container::Object::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Object>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::storage::Store::Container::Object::Builder Store::Container::GetObjectResults::Builder::initObject() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Object>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::GetObjectResults::Builder::adoptObject(
    ::capnp::Orphan< ::mas::schema::storage::Store::Container::Object>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Object>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::storage::Store::Container::Object> Store::Container::GetObjectResults::Builder::disownObject() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Object>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::AddObjectParams::Reader::hasObject() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::AddObjectParams::Builder::hasObject() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::storage::Store::Container::Object::Reader Store::Container::AddObjectParams::Reader::getObject() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Object>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::storage::Store::Container::Object::Builder Store::Container::AddObjectParams::Builder::getObject() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Object>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::storage::Store::Container::Object::Pipeline Store::Container::AddObjectParams::Pipeline::getObject() {
  return  ::mas::schema::storage::Store::Container::Object::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Store::Container::AddObjectParams::Builder::setObject( ::mas::schema::storage::Store::Container::Object::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Object>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::storage::Store::Container::Object::Builder Store::Container::AddObjectParams::Builder::initObject() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Object>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::AddObjectParams::Builder::adoptObject(
    ::capnp::Orphan< ::mas::schema::storage::Store::Container::Object>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Object>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::storage::Store::Container::Object> Store::Container::AddObjectParams::Builder::disownObject() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container::Object>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::AddObjectResults::Reader::getSuccess() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Store::Container::AddObjectResults::Builder::getSuccess() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Store::Container::AddObjectResults::Builder::setSuccess(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Store::Container::RemoveObjectParams::Reader::hasKey() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::Container::RemoveObjectParams::Builder::hasKey() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Store::Container::RemoveObjectParams::Reader::getKey() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Store::Container::RemoveObjectParams::Builder::getKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::Container::RemoveObjectParams::Builder::setKey( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Store::Container::RemoveObjectParams::Builder::initKey(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::Container::RemoveObjectParams::Builder::adoptKey(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Store::Container::RemoveObjectParams::Builder::disownKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::Container::RemoveObjectResults::Reader::getSuccess() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Store::Container::RemoveObjectResults::Builder::getSuccess() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Store::Container::RemoveObjectResults::Builder::setSuccess(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Store::Container::ClearResults::Reader::getSuccess() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Store::Container::ClearResults::Builder::getSuccess() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Store::Container::ClearResults::Builder::setSuccess(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Store::NewContainerResults::Reader::hasContainer() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::NewContainerResults::Builder::hasContainer() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::storage::Store::Container::Client Store::NewContainerResults::Reader::getContainer() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::storage::Store::Container::Client Store::NewContainerResults::Builder::getContainer() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::storage::Store::Container::Client Store::NewContainerResults::Pipeline::getContainer() {
  return  ::mas::schema::storage::Store::Container::Client(_typeless.getPointerField(0).asCap());
}
inline void Store::NewContainerResults::Builder::setContainer( ::mas::schema::storage::Store::Container::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Store::NewContainerResults::Builder::setContainer( ::mas::schema::storage::Store::Container::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Store::NewContainerResults::Builder::adoptContainer(
    ::capnp::Orphan< ::mas::schema::storage::Store::Container>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::storage::Store::Container> Store::NewContainerResults::Builder::disownContainer() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Store::ContainerWithIdParams::Reader::hasId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::ContainerWithIdParams::Builder::hasId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Store::ContainerWithIdParams::Reader::getId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Store::ContainerWithIdParams::Builder::getId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::ContainerWithIdParams::Builder::setId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Store::ContainerWithIdParams::Builder::initId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::ContainerWithIdParams::Builder::adoptId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Store::ContainerWithIdParams::Builder::disownId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::ContainerWithIdResults::Reader::hasContainer() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::ContainerWithIdResults::Builder::hasContainer() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::storage::Store::Container::Client Store::ContainerWithIdResults::Reader::getContainer() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::storage::Store::Container::Client Store::ContainerWithIdResults::Builder::getContainer() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::storage::Store::Container::Client Store::ContainerWithIdResults::Pipeline::getContainer() {
  return  ::mas::schema::storage::Store::Container::Client(_typeless.getPointerField(0).asCap());
}
inline void Store::ContainerWithIdResults::Builder::setContainer( ::mas::schema::storage::Store::Container::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Store::ContainerWithIdResults::Builder::setContainer( ::mas::schema::storage::Store::Container::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Store::ContainerWithIdResults::Builder::adoptContainer(
    ::capnp::Orphan< ::mas::schema::storage::Store::Container>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::storage::Store::Container> Store::ContainerWithIdResults::Builder::disownContainer() {
  return ::capnp::_::PointerHelpers< ::mas::schema::storage::Store::Container>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Store::ListContainersResults::Reader::hasContainers() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::ListContainersResults::Builder::hasContainers() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>::Reader Store::ListContainersResults::Reader::getContainers() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>::Builder Store::ListContainersResults::Builder::getContainers() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::ListContainersResults::Builder::setContainers( ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>::Builder Store::ListContainersResults::Builder::initContainers(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::ListContainersResults::Builder::adoptContainers(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>> Store::ListContainersResults::Builder::disownContainers() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::storage::Store::Container,  ::capnp::Kind::INTERFACE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Store::RemoveContainerParams::Reader::hasId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Store::RemoveContainerParams::Builder::hasId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Store::RemoveContainerParams::Reader::getId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Store::RemoveContainerParams::Builder::getId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Store::RemoveContainerParams::Builder::setId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Store::RemoveContainerParams::Builder::initId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Store::RemoveContainerParams::Builder::adoptId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Store::RemoveContainerParams::Builder::disownId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Store::RemoveContainerResults::Reader::getSuccess() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Store::RemoveContainerResults::Builder::getSuccess() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Store::RemoveContainerResults::Builder::setSuccess(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

