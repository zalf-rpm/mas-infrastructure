// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: service.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#if CAPNP_VERSION != 10000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "common.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(fec1f88b198df649);
CAPNP_DECLARE_SCHEMA(d627f31bdae7f234);
CAPNP_DECLARE_SCHEMA(e01c2290ae549759);
CAPNP_DECLARE_SCHEMA(9abf358a691110fd);
CAPNP_DECLARE_SCHEMA(d6fd194a1ac74bc1);
CAPNP_DECLARE_SCHEMA(ddc3d3cd37ef5b78);
CAPNP_DECLARE_SCHEMA(ce2a1a063e759787);
CAPNP_DECLARE_SCHEMA(ff4271628d295896);
CAPNP_DECLARE_SCHEMA(f5423d8578dbb398);
CAPNP_DECLARE_SCHEMA(dc8472f9b668ba83);
CAPNP_DECLARE_SCHEMA(b15e79db08e2ab2c);
CAPNP_DECLARE_SCHEMA(aba5829222c213cb);
CAPNP_DECLARE_SCHEMA(a8296fdc60dcb6dd);
CAPNP_DECLARE_SCHEMA(89a33828e0de1eaa);
CAPNP_DECLARE_SCHEMA(8ab0ecb99c269c7f);
CAPNP_DECLARE_SCHEMA(c2b88517ccaa9197);
CAPNP_DECLARE_SCHEMA(b9816a53df7cb62e);
CAPNP_DECLARE_SCHEMA(d4d567352ab3882a);
CAPNP_DECLARE_SCHEMA(a962c127b5dccf05);

}  // namespace schemas
}  // namespace capnp

namespace mas {
namespace schema {
namespace service {

struct Admin {
  Admin() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct HeartbeatParams;
  struct HeartbeatResults;
  struct SetTimeoutParams;
  struct SetTimeoutResults;
  struct StopParams;
  struct StopResults;
  struct IdentitiesParams;
  struct IdentitiesResults;
  struct UpdateIdentityParams;
  struct UpdateIdentityResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(fec1f88b198df649)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Admin::HeartbeatParams {
  HeartbeatParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d627f31bdae7f234, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Admin::HeartbeatResults {
  HeartbeatResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e01c2290ae549759, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Admin::SetTimeoutParams {
  SetTimeoutParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9abf358a691110fd, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Admin::SetTimeoutResults {
  SetTimeoutResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d6fd194a1ac74bc1, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Admin::StopParams {
  StopParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ddc3d3cd37ef5b78, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Admin::StopResults {
  StopResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ce2a1a063e759787, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Admin::IdentitiesParams {
  IdentitiesParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ff4271628d295896, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Admin::IdentitiesResults {
  IdentitiesResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f5423d8578dbb398, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Admin::UpdateIdentityParams {
  UpdateIdentityParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dc8472f9b668ba83, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Admin::UpdateIdentityResults {
  UpdateIdentityResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b15e79db08e2ab2c, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SimpleFactory {
  SimpleFactory() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct CreateParams;
  struct CreateResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(aba5829222c213cb)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct SimpleFactory::CreateParams {
  CreateParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a8296fdc60dcb6dd, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SimpleFactory::CreateResults {
  CreateResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(89a33828e0de1eaa, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

template <typename Payload = ::capnp::AnyPointer>
struct Factory {
  Factory() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct CreateParams;
  struct AccessInfo;
  struct ServiceInterfaceNamesParams;
  struct ServiceInterfaceNamesResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(8ab0ecb99c269c7f)
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Payload>::brand(); }
  };
  #endif  // !CAPNP_LITE
};

template <typename Payload>
struct Factory<Payload>::CreateParams {
  CreateParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c2b88517ccaa9197, 1, 2)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Payload>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Payload>
struct Factory<Payload>::AccessInfo {
  AccessInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b9816a53df7cb62e, 0, 3)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Payload>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Payload>
struct Factory<Payload>::ServiceInterfaceNamesParams {
  ServiceInterfaceNamesParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d4d567352ab3882a, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Payload>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Payload>
struct Factory<Payload>::ServiceInterfaceNamesResults {
  ServiceInterfaceNamesResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a962c127b5dccf05, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Payload>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

#if !CAPNP_LITE
class Admin::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client {
public:
  typedef Admin Calls;
  typedef Admin Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::service::Admin::HeartbeatParams,  ::mas::schema::service::Admin::HeartbeatResults> heartbeatRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::service::Admin::SetTimeoutParams,  ::mas::schema::service::Admin::SetTimeoutResults> setTimeoutRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::service::Admin::StopParams,  ::mas::schema::service::Admin::StopResults> stopRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::service::Admin::IdentitiesParams,  ::mas::schema::service::Admin::IdentitiesResults> identitiesRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::service::Admin::UpdateIdentityParams,  ::mas::schema::service::Admin::UpdateIdentityResults> updateIdentityRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Admin::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server {
public:
  typedef Admin Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::service::Admin::HeartbeatParams HeartbeatParams;
  typedef  ::mas::schema::service::Admin::HeartbeatResults HeartbeatResults;
  typedef ::capnp::CallContext<HeartbeatParams, HeartbeatResults> HeartbeatContext;
  virtual ::kj::Promise<void> heartbeat(HeartbeatContext context);
  typedef  ::mas::schema::service::Admin::SetTimeoutParams SetTimeoutParams;
  typedef  ::mas::schema::service::Admin::SetTimeoutResults SetTimeoutResults;
  typedef ::capnp::CallContext<SetTimeoutParams, SetTimeoutResults> SetTimeoutContext;
  virtual ::kj::Promise<void> setTimeout(SetTimeoutContext context);
  typedef  ::mas::schema::service::Admin::StopParams StopParams;
  typedef  ::mas::schema::service::Admin::StopResults StopResults;
  typedef ::capnp::CallContext<StopParams, StopResults> StopContext;
  virtual ::kj::Promise<void> stop(StopContext context);
  typedef  ::mas::schema::service::Admin::IdentitiesParams IdentitiesParams;
  typedef  ::mas::schema::service::Admin::IdentitiesResults IdentitiesResults;
  typedef ::capnp::CallContext<IdentitiesParams, IdentitiesResults> IdentitiesContext;
  virtual ::kj::Promise<void> identities(IdentitiesContext context);
  typedef  ::mas::schema::service::Admin::UpdateIdentityParams UpdateIdentityParams;
  typedef  ::mas::schema::service::Admin::UpdateIdentityResults UpdateIdentityResults;
  typedef ::capnp::CallContext<UpdateIdentityParams, UpdateIdentityResults> UpdateIdentityContext;
  virtual ::kj::Promise<void> updateIdentity(UpdateIdentityContext context);

  inline  ::mas::schema::service::Admin::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::service::Admin>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Admin::HeartbeatParams::Reader {
public:
  typedef HeartbeatParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Admin::HeartbeatParams::Builder {
public:
  typedef HeartbeatParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Admin::HeartbeatParams::Pipeline {
public:
  typedef HeartbeatParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Admin::HeartbeatResults::Reader {
public:
  typedef HeartbeatResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Admin::HeartbeatResults::Builder {
public:
  typedef HeartbeatResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Admin::HeartbeatResults::Pipeline {
public:
  typedef HeartbeatResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Admin::SetTimeoutParams::Reader {
public:
  typedef SetTimeoutParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getSeconds() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Admin::SetTimeoutParams::Builder {
public:
  typedef SetTimeoutParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getSeconds();
  inline void setSeconds( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Admin::SetTimeoutParams::Pipeline {
public:
  typedef SetTimeoutParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Admin::SetTimeoutResults::Reader {
public:
  typedef SetTimeoutResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Admin::SetTimeoutResults::Builder {
public:
  typedef SetTimeoutResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Admin::SetTimeoutResults::Pipeline {
public:
  typedef SetTimeoutResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Admin::StopParams::Reader {
public:
  typedef StopParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Admin::StopParams::Builder {
public:
  typedef StopParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Admin::StopParams::Pipeline {
public:
  typedef StopParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Admin::StopResults::Reader {
public:
  typedef StopResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Admin::StopResults::Builder {
public:
  typedef StopResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Admin::StopResults::Pipeline {
public:
  typedef StopResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Admin::IdentitiesParams::Reader {
public:
  typedef IdentitiesParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Admin::IdentitiesParams::Builder {
public:
  typedef IdentitiesParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Admin::IdentitiesParams::Pipeline {
public:
  typedef IdentitiesParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Admin::IdentitiesResults::Reader {
public:
  typedef IdentitiesResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasInfos() const;
  inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Reader getInfos() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Admin::IdentitiesResults::Builder {
public:
  typedef IdentitiesResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasInfos();
  inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Builder getInfos();
  inline void setInfos( ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Builder initInfos(unsigned int size);
  inline void adoptInfos(::capnp::Orphan< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>> disownInfos();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Admin::IdentitiesResults::Pipeline {
public:
  typedef IdentitiesResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Admin::UpdateIdentityParams::Reader {
public:
  typedef UpdateIdentityParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasOldId() const;
  inline  ::capnp::Text::Reader getOldId() const;

  inline bool hasNewInfo() const;
  inline  ::mas::schema::common::IdInformation::Reader getNewInfo() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Admin::UpdateIdentityParams::Builder {
public:
  typedef UpdateIdentityParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasOldId();
  inline  ::capnp::Text::Builder getOldId();
  inline void setOldId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initOldId(unsigned int size);
  inline void adoptOldId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownOldId();

  inline bool hasNewInfo();
  inline  ::mas::schema::common::IdInformation::Builder getNewInfo();
  inline void setNewInfo( ::mas::schema::common::IdInformation::Reader value);
  inline  ::mas::schema::common::IdInformation::Builder initNewInfo();
  inline void adoptNewInfo(::capnp::Orphan< ::mas::schema::common::IdInformation>&& value);
  inline ::capnp::Orphan< ::mas::schema::common::IdInformation> disownNewInfo();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Admin::UpdateIdentityParams::Pipeline {
public:
  typedef UpdateIdentityParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::common::IdInformation::Pipeline getNewInfo();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Admin::UpdateIdentityResults::Reader {
public:
  typedef UpdateIdentityResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Admin::UpdateIdentityResults::Builder {
public:
  typedef UpdateIdentityResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Admin::UpdateIdentityResults::Pipeline {
public:
  typedef UpdateIdentityResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class SimpleFactory::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client {
public:
  typedef SimpleFactory Calls;
  typedef SimpleFactory Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::service::SimpleFactory::CreateParams,  ::mas::schema::service::SimpleFactory::CreateResults> createRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class SimpleFactory::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server {
public:
  typedef SimpleFactory Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::service::SimpleFactory::CreateParams CreateParams;
  typedef  ::mas::schema::service::SimpleFactory::CreateResults CreateResults;
  typedef ::capnp::CallContext<CreateParams, CreateResults> CreateContext;
  virtual ::kj::Promise<void> create(CreateContext context);

  inline  ::mas::schema::service::SimpleFactory::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::service::SimpleFactory>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class SimpleFactory::CreateParams::Reader {
public:
  typedef CreateParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SimpleFactory::CreateParams::Builder {
public:
  typedef CreateParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SimpleFactory::CreateParams::Pipeline {
public:
  typedef CreateParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SimpleFactory::CreateResults::Reader {
public:
  typedef CreateResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCaps() const;
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Reader getCaps() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SimpleFactory::CreateResults::Builder {
public:
  typedef CreateResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCaps();
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Builder getCaps();
  inline void setCaps( ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Reader value);
  inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Builder initCaps(unsigned int size);
  inline void adoptCaps(::capnp::Orphan< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>> disownCaps();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SimpleFactory::CreateResults::Pipeline {
public:
  typedef CreateResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename Payload>
class Factory<Payload>::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client {
public:
  typedef Factory Calls;
  typedef Factory Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename Payload2 = ::capnp::AnyPointer>
  typename Factory<Payload2>::Client asGeneric() {
    return castAs<Factory<Payload2>>();
  }

  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::service::Factory<Payload>::CreateParams, typename  ::mas::schema::service::Factory<Payload>::AccessInfo>) createRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::service::Factory<Payload>::ServiceInterfaceNamesParams, typename  ::mas::schema::service::Factory<Payload>::ServiceInterfaceNamesResults>) serviceInterfaceNamesRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

template <typename Payload>
class Factory<Payload>::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server {
public:
  typedef Factory Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef ::capnp::CallContext<typename  ::mas::schema::service::Factory<Payload>::CreateParams, typename  ::mas::schema::service::Factory<Payload>::AccessInfo> CreateContext;
  virtual ::kj::Promise<void> create(CreateContext context);
  typedef typename  ::mas::schema::service::Factory<Payload>::ServiceInterfaceNamesParams ServiceInterfaceNamesParams;
  typedef typename  ::mas::schema::service::Factory<Payload>::ServiceInterfaceNamesResults ServiceInterfaceNamesResults;
  typedef ::capnp::CallContext<ServiceInterfaceNamesParams, ServiceInterfaceNamesResults> ServiceInterfaceNamesContext;
  virtual ::kj::Promise<void> serviceInterfaceNames(ServiceInterfaceNamesContext context);

  inline typename  ::mas::schema::service::Factory<Payload>::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::service::Factory<Payload>>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename Payload>
class Factory<Payload>::CreateParams::Reader {
public:
  typedef CreateParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Payload2 = ::capnp::AnyPointer>
  typename Factory<Payload2>::CreateParams::Reader asFactoryGeneric() {
    return typename Factory<Payload2>::CreateParams::Reader(_reader);
  }

  inline  ::uint64_t getTimeoutSeconds() const;

  inline bool hasInterfaceNameToRegistrySR() const;
  inline  ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>::Reader getInterfaceNameToRegistrySR() const;

  inline bool hasMsgPayload() const;
  inline  ::capnp::ReaderFor<Payload> getMsgPayload() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Payload>
class Factory<Payload>::CreateParams::Builder {
public:
  typedef CreateParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Payload2 = ::capnp::AnyPointer>
  typename Factory<Payload2>::CreateParams::Builder asFactoryGeneric() {
    return typename Factory<Payload2>::CreateParams::Builder(_builder);
  }

  inline  ::uint64_t getTimeoutSeconds();
  inline void setTimeoutSeconds( ::uint64_t value);

  inline bool hasInterfaceNameToRegistrySR();
  inline  ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>::Builder getInterfaceNameToRegistrySR();
  inline void setInterfaceNameToRegistrySR( ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>::Builder initInterfaceNameToRegistrySR(unsigned int size);
  inline void adoptInterfaceNameToRegistrySR(::capnp::Orphan< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>> disownInterfaceNameToRegistrySR();

  inline bool hasMsgPayload();
  inline  ::capnp::BuilderFor<Payload> getMsgPayload();
  inline void setMsgPayload( ::capnp::ReaderFor<Payload> value);
  inline  ::capnp::BuilderFor<Payload> initMsgPayload();
  inline  ::capnp::BuilderFor<Payload> initMsgPayload(unsigned int size);
  inline void adoptMsgPayload(::capnp::Orphan<Payload>&& value);
  inline ::capnp::Orphan<Payload> disownMsgPayload();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Payload>
class Factory<Payload>::CreateParams::Pipeline {
public:
  typedef CreateParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<Payload> getMsgPayload();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Payload>
class Factory<Payload>::AccessInfo::Reader {
public:
  typedef AccessInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Payload2 = ::capnp::AnyPointer>
  typename Factory<Payload2>::AccessInfo::Reader asFactoryGeneric() {
    return typename Factory<Payload2>::AccessInfo::Reader(_reader);
  }

  inline bool hasAdminCap() const;
#if !CAPNP_LITE
  inline  ::capnp::Capability::Client getAdminCap() const;
#endif  // !CAPNP_LITE

  inline bool hasServiceCaps() const;
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Reader getServiceCaps() const;
#endif  // !CAPNP_LITE

  inline bool hasError() const;
  inline  ::capnp::Text::Reader getError() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Payload>
class Factory<Payload>::AccessInfo::Builder {
public:
  typedef AccessInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Payload2 = ::capnp::AnyPointer>
  typename Factory<Payload2>::AccessInfo::Builder asFactoryGeneric() {
    return typename Factory<Payload2>::AccessInfo::Builder(_builder);
  }

  inline bool hasAdminCap();
#if !CAPNP_LITE
  inline  ::capnp::Capability::Client getAdminCap();
  inline void setAdminCap( ::capnp::Capability::Client&& value);
  inline void setAdminCap( ::capnp::Capability::Client& value);
  inline void adoptAdminCap(::capnp::Orphan< ::capnp::Capability>&& value);
  inline ::capnp::Orphan< ::capnp::Capability> disownAdminCap();
#endif  // !CAPNP_LITE

  inline bool hasServiceCaps();
#if !CAPNP_LITE
  inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Builder getServiceCaps();
  inline void setServiceCaps( ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Reader value);
  inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Builder initServiceCaps(unsigned int size);
  inline void adoptServiceCaps(::capnp::Orphan< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>> disownServiceCaps();
#endif  // !CAPNP_LITE

  inline bool hasError();
  inline  ::capnp::Text::Builder getError();
  inline void setError( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initError(unsigned int size);
  inline void adoptError(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownError();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Payload>
class Factory<Payload>::AccessInfo::Pipeline {
public:
  typedef AccessInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::Capability::Client getAdminCap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Payload>
class Factory<Payload>::ServiceInterfaceNamesParams::Reader {
public:
  typedef ServiceInterfaceNamesParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Payload2 = ::capnp::AnyPointer>
  typename Factory<Payload2>::ServiceInterfaceNamesParams::Reader asFactoryGeneric() {
    return typename Factory<Payload2>::ServiceInterfaceNamesParams::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Payload>
class Factory<Payload>::ServiceInterfaceNamesParams::Builder {
public:
  typedef ServiceInterfaceNamesParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Payload2 = ::capnp::AnyPointer>
  typename Factory<Payload2>::ServiceInterfaceNamesParams::Builder asFactoryGeneric() {
    return typename Factory<Payload2>::ServiceInterfaceNamesParams::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Payload>
class Factory<Payload>::ServiceInterfaceNamesParams::Pipeline {
public:
  typedef ServiceInterfaceNamesParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Payload>
class Factory<Payload>::ServiceInterfaceNamesResults::Reader {
public:
  typedef ServiceInterfaceNamesResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Payload2 = ::capnp::AnyPointer>
  typename Factory<Payload2>::ServiceInterfaceNamesResults::Reader asFactoryGeneric() {
    return typename Factory<Payload2>::ServiceInterfaceNamesResults::Reader(_reader);
  }

  inline bool hasNames() const;
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader getNames() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Payload>
class Factory<Payload>::ServiceInterfaceNamesResults::Builder {
public:
  typedef ServiceInterfaceNamesResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Payload2 = ::capnp::AnyPointer>
  typename Factory<Payload2>::ServiceInterfaceNamesResults::Builder asFactoryGeneric() {
    return typename Factory<Payload2>::ServiceInterfaceNamesResults::Builder(_builder);
  }

  inline bool hasNames();
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder getNames();
  inline void setNames( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value);
  inline void setNames(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder initNames(unsigned int size);
  inline void adoptNames(::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> disownNames();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Payload>
class Factory<Payload>::ServiceInterfaceNamesResults::Pipeline {
public:
  typedef ServiceInterfaceNamesResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

#if !CAPNP_LITE
inline Admin::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Admin::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Admin::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Admin::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Admin::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::service::Admin::Client& Admin::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::service::Admin::Client& Admin::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline  ::uint64_t Admin::SetTimeoutParams::Reader::getSeconds() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Admin::SetTimeoutParams::Builder::getSeconds() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Admin::SetTimeoutParams::Builder::setSeconds( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Admin::IdentitiesResults::Reader::hasInfos() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Admin::IdentitiesResults::Builder::hasInfos() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Reader Admin::IdentitiesResults::Reader::getInfos() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Builder Admin::IdentitiesResults::Builder::getInfos() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Admin::IdentitiesResults::Builder::setInfos( ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>::Builder Admin::IdentitiesResults::Builder::initInfos(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Admin::IdentitiesResults::Builder::adoptInfos(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>> Admin::IdentitiesResults::Builder::disownInfos() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IdInformation,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Admin::UpdateIdentityParams::Reader::hasOldId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Admin::UpdateIdentityParams::Builder::hasOldId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Admin::UpdateIdentityParams::Reader::getOldId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Admin::UpdateIdentityParams::Builder::getOldId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Admin::UpdateIdentityParams::Builder::setOldId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Admin::UpdateIdentityParams::Builder::initOldId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Admin::UpdateIdentityParams::Builder::adoptOldId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Admin::UpdateIdentityParams::Builder::disownOldId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Admin::UpdateIdentityParams::Reader::hasNewInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Admin::UpdateIdentityParams::Builder::hasNewInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::common::IdInformation::Reader Admin::UpdateIdentityParams::Reader::getNewInfo() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::IdInformation::Builder Admin::UpdateIdentityParams::Builder::getNewInfo() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::common::IdInformation::Pipeline Admin::UpdateIdentityParams::Pipeline::getNewInfo() {
  return  ::mas::schema::common::IdInformation::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Admin::UpdateIdentityParams::Builder::setNewInfo( ::mas::schema::common::IdInformation::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::common::IdInformation::Builder Admin::UpdateIdentityParams::Builder::initNewInfo() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Admin::UpdateIdentityParams::Builder::adoptNewInfo(
    ::capnp::Orphan< ::mas::schema::common::IdInformation>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::common::IdInformation> Admin::UpdateIdentityParams::Builder::disownNewInfo() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::IdInformation>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline SimpleFactory::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline SimpleFactory::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline SimpleFactory::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline SimpleFactory::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline SimpleFactory::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::service::SimpleFactory::Client& SimpleFactory::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::service::SimpleFactory::Client& SimpleFactory::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool SimpleFactory::CreateResults::Reader::hasCaps() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SimpleFactory::CreateResults::Builder::hasCaps() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Reader SimpleFactory::CreateResults::Reader::getCaps() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Builder SimpleFactory::CreateResults::Builder::getCaps() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SimpleFactory::CreateResults::Builder::setCaps( ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Builder SimpleFactory::CreateResults::Builder::initCaps(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void SimpleFactory::CreateResults::Builder::adoptCaps(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>> SimpleFactory::CreateResults::Builder::disownCaps() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename Payload>
inline Factory<Payload>::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
template <typename Payload>
inline Factory<Payload>::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename Payload>
template <typename _t, typename>
inline Factory<Payload>::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename Payload>
template <typename _t, typename>
inline Factory<Payload>::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
template <typename Payload>
inline Factory<Payload>::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
template <typename Payload>
inline typename  ::mas::schema::service::Factory<Payload>::Client& Factory<Payload>::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
template <typename Payload>
inline typename  ::mas::schema::service::Factory<Payload>::Client& Factory<Payload>::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
template <typename Payload>
inline  ::uint64_t Factory<Payload>::CreateParams::Reader::getTimeoutSeconds() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 3600ull);
}

template <typename Payload>
inline  ::uint64_t Factory<Payload>::CreateParams::Builder::getTimeoutSeconds() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 3600ull);
}
template <typename Payload>
inline void Factory<Payload>::CreateParams::Builder::setTimeoutSeconds( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, 3600ull);
}

template <typename Payload>
inline bool Factory<Payload>::CreateParams::Reader::hasInterfaceNameToRegistrySR() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Payload>
inline bool Factory<Payload>::CreateParams::Builder::hasInterfaceNameToRegistrySR() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Payload>
inline  ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>::Reader Factory<Payload>::CreateParams::Reader::getInterfaceNameToRegistrySR() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Payload>
inline  ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>::Builder Factory<Payload>::CreateParams::Builder::getInterfaceNameToRegistrySR() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Payload>
inline void Factory<Payload>::CreateParams::Builder::setInterfaceNameToRegistrySR( ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Payload>
inline  ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>::Builder Factory<Payload>::CreateParams::Builder::initInterfaceNameToRegistrySR(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Payload>
inline void Factory<Payload>::CreateParams::Builder::adoptInterfaceNameToRegistrySR(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Payload>
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>> Factory<Payload>::CreateParams::Builder::disownInterfaceNameToRegistrySR() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename Payload>
inline bool Factory<Payload>::CreateParams::Reader::hasMsgPayload() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Payload>
inline bool Factory<Payload>::CreateParams::Builder::hasMsgPayload() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Payload>
inline  ::capnp::ReaderFor<Payload> Factory<Payload>::CreateParams::Reader::getMsgPayload() const {
  return ::capnp::_::PointerHelpers<Payload>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Payload>
inline  ::capnp::BuilderFor<Payload> Factory<Payload>::CreateParams::Builder::getMsgPayload() {
  return ::capnp::_::PointerHelpers<Payload>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Payload>
inline  ::capnp::PipelineFor<Payload> Factory<Payload>::CreateParams::Pipeline::getMsgPayload() {
  return  ::capnp::PipelineFor<Payload>(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
template <typename Payload>
inline void Factory<Payload>::CreateParams::Builder::setMsgPayload( ::capnp::ReaderFor<Payload> value) {
  ::capnp::_::PointerHelpers<Payload>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename Payload>
inline  ::capnp::BuilderFor<Payload> Factory<Payload>::CreateParams::Builder::initMsgPayload() {
  return ::capnp::_::PointerHelpers<Payload>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Payload>
inline  ::capnp::BuilderFor<Payload> Factory<Payload>::CreateParams::Builder::initMsgPayload(unsigned int size) {
  return ::capnp::_::PointerHelpers<Payload>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
template <typename Payload>
inline void Factory<Payload>::CreateParams::Builder::adoptMsgPayload(
    ::capnp::Orphan<Payload>&& value) {
  ::capnp::_::PointerHelpers<Payload>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Payload>
inline ::capnp::Orphan<Payload> Factory<Payload>::CreateParams::Builder::disownMsgPayload() {
  return ::capnp::_::PointerHelpers<Payload>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

// Factory<Payload>::CreateParams
template <typename Payload>
constexpr uint16_t Factory<Payload>::CreateParams::_capnpPrivate::dataWordSize;
template <typename Payload>
constexpr uint16_t Factory<Payload>::CreateParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Payload>
constexpr ::capnp::Kind Factory<Payload>::CreateParams::_capnpPrivate::kind;
template <typename Payload>
constexpr ::capnp::_::RawSchema const* Factory<Payload>::CreateParams::_capnpPrivate::schema;
template <typename Payload>
const ::capnp::_::RawBrandedSchema::Scope Factory<Payload>::CreateParams::_capnpPrivate::brandScopes[] = {
  { 0x8ab0ecb99c269c7f, brandBindings + 0, 1, false},
};
template <typename Payload>
const ::capnp::_::RawBrandedSchema::Binding Factory<Payload>::CreateParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Payload>(),
};
template <typename Payload>
const ::capnp::_::RawBrandedSchema::Dependency Factory<Payload>::CreateParams::_capnpPrivate::brandDependencies[] = {
  { 16777217,  ::mas::schema::common::Pair< ::capnp::Text,  ::capnp::Text>::_capnpPrivate::brand() },
};
template <typename Payload>
const ::capnp::_::RawBrandedSchema Factory<Payload>::CreateParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_c2b88517ccaa9197, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE

template <typename Payload>
inline bool Factory<Payload>::AccessInfo::Reader::hasAdminCap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Payload>
inline bool Factory<Payload>::AccessInfo::Builder::hasAdminCap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename Payload>
inline  ::capnp::Capability::Client Factory<Payload>::AccessInfo::Reader::getAdminCap() const {
  return ::capnp::_::PointerHelpers< ::capnp::Capability>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Payload>
inline  ::capnp::Capability::Client Factory<Payload>::AccessInfo::Builder::getAdminCap() {
  return ::capnp::_::PointerHelpers< ::capnp::Capability>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Payload>
inline  ::capnp::Capability::Client Factory<Payload>::AccessInfo::Pipeline::getAdminCap() {
  return  ::capnp::Capability::Client(_typeless.getPointerField(0).asCap());
}
template <typename Payload>
inline void Factory<Payload>::AccessInfo::Builder::setAdminCap( ::capnp::Capability::Client&& cap) {
  ::capnp::_::PointerHelpers< ::capnp::Capability>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
template <typename Payload>
inline void Factory<Payload>::AccessInfo::Builder::setAdminCap( ::capnp::Capability::Client& cap) {
  ::capnp::_::PointerHelpers< ::capnp::Capability>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
template <typename Payload>
inline void Factory<Payload>::AccessInfo::Builder::adoptAdminCap(
    ::capnp::Orphan< ::capnp::Capability>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Capability>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Payload>
inline ::capnp::Orphan< ::capnp::Capability> Factory<Payload>::AccessInfo::Builder::disownAdminCap() {
  return ::capnp::_::PointerHelpers< ::capnp::Capability>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

template <typename Payload>
inline bool Factory<Payload>::AccessInfo::Reader::hasServiceCaps() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Payload>
inline bool Factory<Payload>::AccessInfo::Builder::hasServiceCaps() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename Payload>
inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Reader Factory<Payload>::AccessInfo::Reader::getServiceCaps() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Payload>
inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Builder Factory<Payload>::AccessInfo::Builder::getServiceCaps() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Payload>
inline void Factory<Payload>::AccessInfo::Builder::setServiceCaps( ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename Payload>
inline  ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>::Builder Factory<Payload>::AccessInfo::Builder::initServiceCaps(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
template <typename Payload>
inline void Factory<Payload>::AccessInfo::Builder::adoptServiceCaps(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Payload>
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>> Factory<Payload>::AccessInfo::Builder::disownServiceCaps() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::Identifiable,  ::capnp::Kind::INTERFACE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

template <typename Payload>
inline bool Factory<Payload>::AccessInfo::Reader::hasError() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
template <typename Payload>
inline bool Factory<Payload>::AccessInfo::Builder::hasError() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
template <typename Payload>
inline  ::capnp::Text::Reader Factory<Payload>::AccessInfo::Reader::getError() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
template <typename Payload>
inline  ::capnp::Text::Builder Factory<Payload>::AccessInfo::Builder::getError() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
template <typename Payload>
inline void Factory<Payload>::AccessInfo::Builder::setError( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
template <typename Payload>
inline  ::capnp::Text::Builder Factory<Payload>::AccessInfo::Builder::initError(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
template <typename Payload>
inline void Factory<Payload>::AccessInfo::Builder::adoptError(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Payload>
inline ::capnp::Orphan< ::capnp::Text> Factory<Payload>::AccessInfo::Builder::disownError() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

// Factory<Payload>::AccessInfo
template <typename Payload>
constexpr uint16_t Factory<Payload>::AccessInfo::_capnpPrivate::dataWordSize;
template <typename Payload>
constexpr uint16_t Factory<Payload>::AccessInfo::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Payload>
constexpr ::capnp::Kind Factory<Payload>::AccessInfo::_capnpPrivate::kind;
template <typename Payload>
constexpr ::capnp::_::RawSchema const* Factory<Payload>::AccessInfo::_capnpPrivate::schema;
template <typename Payload>
const ::capnp::_::RawBrandedSchema::Scope Factory<Payload>::AccessInfo::_capnpPrivate::brandScopes[] = {
  { 0x8ab0ecb99c269c7f, brandBindings + 0, 1, false},
};
template <typename Payload>
const ::capnp::_::RawBrandedSchema::Binding Factory<Payload>::AccessInfo::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Payload>(),
};
template <typename Payload>
const ::capnp::_::RawBrandedSchema Factory<Payload>::AccessInfo::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_b9816a53df7cb62e, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Factory<Payload>::ServiceInterfaceNamesParams
template <typename Payload>
constexpr uint16_t Factory<Payload>::ServiceInterfaceNamesParams::_capnpPrivate::dataWordSize;
template <typename Payload>
constexpr uint16_t Factory<Payload>::ServiceInterfaceNamesParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Payload>
constexpr ::capnp::Kind Factory<Payload>::ServiceInterfaceNamesParams::_capnpPrivate::kind;
template <typename Payload>
constexpr ::capnp::_::RawSchema const* Factory<Payload>::ServiceInterfaceNamesParams::_capnpPrivate::schema;
template <typename Payload>
const ::capnp::_::RawBrandedSchema::Scope Factory<Payload>::ServiceInterfaceNamesParams::_capnpPrivate::brandScopes[] = {
  { 0x8ab0ecb99c269c7f, brandBindings + 0, 1, false},
};
template <typename Payload>
const ::capnp::_::RawBrandedSchema::Binding Factory<Payload>::ServiceInterfaceNamesParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Payload>(),
};
template <typename Payload>
const ::capnp::_::RawBrandedSchema Factory<Payload>::ServiceInterfaceNamesParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_d4d567352ab3882a, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename Payload>
inline bool Factory<Payload>::ServiceInterfaceNamesResults::Reader::hasNames() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Payload>
inline bool Factory<Payload>::ServiceInterfaceNamesResults::Builder::hasNames() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Payload>
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader Factory<Payload>::ServiceInterfaceNamesResults::Reader::getNames() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Payload>
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Factory<Payload>::ServiceInterfaceNamesResults::Builder::getNames() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Payload>
inline void Factory<Payload>::ServiceInterfaceNamesResults::Builder::setNames( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Payload>
inline void Factory<Payload>::ServiceInterfaceNamesResults::Builder::setNames(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Payload>
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Factory<Payload>::ServiceInterfaceNamesResults::Builder::initNames(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Payload>
inline void Factory<Payload>::ServiceInterfaceNamesResults::Builder::adoptNames(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Payload>
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> Factory<Payload>::ServiceInterfaceNamesResults::Builder::disownNames() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// Factory<Payload>::ServiceInterfaceNamesResults
template <typename Payload>
constexpr uint16_t Factory<Payload>::ServiceInterfaceNamesResults::_capnpPrivate::dataWordSize;
template <typename Payload>
constexpr uint16_t Factory<Payload>::ServiceInterfaceNamesResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Payload>
constexpr ::capnp::Kind Factory<Payload>::ServiceInterfaceNamesResults::_capnpPrivate::kind;
template <typename Payload>
constexpr ::capnp::_::RawSchema const* Factory<Payload>::ServiceInterfaceNamesResults::_capnpPrivate::schema;
template <typename Payload>
const ::capnp::_::RawBrandedSchema::Scope Factory<Payload>::ServiceInterfaceNamesResults::_capnpPrivate::brandScopes[] = {
  { 0x8ab0ecb99c269c7f, brandBindings + 0, 1, false},
};
template <typename Payload>
const ::capnp::_::RawBrandedSchema::Binding Factory<Payload>::ServiceInterfaceNamesResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Payload>(),
};
template <typename Payload>
const ::capnp::_::RawBrandedSchema Factory<Payload>::ServiceInterfaceNamesResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_a962c127b5dccf05, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename Payload>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::service::Factory<Payload>::CreateParams, typename  ::mas::schema::service::Factory<Payload>::AccessInfo>)
Factory<Payload>::Client::createRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::service::Factory<Payload>::CreateParams, typename  ::mas::schema::service::Factory<Payload>::AccessInfo>(
      0x8ab0ecb99c269c7full, 0, sizeHint);
}
template <typename Payload>
::kj::Promise<void> Factory<Payload>::Server::create(CreateContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "service.capnp:Factory", "create",
      0x8ab0ecb99c269c7full, 0);
}
template <typename Payload>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::service::Factory<Payload>::ServiceInterfaceNamesParams, typename  ::mas::schema::service::Factory<Payload>::ServiceInterfaceNamesResults>)
Factory<Payload>::Client::serviceInterfaceNamesRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::service::Factory<Payload>::ServiceInterfaceNamesParams, typename  ::mas::schema::service::Factory<Payload>::ServiceInterfaceNamesResults>(
      0x8ab0ecb99c269c7full, 1, sizeHint);
}
template <typename Payload>
::kj::Promise<void> Factory<Payload>::Server::serviceInterfaceNames(ServiceInterfaceNamesContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "service.capnp:Factory", "serviceInterfaceNames",
      0x8ab0ecb99c269c7full, 1);
}
template <typename Payload>
::capnp::Capability::Server::DispatchCallResult Factory<Payload>::Server::dispatchCall(
    uint64_t interfaceId, uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (interfaceId) {
    case 0x8ab0ecb99c269c7full:
      return dispatchCallInternal(methodId, context);
    case 0xb2afd1cb599c48d5ull:
      return  ::mas::schema::common::Identifiable::Server::dispatchCallInternal(methodId, context);
    default:
      return internalUnimplemented("service.capnp:Factory", interfaceId);
  }
}
template <typename Payload>
::capnp::Capability::Server::DispatchCallResult Factory<Payload>::Server::dispatchCallInternal(
    uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (methodId) {
    case 0:
      return {
        create(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::service::Factory<Payload>::CreateParams, typename  ::mas::schema::service::Factory<Payload>::AccessInfo>(context)),
        false
      };
    case 1:
      return {
        serviceInterfaceNames(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::service::Factory<Payload>::ServiceInterfaceNamesParams, typename  ::mas::schema::service::Factory<Payload>::ServiceInterfaceNamesResults>(context)),
        false
      };
    default:
      (void)context;
      return ::capnp::Capability::Server::internalUnimplemented(
          "service.capnp:Factory",
          0x8ab0ecb99c269c7full, methodId);
  }
}
#endif  // !CAPNP_LITE

// Factory<Payload>
#if !CAPNP_LITE
template <typename Payload>
constexpr ::capnp::Kind Factory<Payload>::_capnpPrivate::kind;
template <typename Payload>
constexpr ::capnp::_::RawSchema const* Factory<Payload>::_capnpPrivate::schema;
template <typename Payload>
const ::capnp::_::RawBrandedSchema::Scope Factory<Payload>::_capnpPrivate::brandScopes[] = {
  { 0x8ab0ecb99c269c7f, brandBindings + 0, 1, false},
};
template <typename Payload>
const ::capnp::_::RawBrandedSchema::Binding Factory<Payload>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Payload>(),
};
template <typename Payload>
const ::capnp::_::RawBrandedSchema::Dependency Factory<Payload>::_capnpPrivate::brandDependencies[] = {
  { 33554432,  ::mas::schema::service::Factory<Payload>::CreateParams::_capnpPrivate::brand() },
  { 33554433,  ::mas::schema::service::Factory<Payload>::ServiceInterfaceNamesParams::_capnpPrivate::brand() },
  { 50331648,  ::mas::schema::service::Factory<Payload>::AccessInfo::_capnpPrivate::brand() },
  { 50331649,  ::mas::schema::service::Factory<Payload>::ServiceInterfaceNamesResults::_capnpPrivate::brand() },
};
template <typename Payload>
const ::capnp::_::RawBrandedSchema Factory<Payload>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_8ab0ecb99c269c7f, brandScopes, brandDependencies,
  1, 4, nullptr
};
#endif  // !CAPNP_LITE

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

