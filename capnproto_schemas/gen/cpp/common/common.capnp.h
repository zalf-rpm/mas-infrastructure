// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: common.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#if CAPNP_VERSION != 10000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "persistence.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(d4cb7ecbfe03dad3);
CAPNP_DECLARE_SCHEMA(b2afd1cb599c48d5);
CAPNP_DECLARE_SCHEMA(9d8aa1cf1e49deb1);
CAPNP_DECLARE_SCHEMA(ed6c098b67cad454);
CAPNP_DECLARE_SCHEMA(e8cbf552b1c262cc);
CAPNP_DECLARE_SCHEMA(902904cd51bff117);
CAPNP_DECLARE_SCHEMA(83b4353989cbcb47);
CAPNP_DECLARE_SCHEMA(b16b6184cf8b8acf);
CAPNP_DECLARE_SCHEMA(9dd4e2c3d76e4587);
CAPNP_DECLARE_SCHEMA(f9033a317ba0d0c6);
CAPNP_DECLARE_SCHEMA(cc040dde1a99ddff);
CAPNP_DECLARE_SCHEMA(c12db9a9ae07a763);
CAPNP_DECLARE_SCHEMA(a1eb17b1112501da);
CAPNP_DECLARE_SCHEMA(fd65c3cd7f2f47fa);
CAPNP_DECLARE_SCHEMA(a869f50b8c586ed9);
CAPNP_DECLARE_SCHEMA(fd058bbd1f9508cd);
CAPNP_DECLARE_SCHEMA(d010f77f1bdf0522);
CAPNP_DECLARE_SCHEMA(fe04fe97ba25a27e);
CAPNP_DECLARE_SCHEMA(cac9c6537df1a097);
CAPNP_DECLARE_SCHEMA(da52b34d937fa814);
CAPNP_DECLARE_SCHEMA(dc9b0f483595691f);
CAPNP_DECLARE_SCHEMA(82449708d4fd120d);
CAPNP_DECLARE_SCHEMA(c1374ccca01e2b53);
CAPNP_DECLARE_SCHEMA(ee543d7c305d56f6);
CAPNP_DECLARE_SCHEMA(93a1b0e66bcacfbb);
CAPNP_DECLARE_SCHEMA(b9fe596d7cadbdcc);
CAPNP_DECLARE_SCHEMA(d69f2da1efe3faaf);
CAPNP_DECLARE_SCHEMA(8ca159db7de3927b);
CAPNP_DECLARE_SCHEMA(c201bf46dd40051e);
CAPNP_DECLARE_SCHEMA(ce7e4202f09e314a);
CAPNP_DECLARE_SCHEMA(98a27c9476315729);
CAPNP_DECLARE_SCHEMA(d3a3b24aaa056a5c);
CAPNP_DECLARE_SCHEMA(b9d4864725174733);
CAPNP_DECLARE_SCHEMA(d67792aa3fc241be);

}  // namespace schemas
}  // namespace capnp

namespace mas {
namespace schema {
namespace common {

struct IdInformation {
  IdInformation() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d4cb7ecbfe03dad3, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Identifiable {
  Identifiable() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct InfoParams;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(b2afd1cb599c48d5)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Identifiable::InfoParams {
  InfoParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9d8aa1cf1e49deb1, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct StructuredText {
  StructuredText() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Structure;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ed6c098b67cad454, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct StructuredText::Structure {
  Structure() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    NONE,
    JSON,
    XML,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e8cbf552b1c262cc, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Callback {
  Callback() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct CallParams;
  struct CallResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(902904cd51bff117)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Callback::CallParams {
  CallParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(83b4353989cbcb47, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Callback::CallResults {
  CallResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b16b6184cf8b8acf, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Action {
  Action() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct DoParams;
  struct DoResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(9dd4e2c3d76e4587)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Action::DoParams {
  DoParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f9033a317ba0d0c6, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Action::DoResults {
  DoResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cc040dde1a99ddff, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Action1 {
  Action1() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct DoParams;
  struct DoResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(c12db9a9ae07a763)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Action1::DoParams {
  DoParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a1eb17b1112501da, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Action1::DoResults {
  DoResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fd65c3cd7f2f47fa, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

template <typename Input = ::capnp::AnyPointer, typename Output = ::capnp::AnyPointer>
struct Factory {
  Factory() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct ProduceParams;
  struct ProduceResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(a869f50b8c586ed9)
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Input, Output>::brand(); }
  };
  #endif  // !CAPNP_LITE
};

template <typename Input, typename Output>
struct Factory<Input, Output>::ProduceParams {
  ProduceParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fd058bbd1f9508cd, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Input, Output>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Input, typename Output>
struct Factory<Input, Output>::ProduceResults {
  ProduceResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d010f77f1bdf0522, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Input, Output>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

struct ZmqPipelineAddresses {
  ZmqPipelineAddresses() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fe04fe97ba25a27e, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

template <typename Object = ::capnp::AnyPointer>
struct CapHolder {
  CapHolder() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct CapParams;
  struct CapResults;
  struct ReleaseParams;
  struct ReleaseResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(cac9c6537df1a097)
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Object>::brand(); }
  };
  #endif  // !CAPNP_LITE
};

template <typename Object>
struct CapHolder<Object>::CapParams {
  CapParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(da52b34d937fa814, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Object>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Object>
struct CapHolder<Object>::CapResults {
  CapResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dc9b0f483595691f, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Object>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Object>
struct CapHolder<Object>::ReleaseParams {
  ReleaseParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(82449708d4fd120d, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Object>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Object>
struct CapHolder<Object>::ReleaseResults {
  ReleaseResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c1374ccca01e2b53, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Object>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

struct IdentifiableHolder {
  IdentifiableHolder() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct CapParams;
  struct CapResults;
  struct ReleaseParams;
  struct ReleaseResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(ee543d7c305d56f6)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct IdentifiableHolder::CapParams {
  CapParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(93a1b0e66bcacfbb, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct IdentifiableHolder::CapResults {
  CapResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b9fe596d7cadbdcc, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct IdentifiableHolder::ReleaseParams {
  ReleaseParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d69f2da1efe3faaf, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct IdentifiableHolder::ReleaseResults {
  ReleaseResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8ca159db7de3927b, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

template <typename PointerType = ::capnp::AnyPointer>
struct ListEntry {
  ListEntry() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c201bf46dd40051e, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, PointerType>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

struct Stopable {
  Stopable() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct StopParams;
  struct StopResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(ce7e4202f09e314a)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Stopable::StopParams {
  StopParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(98a27c9476315729, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Stopable::StopResults {
  StopResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d3a3b24aaa056a5c, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

template <typename F = ::capnp::AnyPointer, typename S = ::capnp::AnyPointer>
struct Pair {
  Pair() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b9d4864725174733, 0, 2)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, F, S>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename H = ::capnp::AnyPointer, typename T = ::capnp::AnyPointer>
struct LL {
  LL() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d67792aa3fc241be, 0, 2)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, H, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class IdInformation::Reader {
public:
  typedef IdInformation Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasId() const;
  inline  ::capnp::Text::Reader getId() const;

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasDescription() const;
  inline  ::capnp::Text::Reader getDescription() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IdInformation::Builder {
public:
  typedef IdInformation Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasId();
  inline  ::capnp::Text::Builder getId();
  inline void setId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initId(unsigned int size);
  inline void adoptId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownId();

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasDescription();
  inline  ::capnp::Text::Builder getDescription();
  inline void setDescription( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initDescription(unsigned int size);
  inline void adoptDescription(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownDescription();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IdInformation::Pipeline {
public:
  typedef IdInformation Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Identifiable::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Identifiable Calls;
  typedef Identifiable Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::common::Identifiable::InfoParams,  ::mas::schema::common::IdInformation> infoRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Identifiable::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Identifiable Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::common::Identifiable::InfoParams InfoParams;
  typedef ::capnp::CallContext<InfoParams,  ::mas::schema::common::IdInformation> InfoContext;
  virtual ::kj::Promise<void> info(InfoContext context);

  inline  ::mas::schema::common::Identifiable::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::common::Identifiable>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Identifiable::InfoParams::Reader {
public:
  typedef InfoParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Identifiable::InfoParams::Builder {
public:
  typedef InfoParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Identifiable::InfoParams::Pipeline {
public:
  typedef InfoParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class StructuredText::Reader {
public:
  typedef StructuredText Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasValue() const;
  inline  ::capnp::Text::Reader getValue() const;

  inline typename Structure::Reader getStructure() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class StructuredText::Builder {
public:
  typedef StructuredText Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasValue();
  inline  ::capnp::Text::Builder getValue();
  inline void setValue( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initValue(unsigned int size);
  inline void adoptValue(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownValue();

  inline typename Structure::Builder getStructure();
  inline typename Structure::Builder initStructure();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class StructuredText::Pipeline {
public:
  typedef StructuredText Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename Structure::Pipeline getStructure();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class StructuredText::Structure::Reader {
public:
  typedef Structure Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isNone() const;
  inline  ::capnp::Void getNone() const;

  inline bool isJson() const;
  inline  ::capnp::Void getJson() const;

  inline bool isXml() const;
  inline  ::capnp::Void getXml() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class StructuredText::Structure::Builder {
public:
  typedef Structure Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isNone();
  inline  ::capnp::Void getNone();
  inline void setNone( ::capnp::Void value = ::capnp::VOID);

  inline bool isJson();
  inline  ::capnp::Void getJson();
  inline void setJson( ::capnp::Void value = ::capnp::VOID);

  inline bool isXml();
  inline  ::capnp::Void getXml();
  inline void setXml( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class StructuredText::Structure::Pipeline {
public:
  typedef Structure Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Callback::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Callback Calls;
  typedef Callback Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::common::Callback::CallParams,  ::mas::schema::common::Callback::CallResults> callRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Callback::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Callback Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::common::Callback::CallParams CallParams;
  typedef  ::mas::schema::common::Callback::CallResults CallResults;
  typedef ::capnp::CallContext<CallParams, CallResults> CallContext;
  virtual ::kj::Promise<void> call(CallContext context);

  inline  ::mas::schema::common::Callback::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::common::Callback>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Callback::CallParams::Reader {
public:
  typedef CallParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Callback::CallParams::Builder {
public:
  typedef CallParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Callback::CallParams::Pipeline {
public:
  typedef CallParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Callback::CallResults::Reader {
public:
  typedef CallResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Callback::CallResults::Builder {
public:
  typedef CallResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Callback::CallResults::Pipeline {
public:
  typedef CallResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Action::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::persistence::Persistent::Client {
public:
  typedef Action Calls;
  typedef Action Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::common::Action::DoParams,  ::mas::schema::common::Action::DoResults> doRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Action::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::persistence::Persistent::Server {
public:
  typedef Action Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::common::Action::DoParams DoParams;
  typedef  ::mas::schema::common::Action::DoResults DoResults;
  typedef ::capnp::CallContext<DoParams, DoResults> DoContext;
  virtual ::kj::Promise<void> do_(DoContext context);

  inline  ::mas::schema::common::Action::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::common::Action>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Action::DoParams::Reader {
public:
  typedef DoParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Action::DoParams::Builder {
public:
  typedef DoParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Action::DoParams::Pipeline {
public:
  typedef DoParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Action::DoResults::Reader {
public:
  typedef DoResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Action::DoResults::Builder {
public:
  typedef DoResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Action::DoResults::Pipeline {
public:
  typedef DoResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Action1::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::persistence::Persistent::Client {
public:
  typedef Action1 Calls;
  typedef Action1 Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::common::Action1::DoParams,  ::mas::schema::common::Action1::DoResults> doRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Action1::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::persistence::Persistent::Server {
public:
  typedef Action1 Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::common::Action1::DoParams DoParams;
  typedef  ::mas::schema::common::Action1::DoResults DoResults;
  typedef ::capnp::CallContext<DoParams, DoResults> DoContext;
  virtual ::kj::Promise<void> do_(DoContext context);

  inline  ::mas::schema::common::Action1::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::common::Action1>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Action1::DoParams::Reader {
public:
  typedef DoParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasP() const;
  inline ::capnp::AnyPointer::Reader getP() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Action1::DoParams::Builder {
public:
  typedef DoParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasP();
  inline ::capnp::AnyPointer::Builder getP();
  inline ::capnp::AnyPointer::Builder initP();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Action1::DoParams::Pipeline {
public:
  typedef DoParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Action1::DoResults::Reader {
public:
  typedef DoResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Action1::DoResults::Builder {
public:
  typedef DoResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Action1::DoResults::Pipeline {
public:
  typedef DoResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename Input, typename Output>
class Factory<Input, Output>::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Factory Calls;
  typedef Factory Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename Input2 = ::capnp::AnyPointer, typename Output2 = ::capnp::AnyPointer>
  typename Factory<Input2, Output2>::Client asGeneric() {
    return castAs<Factory<Input2, Output2>>();
  }

  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::Factory<Input, Output>::ProduceParams, typename  ::mas::schema::common::Factory<Input, Output>::ProduceResults>) produceRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

template <typename Input, typename Output>
class Factory<Input, Output>::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Factory Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef typename  ::mas::schema::common::Factory<Input, Output>::ProduceParams ProduceParams;
  typedef typename  ::mas::schema::common::Factory<Input, Output>::ProduceResults ProduceResults;
  typedef ::capnp::CallContext<ProduceParams, ProduceResults> ProduceContext;
  virtual ::kj::Promise<void> produce(ProduceContext context);

  inline typename  ::mas::schema::common::Factory<Input, Output>::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::common::Factory<Input, Output>>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename Input, typename Output>
class Factory<Input, Output>::ProduceParams::Reader {
public:
  typedef ProduceParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Input2 = ::capnp::AnyPointer, typename Output2 = ::capnp::AnyPointer>
  typename Factory<Input2, Output2>::ProduceParams::Reader asFactoryGeneric() {
    return typename Factory<Input2, Output2>::ProduceParams::Reader(_reader);
  }

  inline bool hasIn() const;
  inline  ::capnp::ReaderFor<Input> getIn() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Input, typename Output>
class Factory<Input, Output>::ProduceParams::Builder {
public:
  typedef ProduceParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Input2 = ::capnp::AnyPointer, typename Output2 = ::capnp::AnyPointer>
  typename Factory<Input2, Output2>::ProduceParams::Builder asFactoryGeneric() {
    return typename Factory<Input2, Output2>::ProduceParams::Builder(_builder);
  }

  inline bool hasIn();
  inline  ::capnp::BuilderFor<Input> getIn();
  inline void setIn( ::capnp::ReaderFor<Input> value);
  inline  ::capnp::BuilderFor<Input> initIn();
  inline  ::capnp::BuilderFor<Input> initIn(unsigned int size);
  inline void adoptIn(::capnp::Orphan<Input>&& value);
  inline ::capnp::Orphan<Input> disownIn();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Input, typename Output>
class Factory<Input, Output>::ProduceParams::Pipeline {
public:
  typedef ProduceParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<Input> getIn();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Input, typename Output>
class Factory<Input, Output>::ProduceResults::Reader {
public:
  typedef ProduceResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Input2 = ::capnp::AnyPointer, typename Output2 = ::capnp::AnyPointer>
  typename Factory<Input2, Output2>::ProduceResults::Reader asFactoryGeneric() {
    return typename Factory<Input2, Output2>::ProduceResults::Reader(_reader);
  }

  inline bool hasOut() const;
  inline  ::capnp::ReaderFor<Output> getOut() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Input, typename Output>
class Factory<Input, Output>::ProduceResults::Builder {
public:
  typedef ProduceResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Input2 = ::capnp::AnyPointer, typename Output2 = ::capnp::AnyPointer>
  typename Factory<Input2, Output2>::ProduceResults::Builder asFactoryGeneric() {
    return typename Factory<Input2, Output2>::ProduceResults::Builder(_builder);
  }

  inline bool hasOut();
  inline  ::capnp::BuilderFor<Output> getOut();
  inline void setOut( ::capnp::ReaderFor<Output> value);
  inline  ::capnp::BuilderFor<Output> initOut();
  inline  ::capnp::BuilderFor<Output> initOut(unsigned int size);
  inline void adoptOut(::capnp::Orphan<Output>&& value);
  inline ::capnp::Orphan<Output> disownOut();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Input, typename Output>
class Factory<Input, Output>::ProduceResults::Pipeline {
public:
  typedef ProduceResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<Output> getOut();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ZmqPipelineAddresses::Reader {
public:
  typedef ZmqPipelineAddresses Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasInput() const;
  inline  ::capnp::Text::Reader getInput() const;

  inline bool hasOutput() const;
  inline  ::capnp::Text::Reader getOutput() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ZmqPipelineAddresses::Builder {
public:
  typedef ZmqPipelineAddresses Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasInput();
  inline  ::capnp::Text::Builder getInput();
  inline void setInput( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initInput(unsigned int size);
  inline void adoptInput(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownInput();

  inline bool hasOutput();
  inline  ::capnp::Text::Builder getOutput();
  inline void setOutput( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initOutput(unsigned int size);
  inline void adoptOutput(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownOutput();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ZmqPipelineAddresses::Pipeline {
public:
  typedef ZmqPipelineAddresses Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename Object>
class CapHolder<Object>::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef CapHolder Calls;
  typedef CapHolder Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename Object2 = ::capnp::AnyPointer>
  typename CapHolder<Object2>::Client asGeneric() {
    return castAs<CapHolder<Object2>>();
  }

  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::CapHolder<Object>::CapParams, typename  ::mas::schema::common::CapHolder<Object>::CapResults>) capRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::CapHolder<Object>::ReleaseParams, typename  ::mas::schema::common::CapHolder<Object>::ReleaseResults>) releaseRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

template <typename Object>
class CapHolder<Object>::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef CapHolder Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef typename  ::mas::schema::common::CapHolder<Object>::CapParams CapParams;
  typedef typename  ::mas::schema::common::CapHolder<Object>::CapResults CapResults;
  typedef ::capnp::CallContext<CapParams, CapResults> CapContext;
  virtual ::kj::Promise<void> cap(CapContext context);
  typedef typename  ::mas::schema::common::CapHolder<Object>::ReleaseParams ReleaseParams;
  typedef typename  ::mas::schema::common::CapHolder<Object>::ReleaseResults ReleaseResults;
  typedef ::capnp::CallContext<ReleaseParams, ReleaseResults> ReleaseContext;
  virtual ::kj::Promise<void> release(ReleaseContext context);

  inline typename  ::mas::schema::common::CapHolder<Object>::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::common::CapHolder<Object>>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename Object>
class CapHolder<Object>::CapParams::Reader {
public:
  typedef CapParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Object2 = ::capnp::AnyPointer>
  typename CapHolder<Object2>::CapParams::Reader asCapHolderGeneric() {
    return typename CapHolder<Object2>::CapParams::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Object>
class CapHolder<Object>::CapParams::Builder {
public:
  typedef CapParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Object2 = ::capnp::AnyPointer>
  typename CapHolder<Object2>::CapParams::Builder asCapHolderGeneric() {
    return typename CapHolder<Object2>::CapParams::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Object>
class CapHolder<Object>::CapParams::Pipeline {
public:
  typedef CapParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Object>
class CapHolder<Object>::CapResults::Reader {
public:
  typedef CapResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Object2 = ::capnp::AnyPointer>
  typename CapHolder<Object2>::CapResults::Reader asCapHolderGeneric() {
    return typename CapHolder<Object2>::CapResults::Reader(_reader);
  }

  inline bool hasObject() const;
  inline  ::capnp::ReaderFor<Object> getObject() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Object>
class CapHolder<Object>::CapResults::Builder {
public:
  typedef CapResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Object2 = ::capnp::AnyPointer>
  typename CapHolder<Object2>::CapResults::Builder asCapHolderGeneric() {
    return typename CapHolder<Object2>::CapResults::Builder(_builder);
  }

  inline bool hasObject();
  inline  ::capnp::BuilderFor<Object> getObject();
  inline void setObject( ::capnp::ReaderFor<Object> value);
  inline  ::capnp::BuilderFor<Object> initObject();
  inline  ::capnp::BuilderFor<Object> initObject(unsigned int size);
  inline void adoptObject(::capnp::Orphan<Object>&& value);
  inline ::capnp::Orphan<Object> disownObject();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Object>
class CapHolder<Object>::CapResults::Pipeline {
public:
  typedef CapResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<Object> getObject();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Object>
class CapHolder<Object>::ReleaseParams::Reader {
public:
  typedef ReleaseParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Object2 = ::capnp::AnyPointer>
  typename CapHolder<Object2>::ReleaseParams::Reader asCapHolderGeneric() {
    return typename CapHolder<Object2>::ReleaseParams::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Object>
class CapHolder<Object>::ReleaseParams::Builder {
public:
  typedef ReleaseParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Object2 = ::capnp::AnyPointer>
  typename CapHolder<Object2>::ReleaseParams::Builder asCapHolderGeneric() {
    return typename CapHolder<Object2>::ReleaseParams::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Object>
class CapHolder<Object>::ReleaseParams::Pipeline {
public:
  typedef ReleaseParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Object>
class CapHolder<Object>::ReleaseResults::Reader {
public:
  typedef ReleaseResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Object2 = ::capnp::AnyPointer>
  typename CapHolder<Object2>::ReleaseResults::Reader asCapHolderGeneric() {
    return typename CapHolder<Object2>::ReleaseResults::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Object>
class CapHolder<Object>::ReleaseResults::Builder {
public:
  typedef ReleaseResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Object2 = ::capnp::AnyPointer>
  typename CapHolder<Object2>::ReleaseResults::Builder asCapHolderGeneric() {
    return typename CapHolder<Object2>::ReleaseResults::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Object>
class CapHolder<Object>::ReleaseResults::Pipeline {
public:
  typedef ReleaseResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class IdentifiableHolder::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client {
public:
  typedef IdentifiableHolder Calls;
  typedef IdentifiableHolder Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::common::IdentifiableHolder::CapParams,  ::mas::schema::common::IdentifiableHolder::CapResults> capRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::common::IdentifiableHolder::ReleaseParams,  ::mas::schema::common::IdentifiableHolder::ReleaseResults> releaseRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class IdentifiableHolder::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server {
public:
  typedef IdentifiableHolder Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::common::IdentifiableHolder::CapParams CapParams;
  typedef  ::mas::schema::common::IdentifiableHolder::CapResults CapResults;
  typedef ::capnp::CallContext<CapParams, CapResults> CapContext;
  virtual ::kj::Promise<void> cap(CapContext context);
  typedef  ::mas::schema::common::IdentifiableHolder::ReleaseParams ReleaseParams;
  typedef  ::mas::schema::common::IdentifiableHolder::ReleaseResults ReleaseResults;
  typedef ::capnp::CallContext<ReleaseParams, ReleaseResults> ReleaseContext;
  virtual ::kj::Promise<void> release(ReleaseContext context);

  inline  ::mas::schema::common::IdentifiableHolder::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::common::IdentifiableHolder>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class IdentifiableHolder::CapParams::Reader {
public:
  typedef CapParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IdentifiableHolder::CapParams::Builder {
public:
  typedef CapParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IdentifiableHolder::CapParams::Pipeline {
public:
  typedef CapParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IdentifiableHolder::CapResults::Reader {
public:
  typedef CapResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCap() const;
#if !CAPNP_LITE
  inline  ::mas::schema::common::Identifiable::Client getCap() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IdentifiableHolder::CapResults::Builder {
public:
  typedef CapResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCap();
#if !CAPNP_LITE
  inline  ::mas::schema::common::Identifiable::Client getCap();
  inline void setCap( ::mas::schema::common::Identifiable::Client&& value);
  inline void setCap( ::mas::schema::common::Identifiable::Client& value);
  inline void adoptCap(::capnp::Orphan< ::mas::schema::common::Identifiable>&& value);
  inline ::capnp::Orphan< ::mas::schema::common::Identifiable> disownCap();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IdentifiableHolder::CapResults::Pipeline {
public:
  typedef CapResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::common::Identifiable::Client getCap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IdentifiableHolder::ReleaseParams::Reader {
public:
  typedef ReleaseParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IdentifiableHolder::ReleaseParams::Builder {
public:
  typedef ReleaseParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IdentifiableHolder::ReleaseParams::Pipeline {
public:
  typedef ReleaseParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IdentifiableHolder::ReleaseResults::Reader {
public:
  typedef ReleaseResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IdentifiableHolder::ReleaseResults::Builder {
public:
  typedef ReleaseResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IdentifiableHolder::ReleaseResults::Pipeline {
public:
  typedef ReleaseResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename PointerType>
class ListEntry<PointerType>::Reader {
public:
  typedef ListEntry Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename PointerType2 = ::capnp::AnyPointer>
  typename ListEntry<PointerType2>::Reader asGeneric() {
    return typename ListEntry<PointerType2>::Reader(_reader);
  }

  inline bool hasEntry() const;
  inline  ::capnp::ReaderFor<PointerType> getEntry() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename PointerType>
class ListEntry<PointerType>::Builder {
public:
  typedef ListEntry Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename PointerType2 = ::capnp::AnyPointer>
  typename ListEntry<PointerType2>::Builder asGeneric() {
    return typename ListEntry<PointerType2>::Builder(_builder);
  }

  inline bool hasEntry();
  inline  ::capnp::BuilderFor<PointerType> getEntry();
  inline void setEntry( ::capnp::ReaderFor<PointerType> value);
  inline  ::capnp::BuilderFor<PointerType> initEntry();
  inline  ::capnp::BuilderFor<PointerType> initEntry(unsigned int size);
  inline void adoptEntry(::capnp::Orphan<PointerType>&& value);
  inline ::capnp::Orphan<PointerType> disownEntry();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename PointerType>
class ListEntry<PointerType>::Pipeline {
public:
  typedef ListEntry Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<PointerType> getEntry();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Stopable::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Stopable Calls;
  typedef Stopable Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::common::Stopable::StopParams,  ::mas::schema::common::Stopable::StopResults> stopRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Stopable::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Stopable Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::common::Stopable::StopParams StopParams;
  typedef  ::mas::schema::common::Stopable::StopResults StopResults;
  typedef ::capnp::CallContext<StopParams, StopResults> StopContext;
  virtual ::kj::Promise<void> stop(StopContext context);

  inline  ::mas::schema::common::Stopable::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::common::Stopable>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Stopable::StopParams::Reader {
public:
  typedef StopParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Stopable::StopParams::Builder {
public:
  typedef StopParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Stopable::StopParams::Pipeline {
public:
  typedef StopParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Stopable::StopResults::Reader {
public:
  typedef StopResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Stopable::StopResults::Builder {
public:
  typedef StopResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Stopable::StopResults::Pipeline {
public:
  typedef StopResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename F, typename S>
class Pair<F, S>::Reader {
public:
  typedef Pair Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename F2 = ::capnp::AnyPointer, typename S2 = ::capnp::AnyPointer>
  typename Pair<F2, S2>::Reader asGeneric() {
    return typename Pair<F2, S2>::Reader(_reader);
  }

  inline bool hasFst() const;
  inline  ::capnp::ReaderFor<F> getFst() const;

  inline bool hasSnd() const;
  inline  ::capnp::ReaderFor<S> getSnd() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename F, typename S>
class Pair<F, S>::Builder {
public:
  typedef Pair Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename F2 = ::capnp::AnyPointer, typename S2 = ::capnp::AnyPointer>
  typename Pair<F2, S2>::Builder asGeneric() {
    return typename Pair<F2, S2>::Builder(_builder);
  }

  inline bool hasFst();
  inline  ::capnp::BuilderFor<F> getFst();
  inline void setFst( ::capnp::ReaderFor<F> value);
  inline  ::capnp::BuilderFor<F> initFst();
  inline  ::capnp::BuilderFor<F> initFst(unsigned int size);
  inline void adoptFst(::capnp::Orphan<F>&& value);
  inline ::capnp::Orphan<F> disownFst();

  inline bool hasSnd();
  inline  ::capnp::BuilderFor<S> getSnd();
  inline void setSnd( ::capnp::ReaderFor<S> value);
  inline  ::capnp::BuilderFor<S> initSnd();
  inline  ::capnp::BuilderFor<S> initSnd(unsigned int size);
  inline void adoptSnd(::capnp::Orphan<S>&& value);
  inline ::capnp::Orphan<S> disownSnd();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename F, typename S>
class Pair<F, S>::Pipeline {
public:
  typedef Pair Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<F> getFst();
  inline  ::capnp::PipelineFor<S> getSnd();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename H, typename T>
class LL<H, T>::Reader {
public:
  typedef LL Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename H2 = ::capnp::AnyPointer, typename T2 = ::capnp::AnyPointer>
  typename LL<H2, T2>::Reader asGeneric() {
    return typename LL<H2, T2>::Reader(_reader);
  }

  inline bool hasHead() const;
  inline  ::capnp::ReaderFor<H> getHead() const;

  inline bool hasTail() const;
  inline  ::capnp::ReaderFor<T> getTail() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename H, typename T>
class LL<H, T>::Builder {
public:
  typedef LL Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename H2 = ::capnp::AnyPointer, typename T2 = ::capnp::AnyPointer>
  typename LL<H2, T2>::Builder asGeneric() {
    return typename LL<H2, T2>::Builder(_builder);
  }

  inline bool hasHead();
  inline  ::capnp::BuilderFor<H> getHead();
  inline void setHead( ::capnp::ReaderFor<H> value);
  inline  ::capnp::BuilderFor<H> initHead();
  inline  ::capnp::BuilderFor<H> initHead(unsigned int size);
  inline void adoptHead(::capnp::Orphan<H>&& value);
  inline ::capnp::Orphan<H> disownHead();

  inline bool hasTail();
  inline  ::capnp::BuilderFor<T> getTail();
  inline void setTail( ::capnp::ReaderFor<T> value);
  inline  ::capnp::BuilderFor<T> initTail();
  inline  ::capnp::BuilderFor<T> initTail(unsigned int size);
  inline void adoptTail(::capnp::Orphan<T>&& value);
  inline ::capnp::Orphan<T> disownTail();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename H, typename T>
class LL<H, T>::Pipeline {
public:
  typedef LL Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<H> getHead();
  inline  ::capnp::PipelineFor<T> getTail();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline bool IdInformation::Reader::hasId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool IdInformation::Builder::hasId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader IdInformation::Reader::getId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder IdInformation::Builder::getId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void IdInformation::Builder::setId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder IdInformation::Builder::initId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void IdInformation::Builder::adoptId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> IdInformation::Builder::disownId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool IdInformation::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool IdInformation::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader IdInformation::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder IdInformation::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void IdInformation::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder IdInformation::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void IdInformation::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> IdInformation::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool IdInformation::Reader::hasDescription() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool IdInformation::Builder::hasDescription() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader IdInformation::Reader::getDescription() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder IdInformation::Builder::getDescription() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void IdInformation::Builder::setDescription( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder IdInformation::Builder::initDescription(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void IdInformation::Builder::adoptDescription(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> IdInformation::Builder::disownDescription() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline Identifiable::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Identifiable::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Identifiable::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Identifiable::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Identifiable::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::common::Identifiable::Client& Identifiable::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::common::Identifiable::Client& Identifiable::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool StructuredText::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool StructuredText::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader StructuredText::Reader::getValue() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder StructuredText::Builder::getValue() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void StructuredText::Builder::setValue( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder StructuredText::Builder::initValue(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void StructuredText::Builder::adoptValue(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> StructuredText::Builder::disownValue() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline typename StructuredText::Structure::Reader StructuredText::Reader::getStructure() const {
  return typename StructuredText::Structure::Reader(_reader);
}
inline typename StructuredText::Structure::Builder StructuredText::Builder::getStructure() {
  return typename StructuredText::Structure::Builder(_builder);
}
#if !CAPNP_LITE
inline typename StructuredText::Structure::Pipeline StructuredText::Pipeline::getStructure() {
  return typename StructuredText::Structure::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename StructuredText::Structure::Builder StructuredText::Builder::initStructure() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  return typename StructuredText::Structure::Builder(_builder);
}
inline  ::mas::schema::common::StructuredText::Structure::Which StructuredText::Structure::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::mas::schema::common::StructuredText::Structure::Which StructuredText::Structure::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool StructuredText::Structure::Reader::isNone() const {
  return which() == StructuredText::Structure::NONE;
}
inline bool StructuredText::Structure::Builder::isNone() {
  return which() == StructuredText::Structure::NONE;
}
inline  ::capnp::Void StructuredText::Structure::Reader::getNone() const {
  KJ_IREQUIRE((which() == StructuredText::Structure::NONE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void StructuredText::Structure::Builder::getNone() {
  KJ_IREQUIRE((which() == StructuredText::Structure::NONE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void StructuredText::Structure::Builder::setNone( ::capnp::Void value) {
  _builder.setDataField<StructuredText::Structure::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, StructuredText::Structure::NONE);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool StructuredText::Structure::Reader::isJson() const {
  return which() == StructuredText::Structure::JSON;
}
inline bool StructuredText::Structure::Builder::isJson() {
  return which() == StructuredText::Structure::JSON;
}
inline  ::capnp::Void StructuredText::Structure::Reader::getJson() const {
  KJ_IREQUIRE((which() == StructuredText::Structure::JSON),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void StructuredText::Structure::Builder::getJson() {
  KJ_IREQUIRE((which() == StructuredText::Structure::JSON),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void StructuredText::Structure::Builder::setJson( ::capnp::Void value) {
  _builder.setDataField<StructuredText::Structure::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, StructuredText::Structure::JSON);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool StructuredText::Structure::Reader::isXml() const {
  return which() == StructuredText::Structure::XML;
}
inline bool StructuredText::Structure::Builder::isXml() {
  return which() == StructuredText::Structure::XML;
}
inline  ::capnp::Void StructuredText::Structure::Reader::getXml() const {
  KJ_IREQUIRE((which() == StructuredText::Structure::XML),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void StructuredText::Structure::Builder::getXml() {
  KJ_IREQUIRE((which() == StructuredText::Structure::XML),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void StructuredText::Structure::Builder::setXml( ::capnp::Void value) {
  _builder.setDataField<StructuredText::Structure::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, StructuredText::Structure::XML);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

#if !CAPNP_LITE
inline Callback::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Callback::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Callback::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Callback::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Callback::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::common::Callback::Client& Callback::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::common::Callback::Client& Callback::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
#if !CAPNP_LITE
inline Action::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Action::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Action::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Action::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Action::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::common::Action::Client& Action::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::common::Action::Client& Action::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
#if !CAPNP_LITE
inline Action1::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Action1::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Action1::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Action1::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Action1::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::common::Action1::Client& Action1::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::common::Action1::Client& Action1::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Action1::DoParams::Reader::hasP() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Action1::DoParams::Builder::hasP() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline ::capnp::AnyPointer::Reader Action1::DoParams::Reader::getP() const {
  return ::capnp::AnyPointer::Reader(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder Action1::DoParams::Builder::getP() {
  return ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder Action1::DoParams::Builder::initP() {
  auto result = ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
  result.clear();
  return result;
}

#if !CAPNP_LITE
template <typename Input, typename Output>
inline Factory<Input, Output>::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
template <typename Input, typename Output>
inline Factory<Input, Output>::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename Input, typename Output>
template <typename _t, typename>
inline Factory<Input, Output>::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename Input, typename Output>
template <typename _t, typename>
inline Factory<Input, Output>::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
template <typename Input, typename Output>
inline Factory<Input, Output>::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
template <typename Input, typename Output>
inline typename  ::mas::schema::common::Factory<Input, Output>::Client& Factory<Input, Output>::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
template <typename Input, typename Output>
inline typename  ::mas::schema::common::Factory<Input, Output>::Client& Factory<Input, Output>::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
template <typename Input, typename Output>
inline bool Factory<Input, Output>::ProduceParams::Reader::hasIn() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Input, typename Output>
inline bool Factory<Input, Output>::ProduceParams::Builder::hasIn() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Input, typename Output>
inline  ::capnp::ReaderFor<Input> Factory<Input, Output>::ProduceParams::Reader::getIn() const {
  return ::capnp::_::PointerHelpers<Input>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Input, typename Output>
inline  ::capnp::BuilderFor<Input> Factory<Input, Output>::ProduceParams::Builder::getIn() {
  return ::capnp::_::PointerHelpers<Input>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Input, typename Output>
inline  ::capnp::PipelineFor<Input> Factory<Input, Output>::ProduceParams::Pipeline::getIn() {
  return  ::capnp::PipelineFor<Input>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename Input, typename Output>
inline void Factory<Input, Output>::ProduceParams::Builder::setIn( ::capnp::ReaderFor<Input> value) {
  ::capnp::_::PointerHelpers<Input>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Input, typename Output>
inline  ::capnp::BuilderFor<Input> Factory<Input, Output>::ProduceParams::Builder::initIn() {
  return ::capnp::_::PointerHelpers<Input>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Input, typename Output>
inline  ::capnp::BuilderFor<Input> Factory<Input, Output>::ProduceParams::Builder::initIn(unsigned int size) {
  return ::capnp::_::PointerHelpers<Input>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Input, typename Output>
inline void Factory<Input, Output>::ProduceParams::Builder::adoptIn(
    ::capnp::Orphan<Input>&& value) {
  ::capnp::_::PointerHelpers<Input>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Input, typename Output>
inline ::capnp::Orphan<Input> Factory<Input, Output>::ProduceParams::Builder::disownIn() {
  return ::capnp::_::PointerHelpers<Input>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// Factory<Input, Output>::ProduceParams
template <typename Input, typename Output>
constexpr uint16_t Factory<Input, Output>::ProduceParams::_capnpPrivate::dataWordSize;
template <typename Input, typename Output>
constexpr uint16_t Factory<Input, Output>::ProduceParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Input, typename Output>
constexpr ::capnp::Kind Factory<Input, Output>::ProduceParams::_capnpPrivate::kind;
template <typename Input, typename Output>
constexpr ::capnp::_::RawSchema const* Factory<Input, Output>::ProduceParams::_capnpPrivate::schema;
template <typename Input, typename Output>
const ::capnp::_::RawBrandedSchema::Scope Factory<Input, Output>::ProduceParams::_capnpPrivate::brandScopes[] = {
  { 0xa869f50b8c586ed9, brandBindings + 0, 2, false},
};
template <typename Input, typename Output>
const ::capnp::_::RawBrandedSchema::Binding Factory<Input, Output>::ProduceParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Input>(),
  ::capnp::_::brandBindingFor<Output>(),
};
template <typename Input, typename Output>
const ::capnp::_::RawBrandedSchema Factory<Input, Output>::ProduceParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_fd058bbd1f9508cd, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename Input, typename Output>
inline bool Factory<Input, Output>::ProduceResults::Reader::hasOut() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Input, typename Output>
inline bool Factory<Input, Output>::ProduceResults::Builder::hasOut() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Input, typename Output>
inline  ::capnp::ReaderFor<Output> Factory<Input, Output>::ProduceResults::Reader::getOut() const {
  return ::capnp::_::PointerHelpers<Output>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Input, typename Output>
inline  ::capnp::BuilderFor<Output> Factory<Input, Output>::ProduceResults::Builder::getOut() {
  return ::capnp::_::PointerHelpers<Output>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Input, typename Output>
inline  ::capnp::PipelineFor<Output> Factory<Input, Output>::ProduceResults::Pipeline::getOut() {
  return  ::capnp::PipelineFor<Output>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename Input, typename Output>
inline void Factory<Input, Output>::ProduceResults::Builder::setOut( ::capnp::ReaderFor<Output> value) {
  ::capnp::_::PointerHelpers<Output>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Input, typename Output>
inline  ::capnp::BuilderFor<Output> Factory<Input, Output>::ProduceResults::Builder::initOut() {
  return ::capnp::_::PointerHelpers<Output>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Input, typename Output>
inline  ::capnp::BuilderFor<Output> Factory<Input, Output>::ProduceResults::Builder::initOut(unsigned int size) {
  return ::capnp::_::PointerHelpers<Output>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Input, typename Output>
inline void Factory<Input, Output>::ProduceResults::Builder::adoptOut(
    ::capnp::Orphan<Output>&& value) {
  ::capnp::_::PointerHelpers<Output>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Input, typename Output>
inline ::capnp::Orphan<Output> Factory<Input, Output>::ProduceResults::Builder::disownOut() {
  return ::capnp::_::PointerHelpers<Output>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// Factory<Input, Output>::ProduceResults
template <typename Input, typename Output>
constexpr uint16_t Factory<Input, Output>::ProduceResults::_capnpPrivate::dataWordSize;
template <typename Input, typename Output>
constexpr uint16_t Factory<Input, Output>::ProduceResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Input, typename Output>
constexpr ::capnp::Kind Factory<Input, Output>::ProduceResults::_capnpPrivate::kind;
template <typename Input, typename Output>
constexpr ::capnp::_::RawSchema const* Factory<Input, Output>::ProduceResults::_capnpPrivate::schema;
template <typename Input, typename Output>
const ::capnp::_::RawBrandedSchema::Scope Factory<Input, Output>::ProduceResults::_capnpPrivate::brandScopes[] = {
  { 0xa869f50b8c586ed9, brandBindings + 0, 2, false},
};
template <typename Input, typename Output>
const ::capnp::_::RawBrandedSchema::Binding Factory<Input, Output>::ProduceResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Input>(),
  ::capnp::_::brandBindingFor<Output>(),
};
template <typename Input, typename Output>
const ::capnp::_::RawBrandedSchema Factory<Input, Output>::ProduceResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_d010f77f1bdf0522, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename Input, typename Output>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::Factory<Input, Output>::ProduceParams, typename  ::mas::schema::common::Factory<Input, Output>::ProduceResults>)
Factory<Input, Output>::Client::produceRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::common::Factory<Input, Output>::ProduceParams, typename  ::mas::schema::common::Factory<Input, Output>::ProduceResults>(
      0xa869f50b8c586ed9ull, 0, sizeHint);
}
template <typename Input, typename Output>
::kj::Promise<void> Factory<Input, Output>::Server::produce(ProduceContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "common.capnp:Factory", "produce",
      0xa869f50b8c586ed9ull, 0);
}
template <typename Input, typename Output>
::capnp::Capability::Server::DispatchCallResult Factory<Input, Output>::Server::dispatchCall(
    uint64_t interfaceId, uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (interfaceId) {
    case 0xa869f50b8c586ed9ull:
      return dispatchCallInternal(methodId, context);
    default:
      return internalUnimplemented("common.capnp:Factory", interfaceId);
  }
}
template <typename Input, typename Output>
::capnp::Capability::Server::DispatchCallResult Factory<Input, Output>::Server::dispatchCallInternal(
    uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (methodId) {
    case 0:
      return {
        produce(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::common::Factory<Input, Output>::ProduceParams, typename  ::mas::schema::common::Factory<Input, Output>::ProduceResults>(context)),
        false
      };
    default:
      (void)context;
      return ::capnp::Capability::Server::internalUnimplemented(
          "common.capnp:Factory",
          0xa869f50b8c586ed9ull, methodId);
  }
}
#endif  // !CAPNP_LITE

// Factory<Input, Output>
#if !CAPNP_LITE
template <typename Input, typename Output>
constexpr ::capnp::Kind Factory<Input, Output>::_capnpPrivate::kind;
template <typename Input, typename Output>
constexpr ::capnp::_::RawSchema const* Factory<Input, Output>::_capnpPrivate::schema;
template <typename Input, typename Output>
const ::capnp::_::RawBrandedSchema::Scope Factory<Input, Output>::_capnpPrivate::brandScopes[] = {
  { 0xa869f50b8c586ed9, brandBindings + 0, 2, false},
};
template <typename Input, typename Output>
const ::capnp::_::RawBrandedSchema::Binding Factory<Input, Output>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Input>(),
  ::capnp::_::brandBindingFor<Output>(),
};
template <typename Input, typename Output>
const ::capnp::_::RawBrandedSchema::Dependency Factory<Input, Output>::_capnpPrivate::brandDependencies[] = {
  { 33554432,  ::mas::schema::common::Factory<Input, Output>::ProduceParams::_capnpPrivate::brand() },
  { 50331648,  ::mas::schema::common::Factory<Input, Output>::ProduceResults::_capnpPrivate::brand() },
};
template <typename Input, typename Output>
const ::capnp::_::RawBrandedSchema Factory<Input, Output>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_a869f50b8c586ed9, brandScopes, brandDependencies,
  1, 2, nullptr
};
#endif  // !CAPNP_LITE

inline bool ZmqPipelineAddresses::Reader::hasInput() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ZmqPipelineAddresses::Builder::hasInput() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader ZmqPipelineAddresses::Reader::getInput() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder ZmqPipelineAddresses::Builder::getInput() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ZmqPipelineAddresses::Builder::setInput( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder ZmqPipelineAddresses::Builder::initInput(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ZmqPipelineAddresses::Builder::adoptInput(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> ZmqPipelineAddresses::Builder::disownInput() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ZmqPipelineAddresses::Reader::hasOutput() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool ZmqPipelineAddresses::Builder::hasOutput() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader ZmqPipelineAddresses::Reader::getOutput() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder ZmqPipelineAddresses::Builder::getOutput() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void ZmqPipelineAddresses::Builder::setOutput( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder ZmqPipelineAddresses::Builder::initOutput(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void ZmqPipelineAddresses::Builder::adoptOutput(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> ZmqPipelineAddresses::Builder::disownOutput() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
template <typename Object>
inline CapHolder<Object>::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
template <typename Object>
inline CapHolder<Object>::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename Object>
template <typename _t, typename>
inline CapHolder<Object>::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename Object>
template <typename _t, typename>
inline CapHolder<Object>::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
template <typename Object>
inline CapHolder<Object>::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
template <typename Object>
inline typename  ::mas::schema::common::CapHolder<Object>::Client& CapHolder<Object>::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
template <typename Object>
inline typename  ::mas::schema::common::CapHolder<Object>::Client& CapHolder<Object>::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
// CapHolder<Object>::CapParams
template <typename Object>
constexpr uint16_t CapHolder<Object>::CapParams::_capnpPrivate::dataWordSize;
template <typename Object>
constexpr uint16_t CapHolder<Object>::CapParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Object>
constexpr ::capnp::Kind CapHolder<Object>::CapParams::_capnpPrivate::kind;
template <typename Object>
constexpr ::capnp::_::RawSchema const* CapHolder<Object>::CapParams::_capnpPrivate::schema;
template <typename Object>
const ::capnp::_::RawBrandedSchema::Scope CapHolder<Object>::CapParams::_capnpPrivate::brandScopes[] = {
  { 0xcac9c6537df1a097, brandBindings + 0, 1, false},
};
template <typename Object>
const ::capnp::_::RawBrandedSchema::Binding CapHolder<Object>::CapParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Object>(),
};
template <typename Object>
const ::capnp::_::RawBrandedSchema CapHolder<Object>::CapParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_da52b34d937fa814, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename Object>
inline bool CapHolder<Object>::CapResults::Reader::hasObject() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Object>
inline bool CapHolder<Object>::CapResults::Builder::hasObject() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Object>
inline  ::capnp::ReaderFor<Object> CapHolder<Object>::CapResults::Reader::getObject() const {
  return ::capnp::_::PointerHelpers<Object>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Object>
inline  ::capnp::BuilderFor<Object> CapHolder<Object>::CapResults::Builder::getObject() {
  return ::capnp::_::PointerHelpers<Object>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Object>
inline  ::capnp::PipelineFor<Object> CapHolder<Object>::CapResults::Pipeline::getObject() {
  return  ::capnp::PipelineFor<Object>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename Object>
inline void CapHolder<Object>::CapResults::Builder::setObject( ::capnp::ReaderFor<Object> value) {
  ::capnp::_::PointerHelpers<Object>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Object>
inline  ::capnp::BuilderFor<Object> CapHolder<Object>::CapResults::Builder::initObject() {
  return ::capnp::_::PointerHelpers<Object>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Object>
inline  ::capnp::BuilderFor<Object> CapHolder<Object>::CapResults::Builder::initObject(unsigned int size) {
  return ::capnp::_::PointerHelpers<Object>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Object>
inline void CapHolder<Object>::CapResults::Builder::adoptObject(
    ::capnp::Orphan<Object>&& value) {
  ::capnp::_::PointerHelpers<Object>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Object>
inline ::capnp::Orphan<Object> CapHolder<Object>::CapResults::Builder::disownObject() {
  return ::capnp::_::PointerHelpers<Object>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// CapHolder<Object>::CapResults
template <typename Object>
constexpr uint16_t CapHolder<Object>::CapResults::_capnpPrivate::dataWordSize;
template <typename Object>
constexpr uint16_t CapHolder<Object>::CapResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Object>
constexpr ::capnp::Kind CapHolder<Object>::CapResults::_capnpPrivate::kind;
template <typename Object>
constexpr ::capnp::_::RawSchema const* CapHolder<Object>::CapResults::_capnpPrivate::schema;
template <typename Object>
const ::capnp::_::RawBrandedSchema::Scope CapHolder<Object>::CapResults::_capnpPrivate::brandScopes[] = {
  { 0xcac9c6537df1a097, brandBindings + 0, 1, false},
};
template <typename Object>
const ::capnp::_::RawBrandedSchema::Binding CapHolder<Object>::CapResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Object>(),
};
template <typename Object>
const ::capnp::_::RawBrandedSchema CapHolder<Object>::CapResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_dc9b0f483595691f, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// CapHolder<Object>::ReleaseParams
template <typename Object>
constexpr uint16_t CapHolder<Object>::ReleaseParams::_capnpPrivate::dataWordSize;
template <typename Object>
constexpr uint16_t CapHolder<Object>::ReleaseParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Object>
constexpr ::capnp::Kind CapHolder<Object>::ReleaseParams::_capnpPrivate::kind;
template <typename Object>
constexpr ::capnp::_::RawSchema const* CapHolder<Object>::ReleaseParams::_capnpPrivate::schema;
template <typename Object>
const ::capnp::_::RawBrandedSchema::Scope CapHolder<Object>::ReleaseParams::_capnpPrivate::brandScopes[] = {
  { 0xcac9c6537df1a097, brandBindings + 0, 1, false},
};
template <typename Object>
const ::capnp::_::RawBrandedSchema::Binding CapHolder<Object>::ReleaseParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Object>(),
};
template <typename Object>
const ::capnp::_::RawBrandedSchema CapHolder<Object>::ReleaseParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_82449708d4fd120d, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// CapHolder<Object>::ReleaseResults
template <typename Object>
constexpr uint16_t CapHolder<Object>::ReleaseResults::_capnpPrivate::dataWordSize;
template <typename Object>
constexpr uint16_t CapHolder<Object>::ReleaseResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Object>
constexpr ::capnp::Kind CapHolder<Object>::ReleaseResults::_capnpPrivate::kind;
template <typename Object>
constexpr ::capnp::_::RawSchema const* CapHolder<Object>::ReleaseResults::_capnpPrivate::schema;
template <typename Object>
const ::capnp::_::RawBrandedSchema::Scope CapHolder<Object>::ReleaseResults::_capnpPrivate::brandScopes[] = {
  { 0xcac9c6537df1a097, brandBindings + 0, 1, false},
};
template <typename Object>
const ::capnp::_::RawBrandedSchema::Binding CapHolder<Object>::ReleaseResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Object>(),
};
template <typename Object>
const ::capnp::_::RawBrandedSchema CapHolder<Object>::ReleaseResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_c1374ccca01e2b53, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename Object>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::CapHolder<Object>::CapParams, typename  ::mas::schema::common::CapHolder<Object>::CapResults>)
CapHolder<Object>::Client::capRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::common::CapHolder<Object>::CapParams, typename  ::mas::schema::common::CapHolder<Object>::CapResults>(
      0xcac9c6537df1a097ull, 0, sizeHint);
}
template <typename Object>
::kj::Promise<void> CapHolder<Object>::Server::cap(CapContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "common.capnp:CapHolder", "cap",
      0xcac9c6537df1a097ull, 0);
}
template <typename Object>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::CapHolder<Object>::ReleaseParams, typename  ::mas::schema::common::CapHolder<Object>::ReleaseResults>)
CapHolder<Object>::Client::releaseRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::common::CapHolder<Object>::ReleaseParams, typename  ::mas::schema::common::CapHolder<Object>::ReleaseResults>(
      0xcac9c6537df1a097ull, 1, sizeHint);
}
template <typename Object>
::kj::Promise<void> CapHolder<Object>::Server::release(ReleaseContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "common.capnp:CapHolder", "release",
      0xcac9c6537df1a097ull, 1);
}
template <typename Object>
::capnp::Capability::Server::DispatchCallResult CapHolder<Object>::Server::dispatchCall(
    uint64_t interfaceId, uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (interfaceId) {
    case 0xcac9c6537df1a097ull:
      return dispatchCallInternal(methodId, context);
    default:
      return internalUnimplemented("common.capnp:CapHolder", interfaceId);
  }
}
template <typename Object>
::capnp::Capability::Server::DispatchCallResult CapHolder<Object>::Server::dispatchCallInternal(
    uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (methodId) {
    case 0:
      return {
        cap(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::common::CapHolder<Object>::CapParams, typename  ::mas::schema::common::CapHolder<Object>::CapResults>(context)),
        false
      };
    case 1:
      return {
        release(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::common::CapHolder<Object>::ReleaseParams, typename  ::mas::schema::common::CapHolder<Object>::ReleaseResults>(context)),
        false
      };
    default:
      (void)context;
      return ::capnp::Capability::Server::internalUnimplemented(
          "common.capnp:CapHolder",
          0xcac9c6537df1a097ull, methodId);
  }
}
#endif  // !CAPNP_LITE

// CapHolder<Object>
#if !CAPNP_LITE
template <typename Object>
constexpr ::capnp::Kind CapHolder<Object>::_capnpPrivate::kind;
template <typename Object>
constexpr ::capnp::_::RawSchema const* CapHolder<Object>::_capnpPrivate::schema;
template <typename Object>
const ::capnp::_::RawBrandedSchema::Scope CapHolder<Object>::_capnpPrivate::brandScopes[] = {
  { 0xcac9c6537df1a097, brandBindings + 0, 1, false},
};
template <typename Object>
const ::capnp::_::RawBrandedSchema::Binding CapHolder<Object>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Object>(),
};
template <typename Object>
const ::capnp::_::RawBrandedSchema::Dependency CapHolder<Object>::_capnpPrivate::brandDependencies[] = {
  { 33554432,  ::mas::schema::common::CapHolder<Object>::CapParams::_capnpPrivate::brand() },
  { 33554433,  ::mas::schema::common::CapHolder<Object>::ReleaseParams::_capnpPrivate::brand() },
  { 50331648,  ::mas::schema::common::CapHolder<Object>::CapResults::_capnpPrivate::brand() },
  { 50331649,  ::mas::schema::common::CapHolder<Object>::ReleaseResults::_capnpPrivate::brand() },
};
template <typename Object>
const ::capnp::_::RawBrandedSchema CapHolder<Object>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_cac9c6537df1a097, brandScopes, brandDependencies,
  1, 4, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
inline IdentifiableHolder::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline IdentifiableHolder::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline IdentifiableHolder::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline IdentifiableHolder::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline IdentifiableHolder::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::common::IdentifiableHolder::Client& IdentifiableHolder::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::common::IdentifiableHolder::Client& IdentifiableHolder::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool IdentifiableHolder::CapResults::Reader::hasCap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool IdentifiableHolder::CapResults::Builder::hasCap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::common::Identifiable::Client IdentifiableHolder::CapResults::Reader::getCap() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::Identifiable::Client IdentifiableHolder::CapResults::Builder::getCap() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::Identifiable::Client IdentifiableHolder::CapResults::Pipeline::getCap() {
  return  ::mas::schema::common::Identifiable::Client(_typeless.getPointerField(0).asCap());
}
inline void IdentifiableHolder::CapResults::Builder::setCap( ::mas::schema::common::Identifiable::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void IdentifiableHolder::CapResults::Builder::setCap( ::mas::schema::common::Identifiable::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void IdentifiableHolder::CapResults::Builder::adoptCap(
    ::capnp::Orphan< ::mas::schema::common::Identifiable>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::common::Identifiable> IdentifiableHolder::CapResults::Builder::disownCap() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

template <typename PointerType>
inline bool ListEntry<PointerType>::Reader::hasEntry() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename PointerType>
inline bool ListEntry<PointerType>::Builder::hasEntry() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename PointerType>
inline  ::capnp::ReaderFor<PointerType> ListEntry<PointerType>::Reader::getEntry() const {
  return ::capnp::_::PointerHelpers<PointerType>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename PointerType>
inline  ::capnp::BuilderFor<PointerType> ListEntry<PointerType>::Builder::getEntry() {
  return ::capnp::_::PointerHelpers<PointerType>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename PointerType>
inline  ::capnp::PipelineFor<PointerType> ListEntry<PointerType>::Pipeline::getEntry() {
  return  ::capnp::PipelineFor<PointerType>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename PointerType>
inline void ListEntry<PointerType>::Builder::setEntry( ::capnp::ReaderFor<PointerType> value) {
  ::capnp::_::PointerHelpers<PointerType>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename PointerType>
inline  ::capnp::BuilderFor<PointerType> ListEntry<PointerType>::Builder::initEntry() {
  return ::capnp::_::PointerHelpers<PointerType>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename PointerType>
inline  ::capnp::BuilderFor<PointerType> ListEntry<PointerType>::Builder::initEntry(unsigned int size) {
  return ::capnp::_::PointerHelpers<PointerType>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename PointerType>
inline void ListEntry<PointerType>::Builder::adoptEntry(
    ::capnp::Orphan<PointerType>&& value) {
  ::capnp::_::PointerHelpers<PointerType>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename PointerType>
inline ::capnp::Orphan<PointerType> ListEntry<PointerType>::Builder::disownEntry() {
  return ::capnp::_::PointerHelpers<PointerType>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// ListEntry<PointerType>
template <typename PointerType>
constexpr uint16_t ListEntry<PointerType>::_capnpPrivate::dataWordSize;
template <typename PointerType>
constexpr uint16_t ListEntry<PointerType>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename PointerType>
constexpr ::capnp::Kind ListEntry<PointerType>::_capnpPrivate::kind;
template <typename PointerType>
constexpr ::capnp::_::RawSchema const* ListEntry<PointerType>::_capnpPrivate::schema;
template <typename PointerType>
const ::capnp::_::RawBrandedSchema::Scope ListEntry<PointerType>::_capnpPrivate::brandScopes[] = {
  { 0xc201bf46dd40051e, brandBindings + 0, 1, false},
};
template <typename PointerType>
const ::capnp::_::RawBrandedSchema::Binding ListEntry<PointerType>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<PointerType>(),
};
template <typename PointerType>
const ::capnp::_::RawBrandedSchema ListEntry<PointerType>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_c201bf46dd40051e, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
inline Stopable::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Stopable::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Stopable::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Stopable::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Stopable::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::common::Stopable::Client& Stopable::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::common::Stopable::Client& Stopable::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
template <typename F, typename S>
inline bool Pair<F, S>::Reader::hasFst() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename F, typename S>
inline bool Pair<F, S>::Builder::hasFst() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename F, typename S>
inline  ::capnp::ReaderFor<F> Pair<F, S>::Reader::getFst() const {
  return ::capnp::_::PointerHelpers<F>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename F, typename S>
inline  ::capnp::BuilderFor<F> Pair<F, S>::Builder::getFst() {
  return ::capnp::_::PointerHelpers<F>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename F, typename S>
inline  ::capnp::PipelineFor<F> Pair<F, S>::Pipeline::getFst() {
  return  ::capnp::PipelineFor<F>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename F, typename S>
inline void Pair<F, S>::Builder::setFst( ::capnp::ReaderFor<F> value) {
  ::capnp::_::PointerHelpers<F>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename F, typename S>
inline  ::capnp::BuilderFor<F> Pair<F, S>::Builder::initFst() {
  return ::capnp::_::PointerHelpers<F>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename F, typename S>
inline  ::capnp::BuilderFor<F> Pair<F, S>::Builder::initFst(unsigned int size) {
  return ::capnp::_::PointerHelpers<F>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename F, typename S>
inline void Pair<F, S>::Builder::adoptFst(
    ::capnp::Orphan<F>&& value) {
  ::capnp::_::PointerHelpers<F>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename F, typename S>
inline ::capnp::Orphan<F> Pair<F, S>::Builder::disownFst() {
  return ::capnp::_::PointerHelpers<F>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename F, typename S>
inline bool Pair<F, S>::Reader::hasSnd() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename F, typename S>
inline bool Pair<F, S>::Builder::hasSnd() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename F, typename S>
inline  ::capnp::ReaderFor<S> Pair<F, S>::Reader::getSnd() const {
  return ::capnp::_::PointerHelpers<S>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename F, typename S>
inline  ::capnp::BuilderFor<S> Pair<F, S>::Builder::getSnd() {
  return ::capnp::_::PointerHelpers<S>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename F, typename S>
inline  ::capnp::PipelineFor<S> Pair<F, S>::Pipeline::getSnd() {
  return  ::capnp::PipelineFor<S>(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
template <typename F, typename S>
inline void Pair<F, S>::Builder::setSnd( ::capnp::ReaderFor<S> value) {
  ::capnp::_::PointerHelpers<S>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename F, typename S>
inline  ::capnp::BuilderFor<S> Pair<F, S>::Builder::initSnd() {
  return ::capnp::_::PointerHelpers<S>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename F, typename S>
inline  ::capnp::BuilderFor<S> Pair<F, S>::Builder::initSnd(unsigned int size) {
  return ::capnp::_::PointerHelpers<S>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
template <typename F, typename S>
inline void Pair<F, S>::Builder::adoptSnd(
    ::capnp::Orphan<S>&& value) {
  ::capnp::_::PointerHelpers<S>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename F, typename S>
inline ::capnp::Orphan<S> Pair<F, S>::Builder::disownSnd() {
  return ::capnp::_::PointerHelpers<S>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

// Pair<F, S>
template <typename F, typename S>
constexpr uint16_t Pair<F, S>::_capnpPrivate::dataWordSize;
template <typename F, typename S>
constexpr uint16_t Pair<F, S>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename F, typename S>
constexpr ::capnp::Kind Pair<F, S>::_capnpPrivate::kind;
template <typename F, typename S>
constexpr ::capnp::_::RawSchema const* Pair<F, S>::_capnpPrivate::schema;
template <typename F, typename S>
const ::capnp::_::RawBrandedSchema::Scope Pair<F, S>::_capnpPrivate::brandScopes[] = {
  { 0xb9d4864725174733, brandBindings + 0, 2, false},
};
template <typename F, typename S>
const ::capnp::_::RawBrandedSchema::Binding Pair<F, S>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<F>(),
  ::capnp::_::brandBindingFor<S>(),
};
template <typename F, typename S>
const ::capnp::_::RawBrandedSchema Pair<F, S>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_b9d4864725174733, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename H, typename T>
inline bool LL<H, T>::Reader::hasHead() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename H, typename T>
inline bool LL<H, T>::Builder::hasHead() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename H, typename T>
inline  ::capnp::ReaderFor<H> LL<H, T>::Reader::getHead() const {
  return ::capnp::_::PointerHelpers<H>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename H, typename T>
inline  ::capnp::BuilderFor<H> LL<H, T>::Builder::getHead() {
  return ::capnp::_::PointerHelpers<H>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename H, typename T>
inline  ::capnp::PipelineFor<H> LL<H, T>::Pipeline::getHead() {
  return  ::capnp::PipelineFor<H>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename H, typename T>
inline void LL<H, T>::Builder::setHead( ::capnp::ReaderFor<H> value) {
  ::capnp::_::PointerHelpers<H>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename H, typename T>
inline  ::capnp::BuilderFor<H> LL<H, T>::Builder::initHead() {
  return ::capnp::_::PointerHelpers<H>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename H, typename T>
inline  ::capnp::BuilderFor<H> LL<H, T>::Builder::initHead(unsigned int size) {
  return ::capnp::_::PointerHelpers<H>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename H, typename T>
inline void LL<H, T>::Builder::adoptHead(
    ::capnp::Orphan<H>&& value) {
  ::capnp::_::PointerHelpers<H>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename H, typename T>
inline ::capnp::Orphan<H> LL<H, T>::Builder::disownHead() {
  return ::capnp::_::PointerHelpers<H>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename H, typename T>
inline bool LL<H, T>::Reader::hasTail() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename H, typename T>
inline bool LL<H, T>::Builder::hasTail() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename H, typename T>
inline  ::capnp::ReaderFor<T> LL<H, T>::Reader::getTail() const {
  return ::capnp::_::PointerHelpers<T>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename H, typename T>
inline  ::capnp::BuilderFor<T> LL<H, T>::Builder::getTail() {
  return ::capnp::_::PointerHelpers<T>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename H, typename T>
inline  ::capnp::PipelineFor<T> LL<H, T>::Pipeline::getTail() {
  return  ::capnp::PipelineFor<T>(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
template <typename H, typename T>
inline void LL<H, T>::Builder::setTail( ::capnp::ReaderFor<T> value) {
  ::capnp::_::PointerHelpers<T>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename H, typename T>
inline  ::capnp::BuilderFor<T> LL<H, T>::Builder::initTail() {
  return ::capnp::_::PointerHelpers<T>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename H, typename T>
inline  ::capnp::BuilderFor<T> LL<H, T>::Builder::initTail(unsigned int size) {
  return ::capnp::_::PointerHelpers<T>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
template <typename H, typename T>
inline void LL<H, T>::Builder::adoptTail(
    ::capnp::Orphan<T>&& value) {
  ::capnp::_::PointerHelpers<T>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename H, typename T>
inline ::capnp::Orphan<T> LL<H, T>::Builder::disownTail() {
  return ::capnp::_::PointerHelpers<T>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

// LL<H, T>
template <typename H, typename T>
constexpr uint16_t LL<H, T>::_capnpPrivate::dataWordSize;
template <typename H, typename T>
constexpr uint16_t LL<H, T>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename H, typename T>
constexpr ::capnp::Kind LL<H, T>::_capnpPrivate::kind;
template <typename H, typename T>
constexpr ::capnp::_::RawSchema const* LL<H, T>::_capnpPrivate::schema;
template <typename H, typename T>
const ::capnp::_::RawBrandedSchema::Scope LL<H, T>::_capnpPrivate::brandScopes[] = {
  { 0xd67792aa3fc241be, brandBindings + 0, 2, false},
};
template <typename H, typename T>
const ::capnp::_::RawBrandedSchema::Binding LL<H, T>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<H>(),
  ::capnp::_::brandBindingFor<T>(),
};
template <typename H, typename T>
const ::capnp::_::RawBrandedSchema LL<H, T>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_d67792aa3fc241be, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

