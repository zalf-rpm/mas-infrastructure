// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: common.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#if CAPNP_VERSION != 10000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "persistence.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(d4cb7ecbfe03dad3);
CAPNP_DECLARE_SCHEMA(b2afd1cb599c48d5);
CAPNP_DECLARE_SCHEMA(9d8aa1cf1e49deb1);
CAPNP_DECLARE_SCHEMA(ed6c098b67cad454);
CAPNP_DECLARE_SCHEMA(e8cbf552b1c262cc);
CAPNP_DECLARE_SCHEMA(902904cd51bff117);
CAPNP_DECLARE_SCHEMA(83b4353989cbcb47);
CAPNP_DECLARE_SCHEMA(b16b6184cf8b8acf);
CAPNP_DECLARE_SCHEMA(9dd4e2c3d76e4587);
CAPNP_DECLARE_SCHEMA(f9033a317ba0d0c6);
CAPNP_DECLARE_SCHEMA(cc040dde1a99ddff);
CAPNP_DECLARE_SCHEMA(c12db9a9ae07a763);
CAPNP_DECLARE_SCHEMA(a1eb17b1112501da);
CAPNP_DECLARE_SCHEMA(fd65c3cd7f2f47fa);
CAPNP_DECLARE_SCHEMA(a869f50b8c586ed9);
CAPNP_DECLARE_SCHEMA(fd058bbd1f9508cd);
CAPNP_DECLARE_SCHEMA(d010f77f1bdf0522);
CAPNP_DECLARE_SCHEMA(fe04fe97ba25a27e);
CAPNP_DECLARE_SCHEMA(cac9c6537df1a097);
CAPNP_DECLARE_SCHEMA(da52b34d937fa814);
CAPNP_DECLARE_SCHEMA(dc9b0f483595691f);
CAPNP_DECLARE_SCHEMA(82449708d4fd120d);
CAPNP_DECLARE_SCHEMA(c1374ccca01e2b53);
CAPNP_DECLARE_SCHEMA(ee543d7c305d56f6);
CAPNP_DECLARE_SCHEMA(93a1b0e66bcacfbb);
CAPNP_DECLARE_SCHEMA(b9fe596d7cadbdcc);
CAPNP_DECLARE_SCHEMA(d69f2da1efe3faaf);
CAPNP_DECLARE_SCHEMA(8ca159db7de3927b);
CAPNP_DECLARE_SCHEMA(c201bf46dd40051e);
CAPNP_DECLARE_SCHEMA(ce7e4202f09e314a);
CAPNP_DECLARE_SCHEMA(98a27c9476315729);
CAPNP_DECLARE_SCHEMA(d3a3b24aaa056a5c);
CAPNP_DECLARE_SCHEMA(b9d4864725174733);
CAPNP_DECLARE_SCHEMA(d67792aa3fc241be);
CAPNP_DECLARE_SCHEMA(a8b91e2c1f8c929a);
CAPNP_DECLARE_SCHEMA(fd0735841a7da108);
CAPNP_DECLARE_SCHEMA(c953edb8b6293faf);
CAPNP_DECLARE_SCHEMA(d39ff99bbab1a74e);
CAPNP_DECLARE_SCHEMA(b07588184ad8aac5);
CAPNP_DECLARE_SCHEMA(f0c0f9413a3083be);
CAPNP_DECLARE_SCHEMA(956ee3f21ad6b221);
enum class CloseSemantics_956ee3f21ad6b221: uint16_t {
  FBP,
  NO,
};
CAPNP_DECLARE_ENUM(CloseSemantics, 956ee3f21ad6b221);
CAPNP_DECLARE_SCHEMA(876b422c6839e6b2);
CAPNP_DECLARE_SCHEMA(9c656810b30decd7);
CAPNP_DECLARE_SCHEMA(f8dc00b2d60ea82f);
CAPNP_DECLARE_SCHEMA(926107b4c88d431f);
CAPNP_DECLARE_SCHEMA(ec0d27e49a0f9f3a);
CAPNP_DECLARE_SCHEMA(9b5844944dc0f458);
CAPNP_DECLARE_SCHEMA(98be830bb53c6eb9);
CAPNP_DECLARE_SCHEMA(b86feee7ac7bebec);
CAPNP_DECLARE_SCHEMA(86215e947f0afb85);
CAPNP_DECLARE_SCHEMA(ee378f318f32b853);
CAPNP_DECLARE_SCHEMA(abd31dc62bd9a48b);
CAPNP_DECLARE_SCHEMA(b6563114436deea9);
CAPNP_DECLARE_SCHEMA(89aeecad59dc62ee);
CAPNP_DECLARE_SCHEMA(9882f67fa6ace6a1);
CAPNP_DECLARE_SCHEMA(d7e3695f7166e987);
CAPNP_DECLARE_SCHEMA(db1f001689bbac5d);
CAPNP_DECLARE_SCHEMA(c8a1bc4350302330);
CAPNP_DECLARE_SCHEMA(d8727b5440681ed4);
CAPNP_DECLARE_SCHEMA(e8ba8300eb17a23c);
CAPNP_DECLARE_SCHEMA(f8224774a4d4d6f5);
CAPNP_DECLARE_SCHEMA(f20dfadcec8a0e13);

}  // namespace schemas
}  // namespace capnp

namespace mas {
namespace schema {
namespace common {

struct IdInformation {
  IdInformation() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d4cb7ecbfe03dad3, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Identifiable {
  Identifiable() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct InfoParams;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(b2afd1cb599c48d5)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Identifiable::InfoParams {
  InfoParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9d8aa1cf1e49deb1, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct StructuredText {
  StructuredText() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Structure;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ed6c098b67cad454, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct StructuredText::Structure {
  Structure() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    NONE,
    JSON,
    XML,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e8cbf552b1c262cc, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Callback {
  Callback() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct CallParams;
  struct CallResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(902904cd51bff117)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Callback::CallParams {
  CallParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(83b4353989cbcb47, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Callback::CallResults {
  CallResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b16b6184cf8b8acf, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Action {
  Action() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct DoParams;
  struct DoResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(9dd4e2c3d76e4587)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Action::DoParams {
  DoParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f9033a317ba0d0c6, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Action::DoResults {
  DoResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cc040dde1a99ddff, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Action1 {
  Action1() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct DoParams;
  struct DoResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(c12db9a9ae07a763)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Action1::DoParams {
  DoParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a1eb17b1112501da, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Action1::DoResults {
  DoResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fd65c3cd7f2f47fa, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

template <typename Input = ::capnp::AnyPointer, typename Output = ::capnp::AnyPointer>
struct Factory {
  Factory() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct ProduceParams;
  struct ProduceResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(a869f50b8c586ed9)
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Input, Output>::brand(); }
  };
  #endif  // !CAPNP_LITE
};

template <typename Input, typename Output>
struct Factory<Input, Output>::ProduceParams {
  ProduceParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fd058bbd1f9508cd, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Input, Output>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Input, typename Output>
struct Factory<Input, Output>::ProduceResults {
  ProduceResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d010f77f1bdf0522, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Input, Output>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

struct ZmqPipelineAddresses {
  ZmqPipelineAddresses() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fe04fe97ba25a27e, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

template <typename Object = ::capnp::AnyPointer>
struct CapHolder {
  CapHolder() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct CapParams;
  struct CapResults;
  struct ReleaseParams;
  struct ReleaseResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(cac9c6537df1a097)
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Object>::brand(); }
  };
  #endif  // !CAPNP_LITE
};

template <typename Object>
struct CapHolder<Object>::CapParams {
  CapParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(da52b34d937fa814, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Object>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Object>
struct CapHolder<Object>::CapResults {
  CapResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dc9b0f483595691f, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Object>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Object>
struct CapHolder<Object>::ReleaseParams {
  ReleaseParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(82449708d4fd120d, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Object>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Object>
struct CapHolder<Object>::ReleaseResults {
  ReleaseResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c1374ccca01e2b53, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Object>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

struct IdentifiableHolder {
  IdentifiableHolder() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct CapParams;
  struct CapResults;
  struct ReleaseParams;
  struct ReleaseResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(ee543d7c305d56f6)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct IdentifiableHolder::CapParams {
  CapParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(93a1b0e66bcacfbb, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct IdentifiableHolder::CapResults {
  CapResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b9fe596d7cadbdcc, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct IdentifiableHolder::ReleaseParams {
  ReleaseParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d69f2da1efe3faaf, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct IdentifiableHolder::ReleaseResults {
  ReleaseResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8ca159db7de3927b, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

template <typename PointerType = ::capnp::AnyPointer>
struct ListEntry {
  ListEntry() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c201bf46dd40051e, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, PointerType>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

struct Stopable {
  Stopable() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct StopParams;
  struct StopResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(ce7e4202f09e314a)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Stopable::StopParams {
  StopParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(98a27c9476315729, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Stopable::StopResults {
  StopResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d3a3b24aaa056a5c, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

template <typename F = ::capnp::AnyPointer, typename S = ::capnp::AnyPointer>
struct Pair {
  Pair() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b9d4864725174733, 0, 2)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, F, S>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename H = ::capnp::AnyPointer, typename T = ::capnp::AnyPointer>
struct LL {
  LL() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d67792aa3fc241be, 0, 2)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, H, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T = ::capnp::AnyPointer>
struct Clock {
  Clock() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct TickParams;
  struct TickResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(a8b91e2c1f8c929a)
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
  };
  #endif  // !CAPNP_LITE
};

template <typename T>
struct Clock<T>::TickParams {
  TickParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fd0735841a7da108, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename T>
struct Clock<T>::TickResults {
  TickResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c953edb8b6293faf, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

struct IP {
  IP() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct KV;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d39ff99bbab1a74e, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct IP::KV {
  KV() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b07588184ad8aac5, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

template <typename V = ::capnp::AnyPointer>
struct Channel {
  Channel() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  typedef ::capnp::schemas::CloseSemantics_956ee3f21ad6b221 CloseSemantics;

  struct Msg;
  struct ChanReader;
  struct ChanWriter;
  struct SetBufferSizeParams;
  struct SetBufferSizeResults;
  struct ReaderParams;
  struct ReaderResults;
  struct WriterParams;
  struct WriterResults;
  struct EndpointsParams;
  struct EndpointsResults;
  struct SetAutoCloseSemanticsParams;
  struct SetAutoCloseSemanticsResults;
  struct CloseParams;
  struct CloseResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(f0c0f9413a3083be)
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
  };
  #endif  // !CAPNP_LITE
};

template <typename V>
struct Channel<V>::Msg {
  Msg() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    VALUE,
    DONE,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(876b422c6839e6b2, 1, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ChanReader {
  ChanReader() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct ReadParams;
  struct CloseParams;
  struct CloseResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(9c656810b30decd7)
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
  };
  #endif  // !CAPNP_LITE
};

template <typename V>
struct Channel<V>::ChanReader::ReadParams {
  ReadParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f8dc00b2d60ea82f, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ChanReader::CloseParams {
  CloseParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(926107b4c88d431f, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ChanReader::CloseResults {
  CloseResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ec0d27e49a0f9f3a, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ChanWriter {
  ChanWriter() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct WriteResults;
  struct CloseParams;
  struct CloseResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(9b5844944dc0f458)
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
  };
  #endif  // !CAPNP_LITE
};

template <typename V>
struct Channel<V>::ChanWriter::WriteResults {
  WriteResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(98be830bb53c6eb9, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ChanWriter::CloseParams {
  CloseParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b86feee7ac7bebec, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ChanWriter::CloseResults {
  CloseResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(86215e947f0afb85, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::SetBufferSizeParams {
  SetBufferSizeParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ee378f318f32b853, 1, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::SetBufferSizeResults {
  SetBufferSizeResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(abd31dc62bd9a48b, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ReaderParams {
  ReaderParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b6563114436deea9, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::ReaderResults {
  ReaderResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(89aeecad59dc62ee, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::WriterParams {
  WriterParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9882f67fa6ace6a1, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::WriterResults {
  WriterResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d7e3695f7166e987, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::EndpointsParams {
  EndpointsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(db1f001689bbac5d, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::EndpointsResults {
  EndpointsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c8a1bc4350302330, 0, 2)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::SetAutoCloseSemanticsParams {
  SetAutoCloseSemanticsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d8727b5440681ed4, 1, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::SetAutoCloseSemanticsResults {
  SetAutoCloseSemanticsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e8ba8300eb17a23c, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::CloseParams {
  CloseParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f8224774a4d4d6f5, 1, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename V>
struct Channel<V>::CloseResults {
  CloseResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f20dfadcec8a0e13, 0, 0)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, V>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class IdInformation::Reader {
public:
  typedef IdInformation Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasId() const;
  inline  ::capnp::Text::Reader getId() const;

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasDescription() const;
  inline  ::capnp::Text::Reader getDescription() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IdInformation::Builder {
public:
  typedef IdInformation Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasId();
  inline  ::capnp::Text::Builder getId();
  inline void setId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initId(unsigned int size);
  inline void adoptId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownId();

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasDescription();
  inline  ::capnp::Text::Builder getDescription();
  inline void setDescription( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initDescription(unsigned int size);
  inline void adoptDescription(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownDescription();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IdInformation::Pipeline {
public:
  typedef IdInformation Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Identifiable::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Identifiable Calls;
  typedef Identifiable Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::common::Identifiable::InfoParams,  ::mas::schema::common::IdInformation> infoRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Identifiable::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Identifiable Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::common::Identifiable::InfoParams InfoParams;
  typedef ::capnp::CallContext<InfoParams,  ::mas::schema::common::IdInformation> InfoContext;
  virtual ::kj::Promise<void> info(InfoContext context);

  inline  ::mas::schema::common::Identifiable::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::common::Identifiable>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Identifiable::InfoParams::Reader {
public:
  typedef InfoParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Identifiable::InfoParams::Builder {
public:
  typedef InfoParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Identifiable::InfoParams::Pipeline {
public:
  typedef InfoParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class StructuredText::Reader {
public:
  typedef StructuredText Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasValue() const;
  inline  ::capnp::Text::Reader getValue() const;

  inline typename Structure::Reader getStructure() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class StructuredText::Builder {
public:
  typedef StructuredText Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasValue();
  inline  ::capnp::Text::Builder getValue();
  inline void setValue( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initValue(unsigned int size);
  inline void adoptValue(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownValue();

  inline typename Structure::Builder getStructure();
  inline typename Structure::Builder initStructure();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class StructuredText::Pipeline {
public:
  typedef StructuredText Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename Structure::Pipeline getStructure();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class StructuredText::Structure::Reader {
public:
  typedef Structure Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isNone() const;
  inline  ::capnp::Void getNone() const;

  inline bool isJson() const;
  inline  ::capnp::Void getJson() const;

  inline bool isXml() const;
  inline  ::capnp::Void getXml() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class StructuredText::Structure::Builder {
public:
  typedef Structure Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isNone();
  inline  ::capnp::Void getNone();
  inline void setNone( ::capnp::Void value = ::capnp::VOID);

  inline bool isJson();
  inline  ::capnp::Void getJson();
  inline void setJson( ::capnp::Void value = ::capnp::VOID);

  inline bool isXml();
  inline  ::capnp::Void getXml();
  inline void setXml( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class StructuredText::Structure::Pipeline {
public:
  typedef Structure Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Callback::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Callback Calls;
  typedef Callback Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::common::Callback::CallParams,  ::mas::schema::common::Callback::CallResults> callRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Callback::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Callback Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::common::Callback::CallParams CallParams;
  typedef  ::mas::schema::common::Callback::CallResults CallResults;
  typedef ::capnp::CallContext<CallParams, CallResults> CallContext;
  virtual ::kj::Promise<void> call(CallContext context);

  inline  ::mas::schema::common::Callback::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::common::Callback>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Callback::CallParams::Reader {
public:
  typedef CallParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Callback::CallParams::Builder {
public:
  typedef CallParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Callback::CallParams::Pipeline {
public:
  typedef CallParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Callback::CallResults::Reader {
public:
  typedef CallResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Callback::CallResults::Builder {
public:
  typedef CallResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Callback::CallResults::Pipeline {
public:
  typedef CallResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Action::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::persistence::Persistent::Client {
public:
  typedef Action Calls;
  typedef Action Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::common::Action::DoParams,  ::mas::schema::common::Action::DoResults> doRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Action::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::persistence::Persistent::Server {
public:
  typedef Action Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::common::Action::DoParams DoParams;
  typedef  ::mas::schema::common::Action::DoResults DoResults;
  typedef ::capnp::CallContext<DoParams, DoResults> DoContext;
  virtual ::kj::Promise<void> do_(DoContext context);

  inline  ::mas::schema::common::Action::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::common::Action>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Action::DoParams::Reader {
public:
  typedef DoParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Action::DoParams::Builder {
public:
  typedef DoParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Action::DoParams::Pipeline {
public:
  typedef DoParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Action::DoResults::Reader {
public:
  typedef DoResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Action::DoResults::Builder {
public:
  typedef DoResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Action::DoResults::Pipeline {
public:
  typedef DoResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Action1::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::persistence::Persistent::Client {
public:
  typedef Action1 Calls;
  typedef Action1 Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::common::Action1::DoParams,  ::mas::schema::common::Action1::DoResults> doRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Action1::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::persistence::Persistent::Server {
public:
  typedef Action1 Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::common::Action1::DoParams DoParams;
  typedef  ::mas::schema::common::Action1::DoResults DoResults;
  typedef ::capnp::CallContext<DoParams, DoResults> DoContext;
  virtual ::kj::Promise<void> do_(DoContext context);

  inline  ::mas::schema::common::Action1::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::common::Action1>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Action1::DoParams::Reader {
public:
  typedef DoParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasP() const;
  inline ::capnp::AnyPointer::Reader getP() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Action1::DoParams::Builder {
public:
  typedef DoParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasP();
  inline ::capnp::AnyPointer::Builder getP();
  inline ::capnp::AnyPointer::Builder initP();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Action1::DoParams::Pipeline {
public:
  typedef DoParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Action1::DoResults::Reader {
public:
  typedef DoResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Action1::DoResults::Builder {
public:
  typedef DoResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Action1::DoResults::Pipeline {
public:
  typedef DoResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename Input, typename Output>
class Factory<Input, Output>::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Factory Calls;
  typedef Factory Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename Input2 = ::capnp::AnyPointer, typename Output2 = ::capnp::AnyPointer>
  typename Factory<Input2, Output2>::Client asGeneric() {
    return castAs<Factory<Input2, Output2>>();
  }

  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::Factory<Input, Output>::ProduceParams, typename  ::mas::schema::common::Factory<Input, Output>::ProduceResults>) produceRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

template <typename Input, typename Output>
class Factory<Input, Output>::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Factory Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef typename  ::mas::schema::common::Factory<Input, Output>::ProduceParams ProduceParams;
  typedef typename  ::mas::schema::common::Factory<Input, Output>::ProduceResults ProduceResults;
  typedef ::capnp::CallContext<ProduceParams, ProduceResults> ProduceContext;
  virtual ::kj::Promise<void> produce(ProduceContext context);

  inline typename  ::mas::schema::common::Factory<Input, Output>::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::common::Factory<Input, Output>>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename Input, typename Output>
class Factory<Input, Output>::ProduceParams::Reader {
public:
  typedef ProduceParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Input2 = ::capnp::AnyPointer, typename Output2 = ::capnp::AnyPointer>
  typename Factory<Input2, Output2>::ProduceParams::Reader asFactoryGeneric() {
    return typename Factory<Input2, Output2>::ProduceParams::Reader(_reader);
  }

  inline bool hasIn() const;
  inline  ::capnp::ReaderFor<Input> getIn() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Input, typename Output>
class Factory<Input, Output>::ProduceParams::Builder {
public:
  typedef ProduceParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Input2 = ::capnp::AnyPointer, typename Output2 = ::capnp::AnyPointer>
  typename Factory<Input2, Output2>::ProduceParams::Builder asFactoryGeneric() {
    return typename Factory<Input2, Output2>::ProduceParams::Builder(_builder);
  }

  inline bool hasIn();
  inline  ::capnp::BuilderFor<Input> getIn();
  inline void setIn( ::capnp::ReaderFor<Input> value);
  inline  ::capnp::BuilderFor<Input> initIn();
  inline  ::capnp::BuilderFor<Input> initIn(unsigned int size);
  inline void adoptIn(::capnp::Orphan<Input>&& value);
  inline ::capnp::Orphan<Input> disownIn();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Input, typename Output>
class Factory<Input, Output>::ProduceParams::Pipeline {
public:
  typedef ProduceParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<Input> getIn();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Input, typename Output>
class Factory<Input, Output>::ProduceResults::Reader {
public:
  typedef ProduceResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Input2 = ::capnp::AnyPointer, typename Output2 = ::capnp::AnyPointer>
  typename Factory<Input2, Output2>::ProduceResults::Reader asFactoryGeneric() {
    return typename Factory<Input2, Output2>::ProduceResults::Reader(_reader);
  }

  inline bool hasOut() const;
  inline  ::capnp::ReaderFor<Output> getOut() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Input, typename Output>
class Factory<Input, Output>::ProduceResults::Builder {
public:
  typedef ProduceResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Input2 = ::capnp::AnyPointer, typename Output2 = ::capnp::AnyPointer>
  typename Factory<Input2, Output2>::ProduceResults::Builder asFactoryGeneric() {
    return typename Factory<Input2, Output2>::ProduceResults::Builder(_builder);
  }

  inline bool hasOut();
  inline  ::capnp::BuilderFor<Output> getOut();
  inline void setOut( ::capnp::ReaderFor<Output> value);
  inline  ::capnp::BuilderFor<Output> initOut();
  inline  ::capnp::BuilderFor<Output> initOut(unsigned int size);
  inline void adoptOut(::capnp::Orphan<Output>&& value);
  inline ::capnp::Orphan<Output> disownOut();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Input, typename Output>
class Factory<Input, Output>::ProduceResults::Pipeline {
public:
  typedef ProduceResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<Output> getOut();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ZmqPipelineAddresses::Reader {
public:
  typedef ZmqPipelineAddresses Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasInput() const;
  inline  ::capnp::Text::Reader getInput() const;

  inline bool hasOutput() const;
  inline  ::capnp::Text::Reader getOutput() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ZmqPipelineAddresses::Builder {
public:
  typedef ZmqPipelineAddresses Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasInput();
  inline  ::capnp::Text::Builder getInput();
  inline void setInput( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initInput(unsigned int size);
  inline void adoptInput(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownInput();

  inline bool hasOutput();
  inline  ::capnp::Text::Builder getOutput();
  inline void setOutput( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initOutput(unsigned int size);
  inline void adoptOutput(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownOutput();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ZmqPipelineAddresses::Pipeline {
public:
  typedef ZmqPipelineAddresses Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename Object>
class CapHolder<Object>::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef CapHolder Calls;
  typedef CapHolder Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename Object2 = ::capnp::AnyPointer>
  typename CapHolder<Object2>::Client asGeneric() {
    return castAs<CapHolder<Object2>>();
  }

  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::CapHolder<Object>::CapParams, typename  ::mas::schema::common::CapHolder<Object>::CapResults>) capRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::CapHolder<Object>::ReleaseParams, typename  ::mas::schema::common::CapHolder<Object>::ReleaseResults>) releaseRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

template <typename Object>
class CapHolder<Object>::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef CapHolder Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef typename  ::mas::schema::common::CapHolder<Object>::CapParams CapParams;
  typedef typename  ::mas::schema::common::CapHolder<Object>::CapResults CapResults;
  typedef ::capnp::CallContext<CapParams, CapResults> CapContext;
  virtual ::kj::Promise<void> cap(CapContext context);
  typedef typename  ::mas::schema::common::CapHolder<Object>::ReleaseParams ReleaseParams;
  typedef typename  ::mas::schema::common::CapHolder<Object>::ReleaseResults ReleaseResults;
  typedef ::capnp::CallContext<ReleaseParams, ReleaseResults> ReleaseContext;
  virtual ::kj::Promise<void> release(ReleaseContext context);

  inline typename  ::mas::schema::common::CapHolder<Object>::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::common::CapHolder<Object>>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename Object>
class CapHolder<Object>::CapParams::Reader {
public:
  typedef CapParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Object2 = ::capnp::AnyPointer>
  typename CapHolder<Object2>::CapParams::Reader asCapHolderGeneric() {
    return typename CapHolder<Object2>::CapParams::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Object>
class CapHolder<Object>::CapParams::Builder {
public:
  typedef CapParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Object2 = ::capnp::AnyPointer>
  typename CapHolder<Object2>::CapParams::Builder asCapHolderGeneric() {
    return typename CapHolder<Object2>::CapParams::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Object>
class CapHolder<Object>::CapParams::Pipeline {
public:
  typedef CapParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Object>
class CapHolder<Object>::CapResults::Reader {
public:
  typedef CapResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Object2 = ::capnp::AnyPointer>
  typename CapHolder<Object2>::CapResults::Reader asCapHolderGeneric() {
    return typename CapHolder<Object2>::CapResults::Reader(_reader);
  }

  inline bool hasObject() const;
  inline  ::capnp::ReaderFor<Object> getObject() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Object>
class CapHolder<Object>::CapResults::Builder {
public:
  typedef CapResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Object2 = ::capnp::AnyPointer>
  typename CapHolder<Object2>::CapResults::Builder asCapHolderGeneric() {
    return typename CapHolder<Object2>::CapResults::Builder(_builder);
  }

  inline bool hasObject();
  inline  ::capnp::BuilderFor<Object> getObject();
  inline void setObject( ::capnp::ReaderFor<Object> value);
  inline  ::capnp::BuilderFor<Object> initObject();
  inline  ::capnp::BuilderFor<Object> initObject(unsigned int size);
  inline void adoptObject(::capnp::Orphan<Object>&& value);
  inline ::capnp::Orphan<Object> disownObject();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Object>
class CapHolder<Object>::CapResults::Pipeline {
public:
  typedef CapResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<Object> getObject();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Object>
class CapHolder<Object>::ReleaseParams::Reader {
public:
  typedef ReleaseParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Object2 = ::capnp::AnyPointer>
  typename CapHolder<Object2>::ReleaseParams::Reader asCapHolderGeneric() {
    return typename CapHolder<Object2>::ReleaseParams::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Object>
class CapHolder<Object>::ReleaseParams::Builder {
public:
  typedef ReleaseParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Object2 = ::capnp::AnyPointer>
  typename CapHolder<Object2>::ReleaseParams::Builder asCapHolderGeneric() {
    return typename CapHolder<Object2>::ReleaseParams::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Object>
class CapHolder<Object>::ReleaseParams::Pipeline {
public:
  typedef ReleaseParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Object>
class CapHolder<Object>::ReleaseResults::Reader {
public:
  typedef ReleaseResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Object2 = ::capnp::AnyPointer>
  typename CapHolder<Object2>::ReleaseResults::Reader asCapHolderGeneric() {
    return typename CapHolder<Object2>::ReleaseResults::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Object>
class CapHolder<Object>::ReleaseResults::Builder {
public:
  typedef ReleaseResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Object2 = ::capnp::AnyPointer>
  typename CapHolder<Object2>::ReleaseResults::Builder asCapHolderGeneric() {
    return typename CapHolder<Object2>::ReleaseResults::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Object>
class CapHolder<Object>::ReleaseResults::Pipeline {
public:
  typedef ReleaseResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class IdentifiableHolder::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client {
public:
  typedef IdentifiableHolder Calls;
  typedef IdentifiableHolder Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::common::IdentifiableHolder::CapParams,  ::mas::schema::common::IdentifiableHolder::CapResults> capRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::common::IdentifiableHolder::ReleaseParams,  ::mas::schema::common::IdentifiableHolder::ReleaseResults> releaseRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class IdentifiableHolder::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server {
public:
  typedef IdentifiableHolder Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::common::IdentifiableHolder::CapParams CapParams;
  typedef  ::mas::schema::common::IdentifiableHolder::CapResults CapResults;
  typedef ::capnp::CallContext<CapParams, CapResults> CapContext;
  virtual ::kj::Promise<void> cap(CapContext context);
  typedef  ::mas::schema::common::IdentifiableHolder::ReleaseParams ReleaseParams;
  typedef  ::mas::schema::common::IdentifiableHolder::ReleaseResults ReleaseResults;
  typedef ::capnp::CallContext<ReleaseParams, ReleaseResults> ReleaseContext;
  virtual ::kj::Promise<void> release(ReleaseContext context);

  inline  ::mas::schema::common::IdentifiableHolder::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::common::IdentifiableHolder>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class IdentifiableHolder::CapParams::Reader {
public:
  typedef CapParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IdentifiableHolder::CapParams::Builder {
public:
  typedef CapParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IdentifiableHolder::CapParams::Pipeline {
public:
  typedef CapParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IdentifiableHolder::CapResults::Reader {
public:
  typedef CapResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCap() const;
#if !CAPNP_LITE
  inline  ::mas::schema::common::Identifiable::Client getCap() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IdentifiableHolder::CapResults::Builder {
public:
  typedef CapResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCap();
#if !CAPNP_LITE
  inline  ::mas::schema::common::Identifiable::Client getCap();
  inline void setCap( ::mas::schema::common::Identifiable::Client&& value);
  inline void setCap( ::mas::schema::common::Identifiable::Client& value);
  inline void adoptCap(::capnp::Orphan< ::mas::schema::common::Identifiable>&& value);
  inline ::capnp::Orphan< ::mas::schema::common::Identifiable> disownCap();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IdentifiableHolder::CapResults::Pipeline {
public:
  typedef CapResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::common::Identifiable::Client getCap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IdentifiableHolder::ReleaseParams::Reader {
public:
  typedef ReleaseParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IdentifiableHolder::ReleaseParams::Builder {
public:
  typedef ReleaseParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IdentifiableHolder::ReleaseParams::Pipeline {
public:
  typedef ReleaseParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IdentifiableHolder::ReleaseResults::Reader {
public:
  typedef ReleaseResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IdentifiableHolder::ReleaseResults::Builder {
public:
  typedef ReleaseResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IdentifiableHolder::ReleaseResults::Pipeline {
public:
  typedef ReleaseResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename PointerType>
class ListEntry<PointerType>::Reader {
public:
  typedef ListEntry Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename PointerType2 = ::capnp::AnyPointer>
  typename ListEntry<PointerType2>::Reader asGeneric() {
    return typename ListEntry<PointerType2>::Reader(_reader);
  }

  inline bool hasEntry() const;
  inline  ::capnp::ReaderFor<PointerType> getEntry() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename PointerType>
class ListEntry<PointerType>::Builder {
public:
  typedef ListEntry Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename PointerType2 = ::capnp::AnyPointer>
  typename ListEntry<PointerType2>::Builder asGeneric() {
    return typename ListEntry<PointerType2>::Builder(_builder);
  }

  inline bool hasEntry();
  inline  ::capnp::BuilderFor<PointerType> getEntry();
  inline void setEntry( ::capnp::ReaderFor<PointerType> value);
  inline  ::capnp::BuilderFor<PointerType> initEntry();
  inline  ::capnp::BuilderFor<PointerType> initEntry(unsigned int size);
  inline void adoptEntry(::capnp::Orphan<PointerType>&& value);
  inline ::capnp::Orphan<PointerType> disownEntry();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename PointerType>
class ListEntry<PointerType>::Pipeline {
public:
  typedef ListEntry Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<PointerType> getEntry();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Stopable::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Stopable Calls;
  typedef Stopable Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::common::Stopable::StopParams,  ::mas::schema::common::Stopable::StopResults> stopRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Stopable::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Stopable Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::common::Stopable::StopParams StopParams;
  typedef  ::mas::schema::common::Stopable::StopResults StopResults;
  typedef ::capnp::CallContext<StopParams, StopResults> StopContext;
  virtual ::kj::Promise<void> stop(StopContext context);

  inline  ::mas::schema::common::Stopable::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::common::Stopable>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Stopable::StopParams::Reader {
public:
  typedef StopParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Stopable::StopParams::Builder {
public:
  typedef StopParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Stopable::StopParams::Pipeline {
public:
  typedef StopParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Stopable::StopResults::Reader {
public:
  typedef StopResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Stopable::StopResults::Builder {
public:
  typedef StopResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Stopable::StopResults::Pipeline {
public:
  typedef StopResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename F, typename S>
class Pair<F, S>::Reader {
public:
  typedef Pair Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename F2 = ::capnp::AnyPointer, typename S2 = ::capnp::AnyPointer>
  typename Pair<F2, S2>::Reader asGeneric() {
    return typename Pair<F2, S2>::Reader(_reader);
  }

  inline bool hasFst() const;
  inline  ::capnp::ReaderFor<F> getFst() const;

  inline bool hasSnd() const;
  inline  ::capnp::ReaderFor<S> getSnd() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename F, typename S>
class Pair<F, S>::Builder {
public:
  typedef Pair Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename F2 = ::capnp::AnyPointer, typename S2 = ::capnp::AnyPointer>
  typename Pair<F2, S2>::Builder asGeneric() {
    return typename Pair<F2, S2>::Builder(_builder);
  }

  inline bool hasFst();
  inline  ::capnp::BuilderFor<F> getFst();
  inline void setFst( ::capnp::ReaderFor<F> value);
  inline  ::capnp::BuilderFor<F> initFst();
  inline  ::capnp::BuilderFor<F> initFst(unsigned int size);
  inline void adoptFst(::capnp::Orphan<F>&& value);
  inline ::capnp::Orphan<F> disownFst();

  inline bool hasSnd();
  inline  ::capnp::BuilderFor<S> getSnd();
  inline void setSnd( ::capnp::ReaderFor<S> value);
  inline  ::capnp::BuilderFor<S> initSnd();
  inline  ::capnp::BuilderFor<S> initSnd(unsigned int size);
  inline void adoptSnd(::capnp::Orphan<S>&& value);
  inline ::capnp::Orphan<S> disownSnd();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename F, typename S>
class Pair<F, S>::Pipeline {
public:
  typedef Pair Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<F> getFst();
  inline  ::capnp::PipelineFor<S> getSnd();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename H, typename T>
class LL<H, T>::Reader {
public:
  typedef LL Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename H2 = ::capnp::AnyPointer, typename T2 = ::capnp::AnyPointer>
  typename LL<H2, T2>::Reader asGeneric() {
    return typename LL<H2, T2>::Reader(_reader);
  }

  inline bool hasHead() const;
  inline  ::capnp::ReaderFor<H> getHead() const;

  inline bool hasTail() const;
  inline  ::capnp::ReaderFor<T> getTail() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename H, typename T>
class LL<H, T>::Builder {
public:
  typedef LL Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename H2 = ::capnp::AnyPointer, typename T2 = ::capnp::AnyPointer>
  typename LL<H2, T2>::Builder asGeneric() {
    return typename LL<H2, T2>::Builder(_builder);
  }

  inline bool hasHead();
  inline  ::capnp::BuilderFor<H> getHead();
  inline void setHead( ::capnp::ReaderFor<H> value);
  inline  ::capnp::BuilderFor<H> initHead();
  inline  ::capnp::BuilderFor<H> initHead(unsigned int size);
  inline void adoptHead(::capnp::Orphan<H>&& value);
  inline ::capnp::Orphan<H> disownHead();

  inline bool hasTail();
  inline  ::capnp::BuilderFor<T> getTail();
  inline void setTail( ::capnp::ReaderFor<T> value);
  inline  ::capnp::BuilderFor<T> initTail();
  inline  ::capnp::BuilderFor<T> initTail(unsigned int size);
  inline void adoptTail(::capnp::Orphan<T>&& value);
  inline ::capnp::Orphan<T> disownTail();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename H, typename T>
class LL<H, T>::Pipeline {
public:
  typedef LL Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<H> getHead();
  inline  ::capnp::PipelineFor<T> getTail();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename T>
class Clock<T>::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Clock Calls;
  typedef Clock Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename T2 = ::capnp::AnyPointer>
  typename Clock<T2>::Client asGeneric() {
    return castAs<Clock<T2>>();
  }

  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::Clock<T>::TickParams, typename  ::mas::schema::common::Clock<T>::TickResults>) tickRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

template <typename T>
class Clock<T>::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Clock Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef typename  ::mas::schema::common::Clock<T>::TickParams TickParams;
  typedef typename  ::mas::schema::common::Clock<T>::TickResults TickResults;
  typedef ::capnp::CallContext<TickParams, TickResults> TickContext;
  virtual ::kj::Promise<void> tick(TickContext context);

  inline typename  ::mas::schema::common::Clock<T>::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::common::Clock<T>>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename T>
class Clock<T>::TickParams::Reader {
public:
  typedef TickParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename Clock<T2>::TickParams::Reader asClockGeneric() {
    return typename Clock<T2>::TickParams::Reader(_reader);
  }

  inline bool hasTime() const;
  inline  ::capnp::ReaderFor<T> getTime() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class Clock<T>::TickParams::Builder {
public:
  typedef TickParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename Clock<T2>::TickParams::Builder asClockGeneric() {
    return typename Clock<T2>::TickParams::Builder(_builder);
  }

  inline bool hasTime();
  inline  ::capnp::BuilderFor<T> getTime();
  inline void setTime( ::capnp::ReaderFor<T> value);
  inline  ::capnp::BuilderFor<T> initTime();
  inline  ::capnp::BuilderFor<T> initTime(unsigned int size);
  inline void adoptTime(::capnp::Orphan<T>&& value);
  inline ::capnp::Orphan<T> disownTime();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class Clock<T>::TickParams::Pipeline {
public:
  typedef TickParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<T> getTime();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename T>
class Clock<T>::TickResults::Reader {
public:
  typedef TickResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename Clock<T2>::TickResults::Reader asClockGeneric() {
    return typename Clock<T2>::TickResults::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename T>
class Clock<T>::TickResults::Builder {
public:
  typedef TickResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename T2 = ::capnp::AnyPointer>
  typename Clock<T2>::TickResults::Builder asClockGeneric() {
    return typename Clock<T2>::TickResults::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename T>
class Clock<T>::TickResults::Pipeline {
public:
  typedef TickResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IP::Reader {
public:
  typedef IP Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasAttributes() const;
  inline  ::capnp::List< ::mas::schema::common::IP::KV,  ::capnp::Kind::STRUCT>::Reader getAttributes() const;

  inline bool hasContent() const;
  inline ::capnp::AnyPointer::Reader getContent() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IP::Builder {
public:
  typedef IP Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasAttributes();
  inline  ::capnp::List< ::mas::schema::common::IP::KV,  ::capnp::Kind::STRUCT>::Builder getAttributes();
  inline void setAttributes( ::capnp::List< ::mas::schema::common::IP::KV,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::common::IP::KV,  ::capnp::Kind::STRUCT>::Builder initAttributes(unsigned int size);
  inline void adoptAttributes(::capnp::Orphan< ::capnp::List< ::mas::schema::common::IP::KV,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::IP::KV,  ::capnp::Kind::STRUCT>> disownAttributes();

  inline bool hasContent();
  inline ::capnp::AnyPointer::Builder getContent();
  inline ::capnp::AnyPointer::Builder initContent();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IP::Pipeline {
public:
  typedef IP Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IP::KV::Reader {
public:
  typedef KV Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasKey() const;
  inline  ::capnp::Text::Reader getKey() const;

  inline bool hasValue() const;
  inline ::capnp::AnyPointer::Reader getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IP::KV::Builder {
public:
  typedef KV Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasKey();
  inline  ::capnp::Text::Builder getKey();
  inline void setKey( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initKey(unsigned int size);
  inline void adoptKey(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownKey();

  inline bool hasValue();
  inline ::capnp::AnyPointer::Builder getValue();
  inline ::capnp::AnyPointer::Builder initValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IP::KV::Pipeline {
public:
  typedef KV Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
class Channel<V>::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Channel Calls;
  typedef Channel Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::Client asGeneric() {
    return castAs<Channel<V2>>();
  }

  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::Channel<V>::SetBufferSizeParams, typename  ::mas::schema::common::Channel<V>::SetBufferSizeResults>) setBufferSizeRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::Channel<V>::ReaderParams, typename  ::mas::schema::common::Channel<V>::ReaderResults>) readerRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::Channel<V>::WriterParams, typename  ::mas::schema::common::Channel<V>::WriterResults>) writerRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::Channel<V>::EndpointsParams, typename  ::mas::schema::common::Channel<V>::EndpointsResults>) endpointsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::Channel<V>::SetAutoCloseSemanticsParams, typename  ::mas::schema::common::Channel<V>::SetAutoCloseSemanticsResults>) setAutoCloseSemanticsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::Channel<V>::CloseParams, typename  ::mas::schema::common::Channel<V>::CloseResults>) closeRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

template <typename V>
class Channel<V>::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Channel Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef typename  ::mas::schema::common::Channel<V>::SetBufferSizeParams SetBufferSizeParams;
  typedef typename  ::mas::schema::common::Channel<V>::SetBufferSizeResults SetBufferSizeResults;
  typedef ::capnp::CallContext<SetBufferSizeParams, SetBufferSizeResults> SetBufferSizeContext;
  virtual ::kj::Promise<void> setBufferSize(SetBufferSizeContext context);
  typedef typename  ::mas::schema::common::Channel<V>::ReaderParams ReaderParams;
  typedef typename  ::mas::schema::common::Channel<V>::ReaderResults ReaderResults;
  typedef ::capnp::CallContext<ReaderParams, ReaderResults> ReaderContext;
  virtual ::kj::Promise<void> reader(ReaderContext context);
  typedef typename  ::mas::schema::common::Channel<V>::WriterParams WriterParams;
  typedef typename  ::mas::schema::common::Channel<V>::WriterResults WriterResults;
  typedef ::capnp::CallContext<WriterParams, WriterResults> WriterContext;
  virtual ::kj::Promise<void> writer(WriterContext context);
  typedef typename  ::mas::schema::common::Channel<V>::EndpointsParams EndpointsParams;
  typedef typename  ::mas::schema::common::Channel<V>::EndpointsResults EndpointsResults;
  typedef ::capnp::CallContext<EndpointsParams, EndpointsResults> EndpointsContext;
  virtual ::kj::Promise<void> endpoints(EndpointsContext context);
  typedef typename  ::mas::schema::common::Channel<V>::SetAutoCloseSemanticsParams SetAutoCloseSemanticsParams;
  typedef typename  ::mas::schema::common::Channel<V>::SetAutoCloseSemanticsResults SetAutoCloseSemanticsResults;
  typedef ::capnp::CallContext<SetAutoCloseSemanticsParams, SetAutoCloseSemanticsResults> SetAutoCloseSemanticsContext;
  virtual ::kj::Promise<void> setAutoCloseSemantics(SetAutoCloseSemanticsContext context);
  typedef typename  ::mas::schema::common::Channel<V>::CloseParams CloseParams;
  typedef typename  ::mas::schema::common::Channel<V>::CloseResults CloseResults;
  typedef ::capnp::CallContext<CloseParams, CloseResults> CloseContext;
  virtual ::kj::Promise<void> close(CloseContext context);

  inline typename  ::mas::schema::common::Channel<V>::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::common::Channel<V>>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::Msg::Reader {
public:
  typedef Msg Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::Msg::Reader asChannelGeneric() {
    return typename Channel<V2>::Msg::Reader(_reader);
  }

  inline Which which() const;
  inline bool isValue() const;
  inline bool hasValue() const;
  inline  ::capnp::ReaderFor<V> getValue() const;

  inline bool isDone() const;
  inline  ::capnp::Void getDone() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::Msg::Builder {
public:
  typedef Msg Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::Msg::Builder asChannelGeneric() {
    return typename Channel<V2>::Msg::Builder(_builder);
  }

  inline Which which();
  inline bool isValue();
  inline bool hasValue();
  inline  ::capnp::BuilderFor<V> getValue();
  inline void setValue( ::capnp::ReaderFor<V> value);
  inline  ::capnp::BuilderFor<V> initValue();
  inline  ::capnp::BuilderFor<V> initValue(unsigned int size);
  inline void adoptValue(::capnp::Orphan<V>&& value);
  inline ::capnp::Orphan<V> disownValue();

  inline bool isDone();
  inline  ::capnp::Void getDone();
  inline void setDone( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::Msg::Pipeline {
public:
  typedef Msg Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanReader::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef ChanReader Calls;
  typedef ChanReader Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanReader::Client asChannelGeneric() {
    return castAs<typename Channel<V2>::ChanReader>();
  }

  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::Channel<V>::ChanReader::ReadParams, typename  ::mas::schema::common::Channel<V>::Msg>) readRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::Channel<V>::ChanReader::CloseParams, typename  ::mas::schema::common::Channel<V>::ChanReader::CloseResults>) closeRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

template <typename V>
class Channel<V>::ChanReader::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef ChanReader Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef typename  ::mas::schema::common::Channel<V>::ChanReader::ReadParams ReadParams;
  typedef ::capnp::CallContext<ReadParams, typename  ::mas::schema::common::Channel<V>::Msg> ReadContext;
  virtual ::kj::Promise<void> read(ReadContext context);
  typedef typename  ::mas::schema::common::Channel<V>::ChanReader::CloseParams CloseParams;
  typedef typename  ::mas::schema::common::Channel<V>::ChanReader::CloseResults CloseResults;
  typedef ::capnp::CallContext<CloseParams, CloseResults> CloseContext;
  virtual ::kj::Promise<void> close(CloseContext context);

  inline typename  ::mas::schema::common::Channel<V>::ChanReader::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs<typename  ::mas::schema::common::Channel<V>::ChanReader>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ChanReader::ReadParams::Reader {
public:
  typedef ReadParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanReader::Reader asChannelGeneric() {
    return typename Channel<V2>::ChanReader::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ChanReader::ReadParams::Builder {
public:
  typedef ReadParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanReader::Builder asChannelGeneric() {
    return typename Channel<V2>::ChanReader::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanReader::ReadParams::Pipeline {
public:
  typedef ReadParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ChanReader::CloseParams::Reader {
public:
  typedef CloseParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanReader::Reader asChannelGeneric() {
    return typename Channel<V2>::ChanReader::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ChanReader::CloseParams::Builder {
public:
  typedef CloseParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanReader::Builder asChannelGeneric() {
    return typename Channel<V2>::ChanReader::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanReader::CloseParams::Pipeline {
public:
  typedef CloseParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ChanReader::CloseResults::Reader {
public:
  typedef CloseResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanReader::Reader asChannelGeneric() {
    return typename Channel<V2>::ChanReader::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ChanReader::CloseResults::Builder {
public:
  typedef CloseResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanReader::Builder asChannelGeneric() {
    return typename Channel<V2>::ChanReader::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanReader::CloseResults::Pipeline {
public:
  typedef CloseResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanWriter::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef ChanWriter Calls;
  typedef ChanWriter Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanWriter::Client asChannelGeneric() {
    return castAs<typename Channel<V2>::ChanWriter>();
  }

  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::Channel<V>::Msg, typename  ::mas::schema::common::Channel<V>::ChanWriter::WriteResults>) writeRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::Channel<V>::ChanWriter::CloseParams, typename  ::mas::schema::common::Channel<V>::ChanWriter::CloseResults>) closeRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

template <typename V>
class Channel<V>::ChanWriter::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef ChanWriter Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef typename  ::mas::schema::common::Channel<V>::ChanWriter::WriteResults WriteResults;
  typedef ::capnp::CallContext<typename  ::mas::schema::common::Channel<V>::Msg, WriteResults> WriteContext;
  virtual ::kj::Promise<void> write(WriteContext context);
  typedef typename  ::mas::schema::common::Channel<V>::ChanWriter::CloseParams CloseParams;
  typedef typename  ::mas::schema::common::Channel<V>::ChanWriter::CloseResults CloseResults;
  typedef ::capnp::CallContext<CloseParams, CloseResults> CloseContext;
  virtual ::kj::Promise<void> close(CloseContext context);

  inline typename  ::mas::schema::common::Channel<V>::ChanWriter::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs<typename  ::mas::schema::common::Channel<V>::ChanWriter>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ChanWriter::WriteResults::Reader {
public:
  typedef WriteResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanWriter::Reader asChannelGeneric() {
    return typename Channel<V2>::ChanWriter::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ChanWriter::WriteResults::Builder {
public:
  typedef WriteResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanWriter::Builder asChannelGeneric() {
    return typename Channel<V2>::ChanWriter::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanWriter::WriteResults::Pipeline {
public:
  typedef WriteResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ChanWriter::CloseParams::Reader {
public:
  typedef CloseParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanWriter::Reader asChannelGeneric() {
    return typename Channel<V2>::ChanWriter::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ChanWriter::CloseParams::Builder {
public:
  typedef CloseParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanWriter::Builder asChannelGeneric() {
    return typename Channel<V2>::ChanWriter::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanWriter::CloseParams::Pipeline {
public:
  typedef CloseParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ChanWriter::CloseResults::Reader {
public:
  typedef CloseResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanWriter::Reader asChannelGeneric() {
    return typename Channel<V2>::ChanWriter::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ChanWriter::CloseResults::Builder {
public:
  typedef CloseResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ChanWriter::Builder asChannelGeneric() {
    return typename Channel<V2>::ChanWriter::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ChanWriter::CloseResults::Pipeline {
public:
  typedef CloseResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::SetBufferSizeParams::Reader {
public:
  typedef SetBufferSizeParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::SetBufferSizeParams::Reader asChannelGeneric() {
    return typename Channel<V2>::SetBufferSizeParams::Reader(_reader);
  }

  inline  ::uint64_t getSize() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::SetBufferSizeParams::Builder {
public:
  typedef SetBufferSizeParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::SetBufferSizeParams::Builder asChannelGeneric() {
    return typename Channel<V2>::SetBufferSizeParams::Builder(_builder);
  }

  inline  ::uint64_t getSize();
  inline void setSize( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::SetBufferSizeParams::Pipeline {
public:
  typedef SetBufferSizeParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::SetBufferSizeResults::Reader {
public:
  typedef SetBufferSizeResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::SetBufferSizeResults::Reader asChannelGeneric() {
    return typename Channel<V2>::SetBufferSizeResults::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::SetBufferSizeResults::Builder {
public:
  typedef SetBufferSizeResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::SetBufferSizeResults::Builder asChannelGeneric() {
    return typename Channel<V2>::SetBufferSizeResults::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::SetBufferSizeResults::Pipeline {
public:
  typedef SetBufferSizeResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ReaderParams::Reader {
public:
  typedef ReaderParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ReaderParams::Reader asChannelGeneric() {
    return typename Channel<V2>::ReaderParams::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ReaderParams::Builder {
public:
  typedef ReaderParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ReaderParams::Builder asChannelGeneric() {
    return typename Channel<V2>::ReaderParams::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ReaderParams::Pipeline {
public:
  typedef ReaderParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::ReaderResults::Reader {
public:
  typedef ReaderResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ReaderResults::Reader asChannelGeneric() {
    return typename Channel<V2>::ReaderResults::Reader(_reader);
  }

  inline bool hasR() const;
#if !CAPNP_LITE
  inline typename  ::mas::schema::common::Channel<V>::ChanReader::Client getR() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::ReaderResults::Builder {
public:
  typedef ReaderResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::ReaderResults::Builder asChannelGeneric() {
    return typename Channel<V2>::ReaderResults::Builder(_builder);
  }

  inline bool hasR();
#if !CAPNP_LITE
  inline typename  ::mas::schema::common::Channel<V>::ChanReader::Client getR();
  inline void setR(typename  ::mas::schema::common::Channel<V>::ChanReader::Client&& value);
  inline void setR(typename  ::mas::schema::common::Channel<V>::ChanReader::Client& value);
  inline void adoptR(::capnp::Orphan<typename  ::mas::schema::common::Channel<V>::ChanReader>&& value);
  inline ::capnp::Orphan<typename  ::mas::schema::common::Channel<V>::ChanReader> disownR();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::ReaderResults::Pipeline {
public:
  typedef ReaderResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename  ::mas::schema::common::Channel<V>::ChanReader::Client getR();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::WriterParams::Reader {
public:
  typedef WriterParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::WriterParams::Reader asChannelGeneric() {
    return typename Channel<V2>::WriterParams::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::WriterParams::Builder {
public:
  typedef WriterParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::WriterParams::Builder asChannelGeneric() {
    return typename Channel<V2>::WriterParams::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::WriterParams::Pipeline {
public:
  typedef WriterParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::WriterResults::Reader {
public:
  typedef WriterResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::WriterResults::Reader asChannelGeneric() {
    return typename Channel<V2>::WriterResults::Reader(_reader);
  }

  inline bool hasW() const;
#if !CAPNP_LITE
  inline typename  ::mas::schema::common::Channel<V>::ChanWriter::Client getW() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::WriterResults::Builder {
public:
  typedef WriterResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::WriterResults::Builder asChannelGeneric() {
    return typename Channel<V2>::WriterResults::Builder(_builder);
  }

  inline bool hasW();
#if !CAPNP_LITE
  inline typename  ::mas::schema::common::Channel<V>::ChanWriter::Client getW();
  inline void setW(typename  ::mas::schema::common::Channel<V>::ChanWriter::Client&& value);
  inline void setW(typename  ::mas::schema::common::Channel<V>::ChanWriter::Client& value);
  inline void adoptW(::capnp::Orphan<typename  ::mas::schema::common::Channel<V>::ChanWriter>&& value);
  inline ::capnp::Orphan<typename  ::mas::schema::common::Channel<V>::ChanWriter> disownW();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::WriterResults::Pipeline {
public:
  typedef WriterResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename  ::mas::schema::common::Channel<V>::ChanWriter::Client getW();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::EndpointsParams::Reader {
public:
  typedef EndpointsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::EndpointsParams::Reader asChannelGeneric() {
    return typename Channel<V2>::EndpointsParams::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::EndpointsParams::Builder {
public:
  typedef EndpointsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::EndpointsParams::Builder asChannelGeneric() {
    return typename Channel<V2>::EndpointsParams::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::EndpointsParams::Pipeline {
public:
  typedef EndpointsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::EndpointsResults::Reader {
public:
  typedef EndpointsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::EndpointsResults::Reader asChannelGeneric() {
    return typename Channel<V2>::EndpointsResults::Reader(_reader);
  }

  inline bool hasR() const;
#if !CAPNP_LITE
  inline typename  ::mas::schema::common::Channel<V>::ChanReader::Client getR() const;
#endif  // !CAPNP_LITE

  inline bool hasW() const;
#if !CAPNP_LITE
  inline typename  ::mas::schema::common::Channel<V>::ChanWriter::Client getW() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::EndpointsResults::Builder {
public:
  typedef EndpointsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::EndpointsResults::Builder asChannelGeneric() {
    return typename Channel<V2>::EndpointsResults::Builder(_builder);
  }

  inline bool hasR();
#if !CAPNP_LITE
  inline typename  ::mas::schema::common::Channel<V>::ChanReader::Client getR();
  inline void setR(typename  ::mas::schema::common::Channel<V>::ChanReader::Client&& value);
  inline void setR(typename  ::mas::schema::common::Channel<V>::ChanReader::Client& value);
  inline void adoptR(::capnp::Orphan<typename  ::mas::schema::common::Channel<V>::ChanReader>&& value);
  inline ::capnp::Orphan<typename  ::mas::schema::common::Channel<V>::ChanReader> disownR();
#endif  // !CAPNP_LITE

  inline bool hasW();
#if !CAPNP_LITE
  inline typename  ::mas::schema::common::Channel<V>::ChanWriter::Client getW();
  inline void setW(typename  ::mas::schema::common::Channel<V>::ChanWriter::Client&& value);
  inline void setW(typename  ::mas::schema::common::Channel<V>::ChanWriter::Client& value);
  inline void adoptW(::capnp::Orphan<typename  ::mas::schema::common::Channel<V>::ChanWriter>&& value);
  inline ::capnp::Orphan<typename  ::mas::schema::common::Channel<V>::ChanWriter> disownW();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::EndpointsResults::Pipeline {
public:
  typedef EndpointsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename  ::mas::schema::common::Channel<V>::ChanReader::Client getR();
  inline typename  ::mas::schema::common::Channel<V>::ChanWriter::Client getW();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::SetAutoCloseSemanticsParams::Reader {
public:
  typedef SetAutoCloseSemanticsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::SetAutoCloseSemanticsParams::Reader asChannelGeneric() {
    return typename Channel<V2>::SetAutoCloseSemanticsParams::Reader(_reader);
  }

  inline typename  ::mas::schema::common::Channel<V>::CloseSemantics getCs() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::SetAutoCloseSemanticsParams::Builder {
public:
  typedef SetAutoCloseSemanticsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::SetAutoCloseSemanticsParams::Builder asChannelGeneric() {
    return typename Channel<V2>::SetAutoCloseSemanticsParams::Builder(_builder);
  }

  inline typename  ::mas::schema::common::Channel<V>::CloseSemantics getCs();
  inline void setCs(typename  ::mas::schema::common::Channel<V>::CloseSemantics value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::SetAutoCloseSemanticsParams::Pipeline {
public:
  typedef SetAutoCloseSemanticsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::SetAutoCloseSemanticsResults::Reader {
public:
  typedef SetAutoCloseSemanticsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::SetAutoCloseSemanticsResults::Reader asChannelGeneric() {
    return typename Channel<V2>::SetAutoCloseSemanticsResults::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::SetAutoCloseSemanticsResults::Builder {
public:
  typedef SetAutoCloseSemanticsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::SetAutoCloseSemanticsResults::Builder asChannelGeneric() {
    return typename Channel<V2>::SetAutoCloseSemanticsResults::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::SetAutoCloseSemanticsResults::Pipeline {
public:
  typedef SetAutoCloseSemanticsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::CloseParams::Reader {
public:
  typedef CloseParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::CloseParams::Reader asChannelGeneric() {
    return typename Channel<V2>::CloseParams::Reader(_reader);
  }

  inline bool getWaitForEmptyBuffer() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::CloseParams::Builder {
public:
  typedef CloseParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::CloseParams::Builder asChannelGeneric() {
    return typename Channel<V2>::CloseParams::Builder(_builder);
  }

  inline bool getWaitForEmptyBuffer();
  inline void setWaitForEmptyBuffer(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::CloseParams::Pipeline {
public:
  typedef CloseParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename V>
class Channel<V>::CloseResults::Reader {
public:
  typedef CloseResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::CloseResults::Reader asChannelGeneric() {
    return typename Channel<V2>::CloseResults::Reader(_reader);
  }

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename V>
class Channel<V>::CloseResults::Builder {
public:
  typedef CloseResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename V2 = ::capnp::AnyPointer>
  typename Channel<V2>::CloseResults::Builder asChannelGeneric() {
    return typename Channel<V2>::CloseResults::Builder(_builder);
  }

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename V>
class Channel<V>::CloseResults::Pipeline {
public:
  typedef CloseResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline bool IdInformation::Reader::hasId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool IdInformation::Builder::hasId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader IdInformation::Reader::getId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder IdInformation::Builder::getId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void IdInformation::Builder::setId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder IdInformation::Builder::initId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void IdInformation::Builder::adoptId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> IdInformation::Builder::disownId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool IdInformation::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool IdInformation::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader IdInformation::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder IdInformation::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void IdInformation::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder IdInformation::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void IdInformation::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> IdInformation::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool IdInformation::Reader::hasDescription() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool IdInformation::Builder::hasDescription() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader IdInformation::Reader::getDescription() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder IdInformation::Builder::getDescription() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void IdInformation::Builder::setDescription( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder IdInformation::Builder::initDescription(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void IdInformation::Builder::adoptDescription(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> IdInformation::Builder::disownDescription() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline Identifiable::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Identifiable::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Identifiable::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Identifiable::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Identifiable::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::common::Identifiable::Client& Identifiable::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::common::Identifiable::Client& Identifiable::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool StructuredText::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool StructuredText::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader StructuredText::Reader::getValue() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder StructuredText::Builder::getValue() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void StructuredText::Builder::setValue( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder StructuredText::Builder::initValue(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void StructuredText::Builder::adoptValue(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> StructuredText::Builder::disownValue() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline typename StructuredText::Structure::Reader StructuredText::Reader::getStructure() const {
  return typename StructuredText::Structure::Reader(_reader);
}
inline typename StructuredText::Structure::Builder StructuredText::Builder::getStructure() {
  return typename StructuredText::Structure::Builder(_builder);
}
#if !CAPNP_LITE
inline typename StructuredText::Structure::Pipeline StructuredText::Pipeline::getStructure() {
  return typename StructuredText::Structure::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename StructuredText::Structure::Builder StructuredText::Builder::initStructure() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  return typename StructuredText::Structure::Builder(_builder);
}
inline  ::mas::schema::common::StructuredText::Structure::Which StructuredText::Structure::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::mas::schema::common::StructuredText::Structure::Which StructuredText::Structure::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool StructuredText::Structure::Reader::isNone() const {
  return which() == StructuredText::Structure::NONE;
}
inline bool StructuredText::Structure::Builder::isNone() {
  return which() == StructuredText::Structure::NONE;
}
inline  ::capnp::Void StructuredText::Structure::Reader::getNone() const {
  KJ_IREQUIRE((which() == StructuredText::Structure::NONE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void StructuredText::Structure::Builder::getNone() {
  KJ_IREQUIRE((which() == StructuredText::Structure::NONE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void StructuredText::Structure::Builder::setNone( ::capnp::Void value) {
  _builder.setDataField<StructuredText::Structure::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, StructuredText::Structure::NONE);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool StructuredText::Structure::Reader::isJson() const {
  return which() == StructuredText::Structure::JSON;
}
inline bool StructuredText::Structure::Builder::isJson() {
  return which() == StructuredText::Structure::JSON;
}
inline  ::capnp::Void StructuredText::Structure::Reader::getJson() const {
  KJ_IREQUIRE((which() == StructuredText::Structure::JSON),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void StructuredText::Structure::Builder::getJson() {
  KJ_IREQUIRE((which() == StructuredText::Structure::JSON),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void StructuredText::Structure::Builder::setJson( ::capnp::Void value) {
  _builder.setDataField<StructuredText::Structure::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, StructuredText::Structure::JSON);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool StructuredText::Structure::Reader::isXml() const {
  return which() == StructuredText::Structure::XML;
}
inline bool StructuredText::Structure::Builder::isXml() {
  return which() == StructuredText::Structure::XML;
}
inline  ::capnp::Void StructuredText::Structure::Reader::getXml() const {
  KJ_IREQUIRE((which() == StructuredText::Structure::XML),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void StructuredText::Structure::Builder::getXml() {
  KJ_IREQUIRE((which() == StructuredText::Structure::XML),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void StructuredText::Structure::Builder::setXml( ::capnp::Void value) {
  _builder.setDataField<StructuredText::Structure::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, StructuredText::Structure::XML);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

#if !CAPNP_LITE
inline Callback::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Callback::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Callback::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Callback::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Callback::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::common::Callback::Client& Callback::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::common::Callback::Client& Callback::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
#if !CAPNP_LITE
inline Action::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Action::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Action::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Action::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Action::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::common::Action::Client& Action::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::common::Action::Client& Action::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
#if !CAPNP_LITE
inline Action1::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Action1::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Action1::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Action1::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Action1::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::common::Action1::Client& Action1::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::common::Action1::Client& Action1::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Action1::DoParams::Reader::hasP() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Action1::DoParams::Builder::hasP() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline ::capnp::AnyPointer::Reader Action1::DoParams::Reader::getP() const {
  return ::capnp::AnyPointer::Reader(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder Action1::DoParams::Builder::getP() {
  return ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder Action1::DoParams::Builder::initP() {
  auto result = ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
  result.clear();
  return result;
}

#if !CAPNP_LITE
template <typename Input, typename Output>
inline Factory<Input, Output>::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
template <typename Input, typename Output>
inline Factory<Input, Output>::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename Input, typename Output>
template <typename _t, typename>
inline Factory<Input, Output>::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename Input, typename Output>
template <typename _t, typename>
inline Factory<Input, Output>::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
template <typename Input, typename Output>
inline Factory<Input, Output>::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
template <typename Input, typename Output>
inline typename  ::mas::schema::common::Factory<Input, Output>::Client& Factory<Input, Output>::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
template <typename Input, typename Output>
inline typename  ::mas::schema::common::Factory<Input, Output>::Client& Factory<Input, Output>::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
template <typename Input, typename Output>
inline bool Factory<Input, Output>::ProduceParams::Reader::hasIn() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Input, typename Output>
inline bool Factory<Input, Output>::ProduceParams::Builder::hasIn() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Input, typename Output>
inline  ::capnp::ReaderFor<Input> Factory<Input, Output>::ProduceParams::Reader::getIn() const {
  return ::capnp::_::PointerHelpers<Input>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Input, typename Output>
inline  ::capnp::BuilderFor<Input> Factory<Input, Output>::ProduceParams::Builder::getIn() {
  return ::capnp::_::PointerHelpers<Input>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Input, typename Output>
inline  ::capnp::PipelineFor<Input> Factory<Input, Output>::ProduceParams::Pipeline::getIn() {
  return  ::capnp::PipelineFor<Input>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename Input, typename Output>
inline void Factory<Input, Output>::ProduceParams::Builder::setIn( ::capnp::ReaderFor<Input> value) {
  ::capnp::_::PointerHelpers<Input>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Input, typename Output>
inline  ::capnp::BuilderFor<Input> Factory<Input, Output>::ProduceParams::Builder::initIn() {
  return ::capnp::_::PointerHelpers<Input>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Input, typename Output>
inline  ::capnp::BuilderFor<Input> Factory<Input, Output>::ProduceParams::Builder::initIn(unsigned int size) {
  return ::capnp::_::PointerHelpers<Input>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Input, typename Output>
inline void Factory<Input, Output>::ProduceParams::Builder::adoptIn(
    ::capnp::Orphan<Input>&& value) {
  ::capnp::_::PointerHelpers<Input>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Input, typename Output>
inline ::capnp::Orphan<Input> Factory<Input, Output>::ProduceParams::Builder::disownIn() {
  return ::capnp::_::PointerHelpers<Input>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// Factory<Input, Output>::ProduceParams
template <typename Input, typename Output>
constexpr uint16_t Factory<Input, Output>::ProduceParams::_capnpPrivate::dataWordSize;
template <typename Input, typename Output>
constexpr uint16_t Factory<Input, Output>::ProduceParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Input, typename Output>
constexpr ::capnp::Kind Factory<Input, Output>::ProduceParams::_capnpPrivate::kind;
template <typename Input, typename Output>
constexpr ::capnp::_::RawSchema const* Factory<Input, Output>::ProduceParams::_capnpPrivate::schema;
template <typename Input, typename Output>
const ::capnp::_::RawBrandedSchema::Scope Factory<Input, Output>::ProduceParams::_capnpPrivate::brandScopes[] = {
  { 0xa869f50b8c586ed9, brandBindings + 0, 2, false},
};
template <typename Input, typename Output>
const ::capnp::_::RawBrandedSchema::Binding Factory<Input, Output>::ProduceParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Input>(),
  ::capnp::_::brandBindingFor<Output>(),
};
template <typename Input, typename Output>
const ::capnp::_::RawBrandedSchema Factory<Input, Output>::ProduceParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_fd058bbd1f9508cd, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename Input, typename Output>
inline bool Factory<Input, Output>::ProduceResults::Reader::hasOut() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Input, typename Output>
inline bool Factory<Input, Output>::ProduceResults::Builder::hasOut() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Input, typename Output>
inline  ::capnp::ReaderFor<Output> Factory<Input, Output>::ProduceResults::Reader::getOut() const {
  return ::capnp::_::PointerHelpers<Output>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Input, typename Output>
inline  ::capnp::BuilderFor<Output> Factory<Input, Output>::ProduceResults::Builder::getOut() {
  return ::capnp::_::PointerHelpers<Output>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Input, typename Output>
inline  ::capnp::PipelineFor<Output> Factory<Input, Output>::ProduceResults::Pipeline::getOut() {
  return  ::capnp::PipelineFor<Output>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename Input, typename Output>
inline void Factory<Input, Output>::ProduceResults::Builder::setOut( ::capnp::ReaderFor<Output> value) {
  ::capnp::_::PointerHelpers<Output>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Input, typename Output>
inline  ::capnp::BuilderFor<Output> Factory<Input, Output>::ProduceResults::Builder::initOut() {
  return ::capnp::_::PointerHelpers<Output>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Input, typename Output>
inline  ::capnp::BuilderFor<Output> Factory<Input, Output>::ProduceResults::Builder::initOut(unsigned int size) {
  return ::capnp::_::PointerHelpers<Output>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Input, typename Output>
inline void Factory<Input, Output>::ProduceResults::Builder::adoptOut(
    ::capnp::Orphan<Output>&& value) {
  ::capnp::_::PointerHelpers<Output>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Input, typename Output>
inline ::capnp::Orphan<Output> Factory<Input, Output>::ProduceResults::Builder::disownOut() {
  return ::capnp::_::PointerHelpers<Output>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// Factory<Input, Output>::ProduceResults
template <typename Input, typename Output>
constexpr uint16_t Factory<Input, Output>::ProduceResults::_capnpPrivate::dataWordSize;
template <typename Input, typename Output>
constexpr uint16_t Factory<Input, Output>::ProduceResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Input, typename Output>
constexpr ::capnp::Kind Factory<Input, Output>::ProduceResults::_capnpPrivate::kind;
template <typename Input, typename Output>
constexpr ::capnp::_::RawSchema const* Factory<Input, Output>::ProduceResults::_capnpPrivate::schema;
template <typename Input, typename Output>
const ::capnp::_::RawBrandedSchema::Scope Factory<Input, Output>::ProduceResults::_capnpPrivate::brandScopes[] = {
  { 0xa869f50b8c586ed9, brandBindings + 0, 2, false},
};
template <typename Input, typename Output>
const ::capnp::_::RawBrandedSchema::Binding Factory<Input, Output>::ProduceResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Input>(),
  ::capnp::_::brandBindingFor<Output>(),
};
template <typename Input, typename Output>
const ::capnp::_::RawBrandedSchema Factory<Input, Output>::ProduceResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_d010f77f1bdf0522, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename Input, typename Output>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::Factory<Input, Output>::ProduceParams, typename  ::mas::schema::common::Factory<Input, Output>::ProduceResults>)
Factory<Input, Output>::Client::produceRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::common::Factory<Input, Output>::ProduceParams, typename  ::mas::schema::common::Factory<Input, Output>::ProduceResults>(
      0xa869f50b8c586ed9ull, 0, sizeHint);
}
template <typename Input, typename Output>
::kj::Promise<void> Factory<Input, Output>::Server::produce(ProduceContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "common.capnp:Factory", "produce",
      0xa869f50b8c586ed9ull, 0);
}
template <typename Input, typename Output>
::capnp::Capability::Server::DispatchCallResult Factory<Input, Output>::Server::dispatchCall(
    uint64_t interfaceId, uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (interfaceId) {
    case 0xa869f50b8c586ed9ull:
      return dispatchCallInternal(methodId, context);
    default:
      return internalUnimplemented("common.capnp:Factory", interfaceId);
  }
}
template <typename Input, typename Output>
::capnp::Capability::Server::DispatchCallResult Factory<Input, Output>::Server::dispatchCallInternal(
    uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (methodId) {
    case 0:
      return {
        produce(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::common::Factory<Input, Output>::ProduceParams, typename  ::mas::schema::common::Factory<Input, Output>::ProduceResults>(context)),
        false
      };
    default:
      (void)context;
      return ::capnp::Capability::Server::internalUnimplemented(
          "common.capnp:Factory",
          0xa869f50b8c586ed9ull, methodId);
  }
}
#endif  // !CAPNP_LITE

// Factory<Input, Output>
#if !CAPNP_LITE
template <typename Input, typename Output>
constexpr ::capnp::Kind Factory<Input, Output>::_capnpPrivate::kind;
template <typename Input, typename Output>
constexpr ::capnp::_::RawSchema const* Factory<Input, Output>::_capnpPrivate::schema;
template <typename Input, typename Output>
const ::capnp::_::RawBrandedSchema::Scope Factory<Input, Output>::_capnpPrivate::brandScopes[] = {
  { 0xa869f50b8c586ed9, brandBindings + 0, 2, false},
};
template <typename Input, typename Output>
const ::capnp::_::RawBrandedSchema::Binding Factory<Input, Output>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Input>(),
  ::capnp::_::brandBindingFor<Output>(),
};
template <typename Input, typename Output>
const ::capnp::_::RawBrandedSchema::Dependency Factory<Input, Output>::_capnpPrivate::brandDependencies[] = {
  { 33554432,  ::mas::schema::common::Factory<Input, Output>::ProduceParams::_capnpPrivate::brand() },
  { 50331648,  ::mas::schema::common::Factory<Input, Output>::ProduceResults::_capnpPrivate::brand() },
};
template <typename Input, typename Output>
const ::capnp::_::RawBrandedSchema Factory<Input, Output>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_a869f50b8c586ed9, brandScopes, brandDependencies,
  1, 2, nullptr
};
#endif  // !CAPNP_LITE

inline bool ZmqPipelineAddresses::Reader::hasInput() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ZmqPipelineAddresses::Builder::hasInput() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader ZmqPipelineAddresses::Reader::getInput() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder ZmqPipelineAddresses::Builder::getInput() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ZmqPipelineAddresses::Builder::setInput( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder ZmqPipelineAddresses::Builder::initInput(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ZmqPipelineAddresses::Builder::adoptInput(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> ZmqPipelineAddresses::Builder::disownInput() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ZmqPipelineAddresses::Reader::hasOutput() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool ZmqPipelineAddresses::Builder::hasOutput() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader ZmqPipelineAddresses::Reader::getOutput() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder ZmqPipelineAddresses::Builder::getOutput() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void ZmqPipelineAddresses::Builder::setOutput( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder ZmqPipelineAddresses::Builder::initOutput(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void ZmqPipelineAddresses::Builder::adoptOutput(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> ZmqPipelineAddresses::Builder::disownOutput() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
template <typename Object>
inline CapHolder<Object>::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
template <typename Object>
inline CapHolder<Object>::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename Object>
template <typename _t, typename>
inline CapHolder<Object>::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename Object>
template <typename _t, typename>
inline CapHolder<Object>::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
template <typename Object>
inline CapHolder<Object>::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
template <typename Object>
inline typename  ::mas::schema::common::CapHolder<Object>::Client& CapHolder<Object>::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
template <typename Object>
inline typename  ::mas::schema::common::CapHolder<Object>::Client& CapHolder<Object>::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
// CapHolder<Object>::CapParams
template <typename Object>
constexpr uint16_t CapHolder<Object>::CapParams::_capnpPrivate::dataWordSize;
template <typename Object>
constexpr uint16_t CapHolder<Object>::CapParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Object>
constexpr ::capnp::Kind CapHolder<Object>::CapParams::_capnpPrivate::kind;
template <typename Object>
constexpr ::capnp::_::RawSchema const* CapHolder<Object>::CapParams::_capnpPrivate::schema;
template <typename Object>
const ::capnp::_::RawBrandedSchema::Scope CapHolder<Object>::CapParams::_capnpPrivate::brandScopes[] = {
  { 0xcac9c6537df1a097, brandBindings + 0, 1, false},
};
template <typename Object>
const ::capnp::_::RawBrandedSchema::Binding CapHolder<Object>::CapParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Object>(),
};
template <typename Object>
const ::capnp::_::RawBrandedSchema CapHolder<Object>::CapParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_da52b34d937fa814, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename Object>
inline bool CapHolder<Object>::CapResults::Reader::hasObject() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Object>
inline bool CapHolder<Object>::CapResults::Builder::hasObject() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Object>
inline  ::capnp::ReaderFor<Object> CapHolder<Object>::CapResults::Reader::getObject() const {
  return ::capnp::_::PointerHelpers<Object>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Object>
inline  ::capnp::BuilderFor<Object> CapHolder<Object>::CapResults::Builder::getObject() {
  return ::capnp::_::PointerHelpers<Object>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Object>
inline  ::capnp::PipelineFor<Object> CapHolder<Object>::CapResults::Pipeline::getObject() {
  return  ::capnp::PipelineFor<Object>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename Object>
inline void CapHolder<Object>::CapResults::Builder::setObject( ::capnp::ReaderFor<Object> value) {
  ::capnp::_::PointerHelpers<Object>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Object>
inline  ::capnp::BuilderFor<Object> CapHolder<Object>::CapResults::Builder::initObject() {
  return ::capnp::_::PointerHelpers<Object>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Object>
inline  ::capnp::BuilderFor<Object> CapHolder<Object>::CapResults::Builder::initObject(unsigned int size) {
  return ::capnp::_::PointerHelpers<Object>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Object>
inline void CapHolder<Object>::CapResults::Builder::adoptObject(
    ::capnp::Orphan<Object>&& value) {
  ::capnp::_::PointerHelpers<Object>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Object>
inline ::capnp::Orphan<Object> CapHolder<Object>::CapResults::Builder::disownObject() {
  return ::capnp::_::PointerHelpers<Object>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// CapHolder<Object>::CapResults
template <typename Object>
constexpr uint16_t CapHolder<Object>::CapResults::_capnpPrivate::dataWordSize;
template <typename Object>
constexpr uint16_t CapHolder<Object>::CapResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Object>
constexpr ::capnp::Kind CapHolder<Object>::CapResults::_capnpPrivate::kind;
template <typename Object>
constexpr ::capnp::_::RawSchema const* CapHolder<Object>::CapResults::_capnpPrivate::schema;
template <typename Object>
const ::capnp::_::RawBrandedSchema::Scope CapHolder<Object>::CapResults::_capnpPrivate::brandScopes[] = {
  { 0xcac9c6537df1a097, brandBindings + 0, 1, false},
};
template <typename Object>
const ::capnp::_::RawBrandedSchema::Binding CapHolder<Object>::CapResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Object>(),
};
template <typename Object>
const ::capnp::_::RawBrandedSchema CapHolder<Object>::CapResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_dc9b0f483595691f, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// CapHolder<Object>::ReleaseParams
template <typename Object>
constexpr uint16_t CapHolder<Object>::ReleaseParams::_capnpPrivate::dataWordSize;
template <typename Object>
constexpr uint16_t CapHolder<Object>::ReleaseParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Object>
constexpr ::capnp::Kind CapHolder<Object>::ReleaseParams::_capnpPrivate::kind;
template <typename Object>
constexpr ::capnp::_::RawSchema const* CapHolder<Object>::ReleaseParams::_capnpPrivate::schema;
template <typename Object>
const ::capnp::_::RawBrandedSchema::Scope CapHolder<Object>::ReleaseParams::_capnpPrivate::brandScopes[] = {
  { 0xcac9c6537df1a097, brandBindings + 0, 1, false},
};
template <typename Object>
const ::capnp::_::RawBrandedSchema::Binding CapHolder<Object>::ReleaseParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Object>(),
};
template <typename Object>
const ::capnp::_::RawBrandedSchema CapHolder<Object>::ReleaseParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_82449708d4fd120d, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// CapHolder<Object>::ReleaseResults
template <typename Object>
constexpr uint16_t CapHolder<Object>::ReleaseResults::_capnpPrivate::dataWordSize;
template <typename Object>
constexpr uint16_t CapHolder<Object>::ReleaseResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Object>
constexpr ::capnp::Kind CapHolder<Object>::ReleaseResults::_capnpPrivate::kind;
template <typename Object>
constexpr ::capnp::_::RawSchema const* CapHolder<Object>::ReleaseResults::_capnpPrivate::schema;
template <typename Object>
const ::capnp::_::RawBrandedSchema::Scope CapHolder<Object>::ReleaseResults::_capnpPrivate::brandScopes[] = {
  { 0xcac9c6537df1a097, brandBindings + 0, 1, false},
};
template <typename Object>
const ::capnp::_::RawBrandedSchema::Binding CapHolder<Object>::ReleaseResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Object>(),
};
template <typename Object>
const ::capnp::_::RawBrandedSchema CapHolder<Object>::ReleaseResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_c1374ccca01e2b53, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename Object>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::CapHolder<Object>::CapParams, typename  ::mas::schema::common::CapHolder<Object>::CapResults>)
CapHolder<Object>::Client::capRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::common::CapHolder<Object>::CapParams, typename  ::mas::schema::common::CapHolder<Object>::CapResults>(
      0xcac9c6537df1a097ull, 0, sizeHint);
}
template <typename Object>
::kj::Promise<void> CapHolder<Object>::Server::cap(CapContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "common.capnp:CapHolder", "cap",
      0xcac9c6537df1a097ull, 0);
}
template <typename Object>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::CapHolder<Object>::ReleaseParams, typename  ::mas::schema::common::CapHolder<Object>::ReleaseResults>)
CapHolder<Object>::Client::releaseRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::common::CapHolder<Object>::ReleaseParams, typename  ::mas::schema::common::CapHolder<Object>::ReleaseResults>(
      0xcac9c6537df1a097ull, 1, sizeHint);
}
template <typename Object>
::kj::Promise<void> CapHolder<Object>::Server::release(ReleaseContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "common.capnp:CapHolder", "release",
      0xcac9c6537df1a097ull, 1);
}
template <typename Object>
::capnp::Capability::Server::DispatchCallResult CapHolder<Object>::Server::dispatchCall(
    uint64_t interfaceId, uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (interfaceId) {
    case 0xcac9c6537df1a097ull:
      return dispatchCallInternal(methodId, context);
    default:
      return internalUnimplemented("common.capnp:CapHolder", interfaceId);
  }
}
template <typename Object>
::capnp::Capability::Server::DispatchCallResult CapHolder<Object>::Server::dispatchCallInternal(
    uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (methodId) {
    case 0:
      return {
        cap(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::common::CapHolder<Object>::CapParams, typename  ::mas::schema::common::CapHolder<Object>::CapResults>(context)),
        false
      };
    case 1:
      return {
        release(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::common::CapHolder<Object>::ReleaseParams, typename  ::mas::schema::common::CapHolder<Object>::ReleaseResults>(context)),
        false
      };
    default:
      (void)context;
      return ::capnp::Capability::Server::internalUnimplemented(
          "common.capnp:CapHolder",
          0xcac9c6537df1a097ull, methodId);
  }
}
#endif  // !CAPNP_LITE

// CapHolder<Object>
#if !CAPNP_LITE
template <typename Object>
constexpr ::capnp::Kind CapHolder<Object>::_capnpPrivate::kind;
template <typename Object>
constexpr ::capnp::_::RawSchema const* CapHolder<Object>::_capnpPrivate::schema;
template <typename Object>
const ::capnp::_::RawBrandedSchema::Scope CapHolder<Object>::_capnpPrivate::brandScopes[] = {
  { 0xcac9c6537df1a097, brandBindings + 0, 1, false},
};
template <typename Object>
const ::capnp::_::RawBrandedSchema::Binding CapHolder<Object>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Object>(),
};
template <typename Object>
const ::capnp::_::RawBrandedSchema::Dependency CapHolder<Object>::_capnpPrivate::brandDependencies[] = {
  { 33554432,  ::mas::schema::common::CapHolder<Object>::CapParams::_capnpPrivate::brand() },
  { 33554433,  ::mas::schema::common::CapHolder<Object>::ReleaseParams::_capnpPrivate::brand() },
  { 50331648,  ::mas::schema::common::CapHolder<Object>::CapResults::_capnpPrivate::brand() },
  { 50331649,  ::mas::schema::common::CapHolder<Object>::ReleaseResults::_capnpPrivate::brand() },
};
template <typename Object>
const ::capnp::_::RawBrandedSchema CapHolder<Object>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_cac9c6537df1a097, brandScopes, brandDependencies,
  1, 4, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
inline IdentifiableHolder::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline IdentifiableHolder::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline IdentifiableHolder::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline IdentifiableHolder::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline IdentifiableHolder::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::common::IdentifiableHolder::Client& IdentifiableHolder::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::common::IdentifiableHolder::Client& IdentifiableHolder::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool IdentifiableHolder::CapResults::Reader::hasCap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool IdentifiableHolder::CapResults::Builder::hasCap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::common::Identifiable::Client IdentifiableHolder::CapResults::Reader::getCap() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::Identifiable::Client IdentifiableHolder::CapResults::Builder::getCap() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::common::Identifiable::Client IdentifiableHolder::CapResults::Pipeline::getCap() {
  return  ::mas::schema::common::Identifiable::Client(_typeless.getPointerField(0).asCap());
}
inline void IdentifiableHolder::CapResults::Builder::setCap( ::mas::schema::common::Identifiable::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void IdentifiableHolder::CapResults::Builder::setCap( ::mas::schema::common::Identifiable::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void IdentifiableHolder::CapResults::Builder::adoptCap(
    ::capnp::Orphan< ::mas::schema::common::Identifiable>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::common::Identifiable> IdentifiableHolder::CapResults::Builder::disownCap() {
  return ::capnp::_::PointerHelpers< ::mas::schema::common::Identifiable>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

template <typename PointerType>
inline bool ListEntry<PointerType>::Reader::hasEntry() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename PointerType>
inline bool ListEntry<PointerType>::Builder::hasEntry() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename PointerType>
inline  ::capnp::ReaderFor<PointerType> ListEntry<PointerType>::Reader::getEntry() const {
  return ::capnp::_::PointerHelpers<PointerType>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename PointerType>
inline  ::capnp::BuilderFor<PointerType> ListEntry<PointerType>::Builder::getEntry() {
  return ::capnp::_::PointerHelpers<PointerType>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename PointerType>
inline  ::capnp::PipelineFor<PointerType> ListEntry<PointerType>::Pipeline::getEntry() {
  return  ::capnp::PipelineFor<PointerType>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename PointerType>
inline void ListEntry<PointerType>::Builder::setEntry( ::capnp::ReaderFor<PointerType> value) {
  ::capnp::_::PointerHelpers<PointerType>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename PointerType>
inline  ::capnp::BuilderFor<PointerType> ListEntry<PointerType>::Builder::initEntry() {
  return ::capnp::_::PointerHelpers<PointerType>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename PointerType>
inline  ::capnp::BuilderFor<PointerType> ListEntry<PointerType>::Builder::initEntry(unsigned int size) {
  return ::capnp::_::PointerHelpers<PointerType>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename PointerType>
inline void ListEntry<PointerType>::Builder::adoptEntry(
    ::capnp::Orphan<PointerType>&& value) {
  ::capnp::_::PointerHelpers<PointerType>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename PointerType>
inline ::capnp::Orphan<PointerType> ListEntry<PointerType>::Builder::disownEntry() {
  return ::capnp::_::PointerHelpers<PointerType>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// ListEntry<PointerType>
template <typename PointerType>
constexpr uint16_t ListEntry<PointerType>::_capnpPrivate::dataWordSize;
template <typename PointerType>
constexpr uint16_t ListEntry<PointerType>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename PointerType>
constexpr ::capnp::Kind ListEntry<PointerType>::_capnpPrivate::kind;
template <typename PointerType>
constexpr ::capnp::_::RawSchema const* ListEntry<PointerType>::_capnpPrivate::schema;
template <typename PointerType>
const ::capnp::_::RawBrandedSchema::Scope ListEntry<PointerType>::_capnpPrivate::brandScopes[] = {
  { 0xc201bf46dd40051e, brandBindings + 0, 1, false},
};
template <typename PointerType>
const ::capnp::_::RawBrandedSchema::Binding ListEntry<PointerType>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<PointerType>(),
};
template <typename PointerType>
const ::capnp::_::RawBrandedSchema ListEntry<PointerType>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_c201bf46dd40051e, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
inline Stopable::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Stopable::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Stopable::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Stopable::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Stopable::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::common::Stopable::Client& Stopable::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::common::Stopable::Client& Stopable::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
template <typename F, typename S>
inline bool Pair<F, S>::Reader::hasFst() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename F, typename S>
inline bool Pair<F, S>::Builder::hasFst() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename F, typename S>
inline  ::capnp::ReaderFor<F> Pair<F, S>::Reader::getFst() const {
  return ::capnp::_::PointerHelpers<F>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename F, typename S>
inline  ::capnp::BuilderFor<F> Pair<F, S>::Builder::getFst() {
  return ::capnp::_::PointerHelpers<F>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename F, typename S>
inline  ::capnp::PipelineFor<F> Pair<F, S>::Pipeline::getFst() {
  return  ::capnp::PipelineFor<F>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename F, typename S>
inline void Pair<F, S>::Builder::setFst( ::capnp::ReaderFor<F> value) {
  ::capnp::_::PointerHelpers<F>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename F, typename S>
inline  ::capnp::BuilderFor<F> Pair<F, S>::Builder::initFst() {
  return ::capnp::_::PointerHelpers<F>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename F, typename S>
inline  ::capnp::BuilderFor<F> Pair<F, S>::Builder::initFst(unsigned int size) {
  return ::capnp::_::PointerHelpers<F>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename F, typename S>
inline void Pair<F, S>::Builder::adoptFst(
    ::capnp::Orphan<F>&& value) {
  ::capnp::_::PointerHelpers<F>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename F, typename S>
inline ::capnp::Orphan<F> Pair<F, S>::Builder::disownFst() {
  return ::capnp::_::PointerHelpers<F>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename F, typename S>
inline bool Pair<F, S>::Reader::hasSnd() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename F, typename S>
inline bool Pair<F, S>::Builder::hasSnd() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename F, typename S>
inline  ::capnp::ReaderFor<S> Pair<F, S>::Reader::getSnd() const {
  return ::capnp::_::PointerHelpers<S>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename F, typename S>
inline  ::capnp::BuilderFor<S> Pair<F, S>::Builder::getSnd() {
  return ::capnp::_::PointerHelpers<S>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename F, typename S>
inline  ::capnp::PipelineFor<S> Pair<F, S>::Pipeline::getSnd() {
  return  ::capnp::PipelineFor<S>(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
template <typename F, typename S>
inline void Pair<F, S>::Builder::setSnd( ::capnp::ReaderFor<S> value) {
  ::capnp::_::PointerHelpers<S>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename F, typename S>
inline  ::capnp::BuilderFor<S> Pair<F, S>::Builder::initSnd() {
  return ::capnp::_::PointerHelpers<S>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename F, typename S>
inline  ::capnp::BuilderFor<S> Pair<F, S>::Builder::initSnd(unsigned int size) {
  return ::capnp::_::PointerHelpers<S>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
template <typename F, typename S>
inline void Pair<F, S>::Builder::adoptSnd(
    ::capnp::Orphan<S>&& value) {
  ::capnp::_::PointerHelpers<S>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename F, typename S>
inline ::capnp::Orphan<S> Pair<F, S>::Builder::disownSnd() {
  return ::capnp::_::PointerHelpers<S>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

// Pair<F, S>
template <typename F, typename S>
constexpr uint16_t Pair<F, S>::_capnpPrivate::dataWordSize;
template <typename F, typename S>
constexpr uint16_t Pair<F, S>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename F, typename S>
constexpr ::capnp::Kind Pair<F, S>::_capnpPrivate::kind;
template <typename F, typename S>
constexpr ::capnp::_::RawSchema const* Pair<F, S>::_capnpPrivate::schema;
template <typename F, typename S>
const ::capnp::_::RawBrandedSchema::Scope Pair<F, S>::_capnpPrivate::brandScopes[] = {
  { 0xb9d4864725174733, brandBindings + 0, 2, false},
};
template <typename F, typename S>
const ::capnp::_::RawBrandedSchema::Binding Pair<F, S>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<F>(),
  ::capnp::_::brandBindingFor<S>(),
};
template <typename F, typename S>
const ::capnp::_::RawBrandedSchema Pair<F, S>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_b9d4864725174733, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename H, typename T>
inline bool LL<H, T>::Reader::hasHead() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename H, typename T>
inline bool LL<H, T>::Builder::hasHead() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename H, typename T>
inline  ::capnp::ReaderFor<H> LL<H, T>::Reader::getHead() const {
  return ::capnp::_::PointerHelpers<H>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename H, typename T>
inline  ::capnp::BuilderFor<H> LL<H, T>::Builder::getHead() {
  return ::capnp::_::PointerHelpers<H>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename H, typename T>
inline  ::capnp::PipelineFor<H> LL<H, T>::Pipeline::getHead() {
  return  ::capnp::PipelineFor<H>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename H, typename T>
inline void LL<H, T>::Builder::setHead( ::capnp::ReaderFor<H> value) {
  ::capnp::_::PointerHelpers<H>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename H, typename T>
inline  ::capnp::BuilderFor<H> LL<H, T>::Builder::initHead() {
  return ::capnp::_::PointerHelpers<H>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename H, typename T>
inline  ::capnp::BuilderFor<H> LL<H, T>::Builder::initHead(unsigned int size) {
  return ::capnp::_::PointerHelpers<H>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename H, typename T>
inline void LL<H, T>::Builder::adoptHead(
    ::capnp::Orphan<H>&& value) {
  ::capnp::_::PointerHelpers<H>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename H, typename T>
inline ::capnp::Orphan<H> LL<H, T>::Builder::disownHead() {
  return ::capnp::_::PointerHelpers<H>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename H, typename T>
inline bool LL<H, T>::Reader::hasTail() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename H, typename T>
inline bool LL<H, T>::Builder::hasTail() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename H, typename T>
inline  ::capnp::ReaderFor<T> LL<H, T>::Reader::getTail() const {
  return ::capnp::_::PointerHelpers<T>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename H, typename T>
inline  ::capnp::BuilderFor<T> LL<H, T>::Builder::getTail() {
  return ::capnp::_::PointerHelpers<T>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename H, typename T>
inline  ::capnp::PipelineFor<T> LL<H, T>::Pipeline::getTail() {
  return  ::capnp::PipelineFor<T>(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
template <typename H, typename T>
inline void LL<H, T>::Builder::setTail( ::capnp::ReaderFor<T> value) {
  ::capnp::_::PointerHelpers<T>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename H, typename T>
inline  ::capnp::BuilderFor<T> LL<H, T>::Builder::initTail() {
  return ::capnp::_::PointerHelpers<T>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename H, typename T>
inline  ::capnp::BuilderFor<T> LL<H, T>::Builder::initTail(unsigned int size) {
  return ::capnp::_::PointerHelpers<T>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
template <typename H, typename T>
inline void LL<H, T>::Builder::adoptTail(
    ::capnp::Orphan<T>&& value) {
  ::capnp::_::PointerHelpers<T>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename H, typename T>
inline ::capnp::Orphan<T> LL<H, T>::Builder::disownTail() {
  return ::capnp::_::PointerHelpers<T>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

// LL<H, T>
template <typename H, typename T>
constexpr uint16_t LL<H, T>::_capnpPrivate::dataWordSize;
template <typename H, typename T>
constexpr uint16_t LL<H, T>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename H, typename T>
constexpr ::capnp::Kind LL<H, T>::_capnpPrivate::kind;
template <typename H, typename T>
constexpr ::capnp::_::RawSchema const* LL<H, T>::_capnpPrivate::schema;
template <typename H, typename T>
const ::capnp::_::RawBrandedSchema::Scope LL<H, T>::_capnpPrivate::brandScopes[] = {
  { 0xd67792aa3fc241be, brandBindings + 0, 2, false},
};
template <typename H, typename T>
const ::capnp::_::RawBrandedSchema::Binding LL<H, T>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<H>(),
  ::capnp::_::brandBindingFor<T>(),
};
template <typename H, typename T>
const ::capnp::_::RawBrandedSchema LL<H, T>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_d67792aa3fc241be, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename T>
inline Clock<T>::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
template <typename T>
inline Clock<T>::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename T>
template <typename _t, typename>
inline Clock<T>::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename T>
template <typename _t, typename>
inline Clock<T>::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
template <typename T>
inline Clock<T>::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
template <typename T>
inline typename  ::mas::schema::common::Clock<T>::Client& Clock<T>::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
template <typename T>
inline typename  ::mas::schema::common::Clock<T>::Client& Clock<T>::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
template <typename T>
inline bool Clock<T>::TickParams::Reader::hasTime() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline bool Clock<T>::TickParams::Builder::hasTime() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename T>
inline  ::capnp::ReaderFor<T> Clock<T>::TickParams::Reader::getTime() const {
  return ::capnp::_::PointerHelpers<T>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline  ::capnp::BuilderFor<T> Clock<T>::TickParams::Builder::getTime() {
  return ::capnp::_::PointerHelpers<T>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename T>
inline  ::capnp::PipelineFor<T> Clock<T>::TickParams::Pipeline::getTime() {
  return  ::capnp::PipelineFor<T>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename T>
inline void Clock<T>::TickParams::Builder::setTime( ::capnp::ReaderFor<T> value) {
  ::capnp::_::PointerHelpers<T>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename T>
inline  ::capnp::BuilderFor<T> Clock<T>::TickParams::Builder::initTime() {
  return ::capnp::_::PointerHelpers<T>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename T>
inline  ::capnp::BuilderFor<T> Clock<T>::TickParams::Builder::initTime(unsigned int size) {
  return ::capnp::_::PointerHelpers<T>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename T>
inline void Clock<T>::TickParams::Builder::adoptTime(
    ::capnp::Orphan<T>&& value) {
  ::capnp::_::PointerHelpers<T>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename T>
inline ::capnp::Orphan<T> Clock<T>::TickParams::Builder::disownTime() {
  return ::capnp::_::PointerHelpers<T>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// Clock<T>::TickParams
template <typename T>
constexpr uint16_t Clock<T>::TickParams::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t Clock<T>::TickParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind Clock<T>::TickParams::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* Clock<T>::TickParams::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope Clock<T>::TickParams::_capnpPrivate::brandScopes[] = {
  { 0xa8b91e2c1f8c929a, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding Clock<T>::TickParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema Clock<T>::TickParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_fd0735841a7da108, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Clock<T>::TickResults
template <typename T>
constexpr uint16_t Clock<T>::TickResults::_capnpPrivate::dataWordSize;
template <typename T>
constexpr uint16_t Clock<T>::TickResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind Clock<T>::TickResults::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* Clock<T>::TickResults::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope Clock<T>::TickResults::_capnpPrivate::brandScopes[] = {
  { 0xa8b91e2c1f8c929a, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding Clock<T>::TickResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema Clock<T>::TickResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_c953edb8b6293faf, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename T>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::Clock<T>::TickParams, typename  ::mas::schema::common::Clock<T>::TickResults>)
Clock<T>::Client::tickRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::common::Clock<T>::TickParams, typename  ::mas::schema::common::Clock<T>::TickResults>(
      0xa8b91e2c1f8c929aull, 0, sizeHint);
}
template <typename T>
::kj::Promise<void> Clock<T>::Server::tick(TickContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "common.capnp:Clock", "tick",
      0xa8b91e2c1f8c929aull, 0);
}
template <typename T>
::capnp::Capability::Server::DispatchCallResult Clock<T>::Server::dispatchCall(
    uint64_t interfaceId, uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (interfaceId) {
    case 0xa8b91e2c1f8c929aull:
      return dispatchCallInternal(methodId, context);
    default:
      return internalUnimplemented("common.capnp:Clock", interfaceId);
  }
}
template <typename T>
::capnp::Capability::Server::DispatchCallResult Clock<T>::Server::dispatchCallInternal(
    uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (methodId) {
    case 0:
      return {
        tick(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::common::Clock<T>::TickParams, typename  ::mas::schema::common::Clock<T>::TickResults>(context)),
        false
      };
    default:
      (void)context;
      return ::capnp::Capability::Server::internalUnimplemented(
          "common.capnp:Clock",
          0xa8b91e2c1f8c929aull, methodId);
  }
}
#endif  // !CAPNP_LITE

// Clock<T>
#if !CAPNP_LITE
template <typename T>
constexpr ::capnp::Kind Clock<T>::_capnpPrivate::kind;
template <typename T>
constexpr ::capnp::_::RawSchema const* Clock<T>::_capnpPrivate::schema;
template <typename T>
const ::capnp::_::RawBrandedSchema::Scope Clock<T>::_capnpPrivate::brandScopes[] = {
  { 0xa8b91e2c1f8c929a, brandBindings + 0, 1, false},
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Binding Clock<T>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<T>(),
};
template <typename T>
const ::capnp::_::RawBrandedSchema::Dependency Clock<T>::_capnpPrivate::brandDependencies[] = {
  { 33554432,  ::mas::schema::common::Clock<T>::TickParams::_capnpPrivate::brand() },
  { 50331648,  ::mas::schema::common::Clock<T>::TickResults::_capnpPrivate::brand() },
};
template <typename T>
const ::capnp::_::RawBrandedSchema Clock<T>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_a8b91e2c1f8c929a, brandScopes, brandDependencies,
  1, 2, nullptr
};
#endif  // !CAPNP_LITE

inline bool IP::Reader::hasAttributes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool IP::Builder::hasAttributes() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::common::IP::KV,  ::capnp::Kind::STRUCT>::Reader IP::Reader::getAttributes() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IP::KV,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::common::IP::KV,  ::capnp::Kind::STRUCT>::Builder IP::Builder::getAttributes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IP::KV,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void IP::Builder::setAttributes( ::capnp::List< ::mas::schema::common::IP::KV,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IP::KV,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::common::IP::KV,  ::capnp::Kind::STRUCT>::Builder IP::Builder::initAttributes(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IP::KV,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void IP::Builder::adoptAttributes(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::common::IP::KV,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IP::KV,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::common::IP::KV,  ::capnp::Kind::STRUCT>> IP::Builder::disownAttributes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::common::IP::KV,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool IP::Reader::hasContent() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool IP::Builder::hasContent() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline ::capnp::AnyPointer::Reader IP::Reader::getContent() const {
  return ::capnp::AnyPointer::Reader(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder IP::Builder::getContent() {
  return ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder IP::Builder::initContent() {
  auto result = ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
  result.clear();
  return result;
}

inline bool IP::KV::Reader::hasKey() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool IP::KV::Builder::hasKey() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader IP::KV::Reader::getKey() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder IP::KV::Builder::getKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void IP::KV::Builder::setKey( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder IP::KV::Builder::initKey(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void IP::KV::Builder::adoptKey(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> IP::KV::Builder::disownKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool IP::KV::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool IP::KV::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline ::capnp::AnyPointer::Reader IP::KV::Reader::getValue() const {
  return ::capnp::AnyPointer::Reader(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder IP::KV::Builder::getValue() {
  return ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder IP::KV::Builder::initValue() {
  auto result = ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
  result.clear();
  return result;
}

#if !CAPNP_LITE
template <typename V>
inline Channel<V>::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
template <typename V>
inline Channel<V>::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename V>
template <typename _t, typename>
inline Channel<V>::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename V>
template <typename _t, typename>
inline Channel<V>::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
template <typename V>
inline Channel<V>::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
template <typename V>
inline typename  ::mas::schema::common::Channel<V>::Client& Channel<V>::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
template <typename V>
inline typename  ::mas::schema::common::Channel<V>::Client& Channel<V>::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
template <typename V>
inline typename  ::mas::schema::common::Channel<V>::Msg::Which Channel<V>::Msg::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename V>
inline typename  ::mas::schema::common::Channel<V>::Msg::Which Channel<V>::Msg::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename V>
inline bool Channel<V>::Msg::Reader::isValue() const {
  return which() == Channel<V>::Msg::VALUE;
}
template <typename V>
inline bool Channel<V>::Msg::Builder::isValue() {
  return which() == Channel<V>::Msg::VALUE;
}
template <typename V>
inline bool Channel<V>::Msg::Reader::hasValue() const {
  if (which() != Channel<V>::Msg::VALUE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline bool Channel<V>::Msg::Builder::hasValue() {
  if (which() != Channel<V>::Msg::VALUE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline  ::capnp::ReaderFor<V> Channel<V>::Msg::Reader::getValue() const {
  KJ_IREQUIRE((which() == Channel<V>::Msg::VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<V>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline  ::capnp::BuilderFor<V> Channel<V>::Msg::Builder::getValue() {
  KJ_IREQUIRE((which() == Channel<V>::Msg::VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<V>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline void Channel<V>::Msg::Builder::setValue( ::capnp::ReaderFor<V> value) {
  _builder.setDataField<Channel<V>::Msg::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Channel<V>::Msg::VALUE);
  ::capnp::_::PointerHelpers<V>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename V>
inline  ::capnp::BuilderFor<V> Channel<V>::Msg::Builder::initValue() {
  _builder.setDataField<Channel<V>::Msg::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Channel<V>::Msg::VALUE);
  return ::capnp::_::PointerHelpers<V>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline  ::capnp::BuilderFor<V> Channel<V>::Msg::Builder::initValue(unsigned int size) {
  _builder.setDataField<Channel<V>::Msg::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Channel<V>::Msg::VALUE);
  return ::capnp::_::PointerHelpers<V>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename V>
inline void Channel<V>::Msg::Builder::adoptValue(
    ::capnp::Orphan<V>&& value) {
  _builder.setDataField<Channel<V>::Msg::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Channel<V>::Msg::VALUE);
  ::capnp::_::PointerHelpers<V>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename V>
inline ::capnp::Orphan<V> Channel<V>::Msg::Builder::disownValue() {
  KJ_IREQUIRE((which() == Channel<V>::Msg::VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers<V>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename V>
inline bool Channel<V>::Msg::Reader::isDone() const {
  return which() == Channel<V>::Msg::DONE;
}
template <typename V>
inline bool Channel<V>::Msg::Builder::isDone() {
  return which() == Channel<V>::Msg::DONE;
}
template <typename V>
inline  ::capnp::Void Channel<V>::Msg::Reader::getDone() const {
  KJ_IREQUIRE((which() == Channel<V>::Msg::DONE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename V>
inline  ::capnp::Void Channel<V>::Msg::Builder::getDone() {
  KJ_IREQUIRE((which() == Channel<V>::Msg::DONE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename V>
inline void Channel<V>::Msg::Builder::setDone( ::capnp::Void value) {
  _builder.setDataField<Channel<V>::Msg::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Channel<V>::Msg::DONE);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

// Channel<V>::Msg
template <typename V>
constexpr uint16_t Channel<V>::Msg::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::Msg::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename V>
constexpr ::capnp::Kind Channel<V>::Msg::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::Msg::_capnpPrivate::schema;
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::Msg::_capnpPrivate::brandScopes[] = {
  { 0xf0c0f9413a3083be, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::Msg::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::Msg::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_876b422c6839e6b2, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
inline Channel<V>::ChanReader::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
template <typename V>
inline Channel<V>::ChanReader::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename V>
template <typename _t, typename>
inline Channel<V>::ChanReader::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename V>
template <typename _t, typename>
inline Channel<V>::ChanReader::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
template <typename V>
inline Channel<V>::ChanReader::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
template <typename V>
inline typename  ::mas::schema::common::Channel<V>::ChanReader::Client& Channel<V>::ChanReader::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
template <typename V>
inline typename  ::mas::schema::common::Channel<V>::ChanReader::Client& Channel<V>::ChanReader::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
// Channel<V>::ChanReader::ReadParams
template <typename V>
constexpr uint16_t Channel<V>::ChanReader::ReadParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ChanReader::ReadParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanReader::ReadParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanReader::ReadParams::_capnpPrivate::schema;
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanReader::ReadParams::_capnpPrivate::brandScopes[] = {
  { 0xf0c0f9413a3083be, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanReader::ReadParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanReader::ReadParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_f8dc00b2d60ea82f, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::ChanReader::CloseParams
template <typename V>
constexpr uint16_t Channel<V>::ChanReader::CloseParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ChanReader::CloseParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanReader::CloseParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanReader::CloseParams::_capnpPrivate::schema;
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanReader::CloseParams::_capnpPrivate::brandScopes[] = {
  { 0xf0c0f9413a3083be, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanReader::CloseParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanReader::CloseParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_926107b4c88d431f, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::ChanReader::CloseResults
template <typename V>
constexpr uint16_t Channel<V>::ChanReader::CloseResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ChanReader::CloseResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanReader::CloseResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanReader::CloseResults::_capnpPrivate::schema;
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanReader::CloseResults::_capnpPrivate::brandScopes[] = {
  { 0xf0c0f9413a3083be, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanReader::CloseResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanReader::CloseResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_ec0d27e49a0f9f3a, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::Channel<V>::ChanReader::ReadParams, typename  ::mas::schema::common::Channel<V>::Msg>)
Channel<V>::ChanReader::Client::readRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::common::Channel<V>::ChanReader::ReadParams, typename  ::mas::schema::common::Channel<V>::Msg>(
      0x9c656810b30decd7ull, 0, sizeHint);
}
template <typename V>
::kj::Promise<void> Channel<V>::ChanReader::Server::read(ReadContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "common.capnp:Channel.Reader", "read",
      0x9c656810b30decd7ull, 0);
}
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::Channel<V>::ChanReader::CloseParams, typename  ::mas::schema::common::Channel<V>::ChanReader::CloseResults>)
Channel<V>::ChanReader::Client::closeRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::common::Channel<V>::ChanReader::CloseParams, typename  ::mas::schema::common::Channel<V>::ChanReader::CloseResults>(
      0x9c656810b30decd7ull, 1, sizeHint);
}
template <typename V>
::kj::Promise<void> Channel<V>::ChanReader::Server::close(CloseContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "common.capnp:Channel.Reader", "close",
      0x9c656810b30decd7ull, 1);
}
template <typename V>
::capnp::Capability::Server::DispatchCallResult Channel<V>::ChanReader::Server::dispatchCall(
    uint64_t interfaceId, uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (interfaceId) {
    case 0x9c656810b30decd7ull:
      return dispatchCallInternal(methodId, context);
    default:
      return internalUnimplemented("common.capnp:Channel.Reader", interfaceId);
  }
}
template <typename V>
::capnp::Capability::Server::DispatchCallResult Channel<V>::ChanReader::Server::dispatchCallInternal(
    uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (methodId) {
    case 0:
      return {
        read(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::common::Channel<V>::ChanReader::ReadParams, typename  ::mas::schema::common::Channel<V>::Msg>(context)),
        false
      };
    case 1:
      return {
        close(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::common::Channel<V>::ChanReader::CloseParams, typename  ::mas::schema::common::Channel<V>::ChanReader::CloseResults>(context)),
        false
      };
    default:
      (void)context;
      return ::capnp::Capability::Server::internalUnimplemented(
          "common.capnp:Channel.Reader",
          0x9c656810b30decd7ull, methodId);
  }
}
#endif  // !CAPNP_LITE

// Channel<V>::ChanReader
#if !CAPNP_LITE
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanReader::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanReader::_capnpPrivate::schema;
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanReader::_capnpPrivate::brandScopes[] = {
  { 0xf0c0f9413a3083be, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanReader::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Dependency Channel<V>::ChanReader::_capnpPrivate::brandDependencies[] = {
  { 33554432,  ::mas::schema::common::Channel<V>::ChanReader::ReadParams::_capnpPrivate::brand() },
  { 33554433,  ::mas::schema::common::Channel<V>::ChanReader::CloseParams::_capnpPrivate::brand() },
  { 50331648,  ::mas::schema::common::Channel<V>::Msg::_capnpPrivate::brand() },
  { 50331649,  ::mas::schema::common::Channel<V>::ChanReader::CloseResults::_capnpPrivate::brand() },
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanReader::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_9c656810b30decd7, brandScopes, brandDependencies,
  1, 4, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
inline Channel<V>::ChanWriter::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
template <typename V>
inline Channel<V>::ChanWriter::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename V>
template <typename _t, typename>
inline Channel<V>::ChanWriter::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename V>
template <typename _t, typename>
inline Channel<V>::ChanWriter::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
template <typename V>
inline Channel<V>::ChanWriter::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
template <typename V>
inline typename  ::mas::schema::common::Channel<V>::ChanWriter::Client& Channel<V>::ChanWriter::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
template <typename V>
inline typename  ::mas::schema::common::Channel<V>::ChanWriter::Client& Channel<V>::ChanWriter::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
// Channel<V>::ChanWriter::WriteResults
template <typename V>
constexpr uint16_t Channel<V>::ChanWriter::WriteResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ChanWriter::WriteResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanWriter::WriteResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanWriter::WriteResults::_capnpPrivate::schema;
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanWriter::WriteResults::_capnpPrivate::brandScopes[] = {
  { 0xf0c0f9413a3083be, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanWriter::WriteResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanWriter::WriteResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_98be830bb53c6eb9, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::ChanWriter::CloseParams
template <typename V>
constexpr uint16_t Channel<V>::ChanWriter::CloseParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ChanWriter::CloseParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanWriter::CloseParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanWriter::CloseParams::_capnpPrivate::schema;
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanWriter::CloseParams::_capnpPrivate::brandScopes[] = {
  { 0xf0c0f9413a3083be, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanWriter::CloseParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanWriter::CloseParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_b86feee7ac7bebec, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::ChanWriter::CloseResults
template <typename V>
constexpr uint16_t Channel<V>::ChanWriter::CloseResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ChanWriter::CloseResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanWriter::CloseResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanWriter::CloseResults::_capnpPrivate::schema;
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanWriter::CloseResults::_capnpPrivate::brandScopes[] = {
  { 0xf0c0f9413a3083be, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanWriter::CloseResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanWriter::CloseResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_86215e947f0afb85, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::Channel<V>::Msg, typename  ::mas::schema::common::Channel<V>::ChanWriter::WriteResults>)
Channel<V>::ChanWriter::Client::writeRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::common::Channel<V>::Msg, typename  ::mas::schema::common::Channel<V>::ChanWriter::WriteResults>(
      0x9b5844944dc0f458ull, 0, sizeHint);
}
template <typename V>
::kj::Promise<void> Channel<V>::ChanWriter::Server::write(WriteContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "common.capnp:Channel.Writer", "write",
      0x9b5844944dc0f458ull, 0);
}
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::Channel<V>::ChanWriter::CloseParams, typename  ::mas::schema::common::Channel<V>::ChanWriter::CloseResults>)
Channel<V>::ChanWriter::Client::closeRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::common::Channel<V>::ChanWriter::CloseParams, typename  ::mas::schema::common::Channel<V>::ChanWriter::CloseResults>(
      0x9b5844944dc0f458ull, 1, sizeHint);
}
template <typename V>
::kj::Promise<void> Channel<V>::ChanWriter::Server::close(CloseContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "common.capnp:Channel.Writer", "close",
      0x9b5844944dc0f458ull, 1);
}
template <typename V>
::capnp::Capability::Server::DispatchCallResult Channel<V>::ChanWriter::Server::dispatchCall(
    uint64_t interfaceId, uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (interfaceId) {
    case 0x9b5844944dc0f458ull:
      return dispatchCallInternal(methodId, context);
    default:
      return internalUnimplemented("common.capnp:Channel.Writer", interfaceId);
  }
}
template <typename V>
::capnp::Capability::Server::DispatchCallResult Channel<V>::ChanWriter::Server::dispatchCallInternal(
    uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (methodId) {
    case 0:
      return {
        write(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::common::Channel<V>::Msg, typename  ::mas::schema::common::Channel<V>::ChanWriter::WriteResults>(context)),
        false
      };
    case 1:
      return {
        close(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::common::Channel<V>::ChanWriter::CloseParams, typename  ::mas::schema::common::Channel<V>::ChanWriter::CloseResults>(context)),
        false
      };
    default:
      (void)context;
      return ::capnp::Capability::Server::internalUnimplemented(
          "common.capnp:Channel.Writer",
          0x9b5844944dc0f458ull, methodId);
  }
}
#endif  // !CAPNP_LITE

// Channel<V>::ChanWriter
#if !CAPNP_LITE
template <typename V>
constexpr ::capnp::Kind Channel<V>::ChanWriter::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ChanWriter::_capnpPrivate::schema;
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ChanWriter::_capnpPrivate::brandScopes[] = {
  { 0xf0c0f9413a3083be, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ChanWriter::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Dependency Channel<V>::ChanWriter::_capnpPrivate::brandDependencies[] = {
  { 33554432,  ::mas::schema::common::Channel<V>::Msg::_capnpPrivate::brand() },
  { 33554433,  ::mas::schema::common::Channel<V>::ChanWriter::CloseParams::_capnpPrivate::brand() },
  { 50331648,  ::mas::schema::common::Channel<V>::ChanWriter::WriteResults::_capnpPrivate::brand() },
  { 50331649,  ::mas::schema::common::Channel<V>::ChanWriter::CloseResults::_capnpPrivate::brand() },
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ChanWriter::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_9b5844944dc0f458, brandScopes, brandDependencies,
  1, 4, nullptr
};
#endif  // !CAPNP_LITE

template <typename V>
inline  ::uint64_t Channel<V>::SetBufferSizeParams::Reader::getSize() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 1ull);
}

template <typename V>
inline  ::uint64_t Channel<V>::SetBufferSizeParams::Builder::getSize() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 1ull);
}
template <typename V>
inline void Channel<V>::SetBufferSizeParams::Builder::setSize( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, 1ull);
}

// Channel<V>::SetBufferSizeParams
template <typename V>
constexpr uint16_t Channel<V>::SetBufferSizeParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::SetBufferSizeParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename V>
constexpr ::capnp::Kind Channel<V>::SetBufferSizeParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::SetBufferSizeParams::_capnpPrivate::schema;
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::SetBufferSizeParams::_capnpPrivate::brandScopes[] = {
  { 0xf0c0f9413a3083be, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::SetBufferSizeParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::SetBufferSizeParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_ee378f318f32b853, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::SetBufferSizeResults
template <typename V>
constexpr uint16_t Channel<V>::SetBufferSizeResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::SetBufferSizeResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename V>
constexpr ::capnp::Kind Channel<V>::SetBufferSizeResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::SetBufferSizeResults::_capnpPrivate::schema;
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::SetBufferSizeResults::_capnpPrivate::brandScopes[] = {
  { 0xf0c0f9413a3083be, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::SetBufferSizeResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::SetBufferSizeResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_abd31dc62bd9a48b, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::ReaderParams
template <typename V>
constexpr uint16_t Channel<V>::ReaderParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ReaderParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename V>
constexpr ::capnp::Kind Channel<V>::ReaderParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ReaderParams::_capnpPrivate::schema;
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ReaderParams::_capnpPrivate::brandScopes[] = {
  { 0xf0c0f9413a3083be, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ReaderParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ReaderParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_b6563114436deea9, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename V>
inline bool Channel<V>::ReaderResults::Reader::hasR() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline bool Channel<V>::ReaderResults::Builder::hasR() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename V>
inline typename  ::mas::schema::common::Channel<V>::ChanReader::Client Channel<V>::ReaderResults::Reader::getR() const {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::common::Channel<V>::ChanReader>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::mas::schema::common::Channel<V>::ChanReader::Client Channel<V>::ReaderResults::Builder::getR() {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::common::Channel<V>::ChanReader>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::mas::schema::common::Channel<V>::ChanReader::Client Channel<V>::ReaderResults::Pipeline::getR() {
  return typename  ::mas::schema::common::Channel<V>::ChanReader::Client(_typeless.getPointerField(0).asCap());
}
template <typename V>
inline void Channel<V>::ReaderResults::Builder::setR(typename  ::mas::schema::common::Channel<V>::ChanReader::Client&& cap) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::common::Channel<V>::ChanReader>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
template <typename V>
inline void Channel<V>::ReaderResults::Builder::setR(typename  ::mas::schema::common::Channel<V>::ChanReader::Client& cap) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::common::Channel<V>::ChanReader>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
template <typename V>
inline void Channel<V>::ReaderResults::Builder::adoptR(
    ::capnp::Orphan<typename  ::mas::schema::common::Channel<V>::ChanReader>&& value) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::common::Channel<V>::ChanReader>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename V>
inline ::capnp::Orphan<typename  ::mas::schema::common::Channel<V>::ChanReader> Channel<V>::ReaderResults::Builder::disownR() {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::common::Channel<V>::ChanReader>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

// Channel<V>::ReaderResults
template <typename V>
constexpr uint16_t Channel<V>::ReaderResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::ReaderResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename V>
constexpr ::capnp::Kind Channel<V>::ReaderResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::ReaderResults::_capnpPrivate::schema;
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::ReaderResults::_capnpPrivate::brandScopes[] = {
  { 0xf0c0f9413a3083be, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::ReaderResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Dependency Channel<V>::ReaderResults::_capnpPrivate::brandDependencies[] = {
  { 16777216,  ::mas::schema::common::Channel<V>::ChanReader::_capnpPrivate::brand() },
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::ReaderResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_89aeecad59dc62ee, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::WriterParams
template <typename V>
constexpr uint16_t Channel<V>::WriterParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::WriterParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename V>
constexpr ::capnp::Kind Channel<V>::WriterParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::WriterParams::_capnpPrivate::schema;
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::WriterParams::_capnpPrivate::brandScopes[] = {
  { 0xf0c0f9413a3083be, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::WriterParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::WriterParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_9882f67fa6ace6a1, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename V>
inline bool Channel<V>::WriterResults::Reader::hasW() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline bool Channel<V>::WriterResults::Builder::hasW() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename V>
inline typename  ::mas::schema::common::Channel<V>::ChanWriter::Client Channel<V>::WriterResults::Reader::getW() const {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::common::Channel<V>::ChanWriter>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::mas::schema::common::Channel<V>::ChanWriter::Client Channel<V>::WriterResults::Builder::getW() {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::common::Channel<V>::ChanWriter>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::mas::schema::common::Channel<V>::ChanWriter::Client Channel<V>::WriterResults::Pipeline::getW() {
  return typename  ::mas::schema::common::Channel<V>::ChanWriter::Client(_typeless.getPointerField(0).asCap());
}
template <typename V>
inline void Channel<V>::WriterResults::Builder::setW(typename  ::mas::schema::common::Channel<V>::ChanWriter::Client&& cap) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::common::Channel<V>::ChanWriter>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
template <typename V>
inline void Channel<V>::WriterResults::Builder::setW(typename  ::mas::schema::common::Channel<V>::ChanWriter::Client& cap) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::common::Channel<V>::ChanWriter>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
template <typename V>
inline void Channel<V>::WriterResults::Builder::adoptW(
    ::capnp::Orphan<typename  ::mas::schema::common::Channel<V>::ChanWriter>&& value) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::common::Channel<V>::ChanWriter>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename V>
inline ::capnp::Orphan<typename  ::mas::schema::common::Channel<V>::ChanWriter> Channel<V>::WriterResults::Builder::disownW() {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::common::Channel<V>::ChanWriter>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

// Channel<V>::WriterResults
template <typename V>
constexpr uint16_t Channel<V>::WriterResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::WriterResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename V>
constexpr ::capnp::Kind Channel<V>::WriterResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::WriterResults::_capnpPrivate::schema;
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::WriterResults::_capnpPrivate::brandScopes[] = {
  { 0xf0c0f9413a3083be, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::WriterResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Dependency Channel<V>::WriterResults::_capnpPrivate::brandDependencies[] = {
  { 16777216,  ::mas::schema::common::Channel<V>::ChanWriter::_capnpPrivate::brand() },
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::WriterResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_d7e3695f7166e987, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::EndpointsParams
template <typename V>
constexpr uint16_t Channel<V>::EndpointsParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::EndpointsParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename V>
constexpr ::capnp::Kind Channel<V>::EndpointsParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::EndpointsParams::_capnpPrivate::schema;
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::EndpointsParams::_capnpPrivate::brandScopes[] = {
  { 0xf0c0f9413a3083be, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::EndpointsParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::EndpointsParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_db1f001689bbac5d, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename V>
inline bool Channel<V>::EndpointsResults::Reader::hasR() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline bool Channel<V>::EndpointsResults::Builder::hasR() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename V>
inline typename  ::mas::schema::common::Channel<V>::ChanReader::Client Channel<V>::EndpointsResults::Reader::getR() const {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::common::Channel<V>::ChanReader>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::mas::schema::common::Channel<V>::ChanReader::Client Channel<V>::EndpointsResults::Builder::getR() {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::common::Channel<V>::ChanReader>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::mas::schema::common::Channel<V>::ChanReader::Client Channel<V>::EndpointsResults::Pipeline::getR() {
  return typename  ::mas::schema::common::Channel<V>::ChanReader::Client(_typeless.getPointerField(0).asCap());
}
template <typename V>
inline void Channel<V>::EndpointsResults::Builder::setR(typename  ::mas::schema::common::Channel<V>::ChanReader::Client&& cap) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::common::Channel<V>::ChanReader>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
template <typename V>
inline void Channel<V>::EndpointsResults::Builder::setR(typename  ::mas::schema::common::Channel<V>::ChanReader::Client& cap) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::common::Channel<V>::ChanReader>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
template <typename V>
inline void Channel<V>::EndpointsResults::Builder::adoptR(
    ::capnp::Orphan<typename  ::mas::schema::common::Channel<V>::ChanReader>&& value) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::common::Channel<V>::ChanReader>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename V>
inline ::capnp::Orphan<typename  ::mas::schema::common::Channel<V>::ChanReader> Channel<V>::EndpointsResults::Builder::disownR() {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::common::Channel<V>::ChanReader>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

template <typename V>
inline bool Channel<V>::EndpointsResults::Reader::hasW() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename V>
inline bool Channel<V>::EndpointsResults::Builder::hasW() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
template <typename V>
inline typename  ::mas::schema::common::Channel<V>::ChanWriter::Client Channel<V>::EndpointsResults::Reader::getW() const {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::common::Channel<V>::ChanWriter>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::mas::schema::common::Channel<V>::ChanWriter::Client Channel<V>::EndpointsResults::Builder::getW() {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::common::Channel<V>::ChanWriter>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename V>
inline typename  ::mas::schema::common::Channel<V>::ChanWriter::Client Channel<V>::EndpointsResults::Pipeline::getW() {
  return typename  ::mas::schema::common::Channel<V>::ChanWriter::Client(_typeless.getPointerField(1).asCap());
}
template <typename V>
inline void Channel<V>::EndpointsResults::Builder::setW(typename  ::mas::schema::common::Channel<V>::ChanWriter::Client&& cap) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::common::Channel<V>::ChanWriter>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(cap));
}
template <typename V>
inline void Channel<V>::EndpointsResults::Builder::setW(typename  ::mas::schema::common::Channel<V>::ChanWriter::Client& cap) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::common::Channel<V>::ChanWriter>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), cap);
}
template <typename V>
inline void Channel<V>::EndpointsResults::Builder::adoptW(
    ::capnp::Orphan<typename  ::mas::schema::common::Channel<V>::ChanWriter>&& value) {
  ::capnp::_::PointerHelpers<typename  ::mas::schema::common::Channel<V>::ChanWriter>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename V>
inline ::capnp::Orphan<typename  ::mas::schema::common::Channel<V>::ChanWriter> Channel<V>::EndpointsResults::Builder::disownW() {
  return ::capnp::_::PointerHelpers<typename  ::mas::schema::common::Channel<V>::ChanWriter>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

// Channel<V>::EndpointsResults
template <typename V>
constexpr uint16_t Channel<V>::EndpointsResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::EndpointsResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename V>
constexpr ::capnp::Kind Channel<V>::EndpointsResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::EndpointsResults::_capnpPrivate::schema;
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::EndpointsResults::_capnpPrivate::brandScopes[] = {
  { 0xf0c0f9413a3083be, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::EndpointsResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Dependency Channel<V>::EndpointsResults::_capnpPrivate::brandDependencies[] = {
  { 16777216,  ::mas::schema::common::Channel<V>::ChanReader::_capnpPrivate::brand() },
  { 16777217,  ::mas::schema::common::Channel<V>::ChanWriter::_capnpPrivate::brand() },
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::EndpointsResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_c8a1bc4350302330, brandScopes, brandDependencies,
  1, 2, nullptr
};
#endif  // !CAPNP_LITE

template <typename V>
inline typename  ::mas::schema::common::Channel<V>::CloseSemantics Channel<V>::SetAutoCloseSemanticsParams::Reader::getCs() const {
  return _reader.getDataField<typename  ::mas::schema::common::Channel<V>::CloseSemantics>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename V>
inline typename  ::mas::schema::common::Channel<V>::CloseSemantics Channel<V>::SetAutoCloseSemanticsParams::Builder::getCs() {
  return _builder.getDataField<typename  ::mas::schema::common::Channel<V>::CloseSemantics>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename V>
inline void Channel<V>::SetAutoCloseSemanticsParams::Builder::setCs(typename  ::mas::schema::common::Channel<V>::CloseSemantics value) {
  _builder.setDataField<typename  ::mas::schema::common::Channel<V>::CloseSemantics>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

// Channel<V>::SetAutoCloseSemanticsParams
template <typename V>
constexpr uint16_t Channel<V>::SetAutoCloseSemanticsParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::SetAutoCloseSemanticsParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename V>
constexpr ::capnp::Kind Channel<V>::SetAutoCloseSemanticsParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::SetAutoCloseSemanticsParams::_capnpPrivate::schema;
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::SetAutoCloseSemanticsParams::_capnpPrivate::brandScopes[] = {
  { 0xf0c0f9413a3083be, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::SetAutoCloseSemanticsParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::SetAutoCloseSemanticsParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_d8727b5440681ed4, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::SetAutoCloseSemanticsResults
template <typename V>
constexpr uint16_t Channel<V>::SetAutoCloseSemanticsResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::SetAutoCloseSemanticsResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename V>
constexpr ::capnp::Kind Channel<V>::SetAutoCloseSemanticsResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::SetAutoCloseSemanticsResults::_capnpPrivate::schema;
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::SetAutoCloseSemanticsResults::_capnpPrivate::brandScopes[] = {
  { 0xf0c0f9413a3083be, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::SetAutoCloseSemanticsResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::SetAutoCloseSemanticsResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_e8ba8300eb17a23c, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename V>
inline bool Channel<V>::CloseParams::Reader::getWaitForEmptyBuffer() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, true);
}

template <typename V>
inline bool Channel<V>::CloseParams::Builder::getWaitForEmptyBuffer() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, true);
}
template <typename V>
inline void Channel<V>::CloseParams::Builder::setWaitForEmptyBuffer(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, true);
}

// Channel<V>::CloseParams
template <typename V>
constexpr uint16_t Channel<V>::CloseParams::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::CloseParams::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename V>
constexpr ::capnp::Kind Channel<V>::CloseParams::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::CloseParams::_capnpPrivate::schema;
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::CloseParams::_capnpPrivate::brandScopes[] = {
  { 0xf0c0f9413a3083be, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::CloseParams::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::CloseParams::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_f8224774a4d4d6f5, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Channel<V>::CloseResults
template <typename V>
constexpr uint16_t Channel<V>::CloseResults::_capnpPrivate::dataWordSize;
template <typename V>
constexpr uint16_t Channel<V>::CloseResults::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename V>
constexpr ::capnp::Kind Channel<V>::CloseResults::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::CloseResults::_capnpPrivate::schema;
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::CloseResults::_capnpPrivate::brandScopes[] = {
  { 0xf0c0f9413a3083be, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::CloseResults::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::CloseResults::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_f20dfadcec8a0e13, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::Channel<V>::SetBufferSizeParams, typename  ::mas::schema::common::Channel<V>::SetBufferSizeResults>)
Channel<V>::Client::setBufferSizeRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::common::Channel<V>::SetBufferSizeParams, typename  ::mas::schema::common::Channel<V>::SetBufferSizeResults>(
      0xf0c0f9413a3083beull, 0, sizeHint);
}
template <typename V>
::kj::Promise<void> Channel<V>::Server::setBufferSize(SetBufferSizeContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "common.capnp:Channel", "setBufferSize",
      0xf0c0f9413a3083beull, 0);
}
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::Channel<V>::ReaderParams, typename  ::mas::schema::common::Channel<V>::ReaderResults>)
Channel<V>::Client::readerRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::common::Channel<V>::ReaderParams, typename  ::mas::schema::common::Channel<V>::ReaderResults>(
      0xf0c0f9413a3083beull, 1, sizeHint);
}
template <typename V>
::kj::Promise<void> Channel<V>::Server::reader(ReaderContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "common.capnp:Channel", "reader",
      0xf0c0f9413a3083beull, 1);
}
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::Channel<V>::WriterParams, typename  ::mas::schema::common::Channel<V>::WriterResults>)
Channel<V>::Client::writerRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::common::Channel<V>::WriterParams, typename  ::mas::schema::common::Channel<V>::WriterResults>(
      0xf0c0f9413a3083beull, 2, sizeHint);
}
template <typename V>
::kj::Promise<void> Channel<V>::Server::writer(WriterContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "common.capnp:Channel", "writer",
      0xf0c0f9413a3083beull, 2);
}
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::Channel<V>::EndpointsParams, typename  ::mas::schema::common::Channel<V>::EndpointsResults>)
Channel<V>::Client::endpointsRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::common::Channel<V>::EndpointsParams, typename  ::mas::schema::common::Channel<V>::EndpointsResults>(
      0xf0c0f9413a3083beull, 3, sizeHint);
}
template <typename V>
::kj::Promise<void> Channel<V>::Server::endpoints(EndpointsContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "common.capnp:Channel", "endpoints",
      0xf0c0f9413a3083beull, 3);
}
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::Channel<V>::SetAutoCloseSemanticsParams, typename  ::mas::schema::common::Channel<V>::SetAutoCloseSemanticsResults>)
Channel<V>::Client::setAutoCloseSemanticsRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::common::Channel<V>::SetAutoCloseSemanticsParams, typename  ::mas::schema::common::Channel<V>::SetAutoCloseSemanticsResults>(
      0xf0c0f9413a3083beull, 4, sizeHint);
}
template <typename V>
::kj::Promise<void> Channel<V>::Server::setAutoCloseSemantics(SetAutoCloseSemanticsContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "common.capnp:Channel", "setAutoCloseSemantics",
      0xf0c0f9413a3083beull, 4);
}
template <typename V>
CAPNP_AUTO_IF_MSVC(::capnp::Request<typename  ::mas::schema::common::Channel<V>::CloseParams, typename  ::mas::schema::common::Channel<V>::CloseResults>)
Channel<V>::Client::closeRequest(::kj::Maybe< ::capnp::MessageSize> sizeHint) {
  return newCall<typename  ::mas::schema::common::Channel<V>::CloseParams, typename  ::mas::schema::common::Channel<V>::CloseResults>(
      0xf0c0f9413a3083beull, 5, sizeHint);
}
template <typename V>
::kj::Promise<void> Channel<V>::Server::close(CloseContext) {
  return ::capnp::Capability::Server::internalUnimplemented(
      "common.capnp:Channel", "close",
      0xf0c0f9413a3083beull, 5);
}
template <typename V>
::capnp::Capability::Server::DispatchCallResult Channel<V>::Server::dispatchCall(
    uint64_t interfaceId, uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (interfaceId) {
    case 0xf0c0f9413a3083beull:
      return dispatchCallInternal(methodId, context);
    default:
      return internalUnimplemented("common.capnp:Channel", interfaceId);
  }
}
template <typename V>
::capnp::Capability::Server::DispatchCallResult Channel<V>::Server::dispatchCallInternal(
    uint16_t methodId,
    ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context) {
  switch (methodId) {
    case 0:
      return {
        setBufferSize(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::common::Channel<V>::SetBufferSizeParams, typename  ::mas::schema::common::Channel<V>::SetBufferSizeResults>(context)),
        false
      };
    case 1:
      return {
        reader(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::common::Channel<V>::ReaderParams, typename  ::mas::schema::common::Channel<V>::ReaderResults>(context)),
        false
      };
    case 2:
      return {
        writer(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::common::Channel<V>::WriterParams, typename  ::mas::schema::common::Channel<V>::WriterResults>(context)),
        false
      };
    case 3:
      return {
        endpoints(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::common::Channel<V>::EndpointsParams, typename  ::mas::schema::common::Channel<V>::EndpointsResults>(context)),
        false
      };
    case 4:
      return {
        setAutoCloseSemantics(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::common::Channel<V>::SetAutoCloseSemanticsParams, typename  ::mas::schema::common::Channel<V>::SetAutoCloseSemanticsResults>(context)),
        false
      };
    case 5:
      return {
        close(::capnp::Capability::Server::internalGetTypedContext<
            typename  ::mas::schema::common::Channel<V>::CloseParams, typename  ::mas::schema::common::Channel<V>::CloseResults>(context)),
        false
      };
    default:
      (void)context;
      return ::capnp::Capability::Server::internalUnimplemented(
          "common.capnp:Channel",
          0xf0c0f9413a3083beull, methodId);
  }
}
#endif  // !CAPNP_LITE

// Channel<V>
#if !CAPNP_LITE
template <typename V>
constexpr ::capnp::Kind Channel<V>::_capnpPrivate::kind;
template <typename V>
constexpr ::capnp::_::RawSchema const* Channel<V>::_capnpPrivate::schema;
template <typename V>
const ::capnp::_::RawBrandedSchema::Scope Channel<V>::_capnpPrivate::brandScopes[] = {
  { 0xf0c0f9413a3083be, brandBindings + 0, 1, false},
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Binding Channel<V>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<V>(),
};
template <typename V>
const ::capnp::_::RawBrandedSchema::Dependency Channel<V>::_capnpPrivate::brandDependencies[] = {
  { 33554432,  ::mas::schema::common::Channel<V>::SetBufferSizeParams::_capnpPrivate::brand() },
  { 33554433,  ::mas::schema::common::Channel<V>::ReaderParams::_capnpPrivate::brand() },
  { 33554434,  ::mas::schema::common::Channel<V>::WriterParams::_capnpPrivate::brand() },
  { 33554435,  ::mas::schema::common::Channel<V>::EndpointsParams::_capnpPrivate::brand() },
  { 33554436,  ::mas::schema::common::Channel<V>::SetAutoCloseSemanticsParams::_capnpPrivate::brand() },
  { 33554437,  ::mas::schema::common::Channel<V>::CloseParams::_capnpPrivate::brand() },
  { 50331648,  ::mas::schema::common::Channel<V>::SetBufferSizeResults::_capnpPrivate::brand() },
  { 50331649,  ::mas::schema::common::Channel<V>::ReaderResults::_capnpPrivate::brand() },
  { 50331650,  ::mas::schema::common::Channel<V>::WriterResults::_capnpPrivate::brand() },
  { 50331651,  ::mas::schema::common::Channel<V>::EndpointsResults::_capnpPrivate::brand() },
  { 50331652,  ::mas::schema::common::Channel<V>::SetAutoCloseSemanticsResults::_capnpPrivate::brand() },
  { 50331653,  ::mas::schema::common::Channel<V>::CloseResults::_capnpPrivate::brand() },
};
template <typename V>
const ::capnp::_::RawBrandedSchema Channel<V>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_f0c0f9413a3083be, brandScopes, brandDependencies,
  1, 12, nullptr
};
#endif  // !CAPNP_LITE

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

