// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: grid.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#if CAPNP_VERSION != 10000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "common.capnp.h"
#include "geo.capnp.h"
#include "persistence.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(a5ecdc7767a6b301);
enum class Aggregation_a5ecdc7767a6b301: uint16_t {
  NONE,
  W_AVG,
  W_MEDIAN,
  MIN,
  MAX,
  SUM,
  I_AVG,
  I_MEDIAN,
  AVG,
  MEDIAN,
  W_SUM,
  I_SUM,
  W_MIN,
  I_MIN,
  W_MAX,
  I_MAX,
};
CAPNP_DECLARE_ENUM(Aggregation, a5ecdc7767a6b301);
CAPNP_DECLARE_SCHEMA(e42973b29661e3c6);
CAPNP_DECLARE_SCHEMA(fe2e0dfae573d9d0);
CAPNP_DECLARE_SCHEMA(b9e2d85d086206ff);
CAPNP_DECLARE_SCHEMA(ac444617ef333a1d);
CAPNP_DECLARE_SCHEMA(d639518280cb55d3);
CAPNP_DECLARE_SCHEMA(e9b0c7718f68f6bb);
CAPNP_DECLARE_SCHEMA(8e536f6e598b2579);
CAPNP_DECLARE_SCHEMA(eb7e6f1c610c079a);
CAPNP_DECLARE_SCHEMA(a8bd0263833540b0);
CAPNP_DECLARE_SCHEMA(f79edcb97e1e2deb);
CAPNP_DECLARE_SCHEMA(8cd7ba490778c79a);
CAPNP_DECLARE_SCHEMA(a6005af20cc08dbe);
CAPNP_DECLARE_SCHEMA(e7a46f6b1610256f);
CAPNP_DECLARE_SCHEMA(f804a76f2ada54b6);
CAPNP_DECLARE_SCHEMA(9bc132bd2a1b1fcf);
CAPNP_DECLARE_SCHEMA(948ff2bdd6e6972f);
CAPNP_DECLARE_SCHEMA(a21ef33efc715994);
CAPNP_DECLARE_SCHEMA(f37338992466bd97);
CAPNP_DECLARE_SCHEMA(e57fce57d3443377);
CAPNP_DECLARE_SCHEMA(d9add1b3fdcfdbba);
CAPNP_DECLARE_SCHEMA(9b8dd52b78a7ebd2);

}  // namespace schemas
}  // namespace capnp

namespace mas {
namespace schema {
namespace grid {

typedef ::capnp::schemas::Aggregation_a5ecdc7767a6b301 Aggregation;

struct Grid {
  Grid() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct Value;
  struct RowCol;
  struct AggregationPart;
  struct Callback;
  struct ClosestValueAtParams;
  struct ClosestValueAtResults;
  struct ResolutionParams;
  struct ResolutionResults;
  struct DimensionParams;
  struct DimensionResults;
  struct NoDataValueParams;
  struct NoDataValueResults;
  struct ValueAtParams;
  struct ValueAtResults;
  struct LatLonBoundsParams;
  struct LatLonBoundsResults;
  struct StreamCellsParams;
  struct StreamCellsResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(e42973b29661e3c6)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Grid::Value {
  Value() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    F,
    I,
    UI,
    NO,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fe2e0dfae573d9d0, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Grid::RowCol {
  RowCol() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b9e2d85d086206ff, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Grid::AggregationPart {
  AggregationPart() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ac444617ef333a1d, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Grid::Callback {
  Callback() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct SendCellsParams;
  struct SendCellsResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(d639518280cb55d3)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Grid::Callback::SendCellsParams {
  SendCellsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e9b0c7718f68f6bb, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Grid::Callback::SendCellsResults {
  SendCellsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8e536f6e598b2579, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Grid::ClosestValueAtParams {
  ClosestValueAtParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(eb7e6f1c610c079a, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Grid::ClosestValueAtResults {
  ClosestValueAtResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a8bd0263833540b0, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Grid::ResolutionParams {
  ResolutionParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f79edcb97e1e2deb, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Grid::ResolutionResults {
  ResolutionResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8cd7ba490778c79a, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Grid::DimensionParams {
  DimensionParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a6005af20cc08dbe, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Grid::DimensionResults {
  DimensionResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e7a46f6b1610256f, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Grid::NoDataValueParams {
  NoDataValueParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f804a76f2ada54b6, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Grid::NoDataValueResults {
  NoDataValueResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9bc132bd2a1b1fcf, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Grid::ValueAtParams {
  ValueAtParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(948ff2bdd6e6972f, 4, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Grid::ValueAtResults {
  ValueAtResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a21ef33efc715994, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Grid::LatLonBoundsParams {
  LatLonBoundsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f37338992466bd97, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Grid::LatLonBoundsResults {
  LatLonBoundsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e57fce57d3443377, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Grid::StreamCellsParams {
  StreamCellsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d9add1b3fdcfdbba, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Grid::StreamCellsResults {
  StreamCellsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9b8dd52b78a7ebd2, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

#if !CAPNP_LITE
class Grid::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::mas::schema::common::Identifiable::Client,
      public virtual  ::mas::schema::persistence::Persistent::Client {
public:
  typedef Grid Calls;
  typedef Grid Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::grid::Grid::ClosestValueAtParams,  ::mas::schema::grid::Grid::ClosestValueAtResults> closestValueAtRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::grid::Grid::ResolutionParams,  ::mas::schema::grid::Grid::ResolutionResults> resolutionRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::grid::Grid::DimensionParams,  ::mas::schema::grid::Grid::DimensionResults> dimensionRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::grid::Grid::NoDataValueParams,  ::mas::schema::grid::Grid::NoDataValueResults> noDataValueRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::grid::Grid::ValueAtParams,  ::mas::schema::grid::Grid::ValueAtResults> valueAtRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::grid::Grid::LatLonBoundsParams,  ::mas::schema::grid::Grid::LatLonBoundsResults> latLonBoundsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::mas::schema::grid::Grid::StreamCellsParams,  ::mas::schema::grid::Grid::StreamCellsResults> streamCellsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Grid::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::mas::schema::common::Identifiable::Server,
      public virtual  ::mas::schema::persistence::Persistent::Server {
public:
  typedef Grid Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::grid::Grid::ClosestValueAtParams ClosestValueAtParams;
  typedef  ::mas::schema::grid::Grid::ClosestValueAtResults ClosestValueAtResults;
  typedef ::capnp::CallContext<ClosestValueAtParams, ClosestValueAtResults> ClosestValueAtContext;
  virtual ::kj::Promise<void> closestValueAt(ClosestValueAtContext context);
  typedef  ::mas::schema::grid::Grid::ResolutionParams ResolutionParams;
  typedef  ::mas::schema::grid::Grid::ResolutionResults ResolutionResults;
  typedef ::capnp::CallContext<ResolutionParams, ResolutionResults> ResolutionContext;
  virtual ::kj::Promise<void> resolution(ResolutionContext context);
  typedef  ::mas::schema::grid::Grid::DimensionParams DimensionParams;
  typedef  ::mas::schema::grid::Grid::DimensionResults DimensionResults;
  typedef ::capnp::CallContext<DimensionParams, DimensionResults> DimensionContext;
  virtual ::kj::Promise<void> dimension(DimensionContext context);
  typedef  ::mas::schema::grid::Grid::NoDataValueParams NoDataValueParams;
  typedef  ::mas::schema::grid::Grid::NoDataValueResults NoDataValueResults;
  typedef ::capnp::CallContext<NoDataValueParams, NoDataValueResults> NoDataValueContext;
  virtual ::kj::Promise<void> noDataValue(NoDataValueContext context);
  typedef  ::mas::schema::grid::Grid::ValueAtParams ValueAtParams;
  typedef  ::mas::schema::grid::Grid::ValueAtResults ValueAtResults;
  typedef ::capnp::CallContext<ValueAtParams, ValueAtResults> ValueAtContext;
  virtual ::kj::Promise<void> valueAt(ValueAtContext context);
  typedef  ::mas::schema::grid::Grid::LatLonBoundsParams LatLonBoundsParams;
  typedef  ::mas::schema::grid::Grid::LatLonBoundsResults LatLonBoundsResults;
  typedef ::capnp::CallContext<LatLonBoundsParams, LatLonBoundsResults> LatLonBoundsContext;
  virtual ::kj::Promise<void> latLonBounds(LatLonBoundsContext context);
  typedef  ::mas::schema::grid::Grid::StreamCellsParams StreamCellsParams;
  typedef  ::mas::schema::grid::Grid::StreamCellsResults StreamCellsResults;
  typedef ::capnp::CallContext<StreamCellsParams, StreamCellsResults> StreamCellsContext;
  virtual ::kj::Promise<void> streamCells(StreamCellsContext context);

  inline  ::mas::schema::grid::Grid::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::grid::Grid>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Grid::Value::Reader {
public:
  typedef Value Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isF() const;
  inline double getF() const;

  inline bool isI() const;
  inline  ::int64_t getI() const;

  inline bool isUi() const;
  inline  ::uint64_t getUi() const;

  inline bool isNo() const;
  inline bool getNo() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Grid::Value::Builder {
public:
  typedef Value Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isF();
  inline double getF();
  inline void setF(double value);

  inline bool isI();
  inline  ::int64_t getI();
  inline void setI( ::int64_t value);

  inline bool isUi();
  inline  ::uint64_t getUi();
  inline void setUi( ::uint64_t value);

  inline bool isNo();
  inline bool getNo();
  inline void setNo(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Grid::Value::Pipeline {
public:
  typedef Value Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Grid::RowCol::Reader {
public:
  typedef RowCol Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getRow() const;

  inline  ::uint64_t getCol() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Grid::RowCol::Builder {
public:
  typedef RowCol Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getRow();
  inline void setRow( ::uint64_t value);

  inline  ::uint64_t getCol();
  inline void setCol( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Grid::RowCol::Pipeline {
public:
  typedef RowCol Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Grid::AggregationPart::Reader {
public:
  typedef AggregationPart Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasValue() const;
  inline  ::mas::schema::grid::Grid::Value::Reader getValue() const;

  inline bool hasRowCol() const;
  inline  ::mas::schema::grid::Grid::RowCol::Reader getRowCol() const;

  inline double getAreaFrac() const;

  inline double getIValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Grid::AggregationPart::Builder {
public:
  typedef AggregationPart Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasValue();
  inline  ::mas::schema::grid::Grid::Value::Builder getValue();
  inline void setValue( ::mas::schema::grid::Grid::Value::Reader value);
  inline  ::mas::schema::grid::Grid::Value::Builder initValue();
  inline void adoptValue(::capnp::Orphan< ::mas::schema::grid::Grid::Value>&& value);
  inline ::capnp::Orphan< ::mas::schema::grid::Grid::Value> disownValue();

  inline bool hasRowCol();
  inline  ::mas::schema::grid::Grid::RowCol::Builder getRowCol();
  inline void setRowCol( ::mas::schema::grid::Grid::RowCol::Reader value);
  inline  ::mas::schema::grid::Grid::RowCol::Builder initRowCol();
  inline void adoptRowCol(::capnp::Orphan< ::mas::schema::grid::Grid::RowCol>&& value);
  inline ::capnp::Orphan< ::mas::schema::grid::Grid::RowCol> disownRowCol();

  inline double getAreaFrac();
  inline void setAreaFrac(double value);

  inline double getIValue();
  inline void setIValue(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Grid::AggregationPart::Pipeline {
public:
  typedef AggregationPart Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::grid::Grid::Value::Pipeline getValue();
  inline  ::mas::schema::grid::Grid::RowCol::Pipeline getRowCol();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Grid::Callback::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Callback Calls;
  typedef Callback Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::mas::schema::grid::Grid::Callback::SendCellsParams,  ::mas::schema::grid::Grid::Callback::SendCellsResults> sendCellsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Grid::Callback::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Callback Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::mas::schema::grid::Grid::Callback::SendCellsParams SendCellsParams;
  typedef  ::mas::schema::grid::Grid::Callback::SendCellsResults SendCellsResults;
  typedef ::capnp::CallContext<SendCellsParams, SendCellsResults> SendCellsContext;
  virtual ::kj::Promise<void> sendCells(SendCellsContext context);

  inline  ::mas::schema::grid::Grid::Callback::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::mas::schema::grid::Grid::Callback>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Grid::Callback::SendCellsParams::Reader {
public:
  typedef SendCellsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCells() const;
  inline  ::capnp::List< ::mas::schema::grid::Grid::RowCol,  ::capnp::Kind::STRUCT>::Reader getCells() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Grid::Callback::SendCellsParams::Builder {
public:
  typedef SendCellsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCells();
  inline  ::capnp::List< ::mas::schema::grid::Grid::RowCol,  ::capnp::Kind::STRUCT>::Builder getCells();
  inline void setCells( ::capnp::List< ::mas::schema::grid::Grid::RowCol,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::grid::Grid::RowCol,  ::capnp::Kind::STRUCT>::Builder initCells(unsigned int size);
  inline void adoptCells(::capnp::Orphan< ::capnp::List< ::mas::schema::grid::Grid::RowCol,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::grid::Grid::RowCol,  ::capnp::Kind::STRUCT>> disownCells();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Grid::Callback::SendCellsParams::Pipeline {
public:
  typedef SendCellsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Grid::Callback::SendCellsResults::Reader {
public:
  typedef SendCellsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Grid::Callback::SendCellsResults::Builder {
public:
  typedef SendCellsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Grid::Callback::SendCellsResults::Pipeline {
public:
  typedef SendCellsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Grid::ClosestValueAtParams::Reader {
public:
  typedef ClosestValueAtParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLatlonCoord() const;
  inline  ::mas::schema::geo::LatLonCoord::Reader getLatlonCoord() const;

  inline bool getIgnoreNoData() const;

  inline  ::uint64_t getResolution() const;

  inline  ::mas::schema::grid::Aggregation getAgg() const;

  inline bool getReturnRowCols() const;

  inline bool getIncludeAggParts() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Grid::ClosestValueAtParams::Builder {
public:
  typedef ClosestValueAtParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLatlonCoord();
  inline  ::mas::schema::geo::LatLonCoord::Builder getLatlonCoord();
  inline void setLatlonCoord( ::mas::schema::geo::LatLonCoord::Reader value);
  inline  ::mas::schema::geo::LatLonCoord::Builder initLatlonCoord();
  inline void adoptLatlonCoord(::capnp::Orphan< ::mas::schema::geo::LatLonCoord>&& value);
  inline ::capnp::Orphan< ::mas::schema::geo::LatLonCoord> disownLatlonCoord();

  inline bool getIgnoreNoData();
  inline void setIgnoreNoData(bool value);

  inline  ::uint64_t getResolution();
  inline void setResolution( ::uint64_t value);

  inline  ::mas::schema::grid::Aggregation getAgg();
  inline void setAgg( ::mas::schema::grid::Aggregation value);

  inline bool getReturnRowCols();
  inline void setReturnRowCols(bool value);

  inline bool getIncludeAggParts();
  inline void setIncludeAggParts(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Grid::ClosestValueAtParams::Pipeline {
public:
  typedef ClosestValueAtParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::geo::LatLonCoord::Pipeline getLatlonCoord();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Grid::ClosestValueAtResults::Reader {
public:
  typedef ClosestValueAtResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasVal() const;
  inline  ::mas::schema::grid::Grid::Value::Reader getVal() const;

  inline bool hasTl() const;
  inline  ::mas::schema::grid::Grid::RowCol::Reader getTl() const;

  inline bool hasBr() const;
  inline  ::mas::schema::grid::Grid::RowCol::Reader getBr() const;

  inline bool hasAggParts() const;
  inline  ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>::Reader getAggParts() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Grid::ClosestValueAtResults::Builder {
public:
  typedef ClosestValueAtResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasVal();
  inline  ::mas::schema::grid::Grid::Value::Builder getVal();
  inline void setVal( ::mas::schema::grid::Grid::Value::Reader value);
  inline  ::mas::schema::grid::Grid::Value::Builder initVal();
  inline void adoptVal(::capnp::Orphan< ::mas::schema::grid::Grid::Value>&& value);
  inline ::capnp::Orphan< ::mas::schema::grid::Grid::Value> disownVal();

  inline bool hasTl();
  inline  ::mas::schema::grid::Grid::RowCol::Builder getTl();
  inline void setTl( ::mas::schema::grid::Grid::RowCol::Reader value);
  inline  ::mas::schema::grid::Grid::RowCol::Builder initTl();
  inline void adoptTl(::capnp::Orphan< ::mas::schema::grid::Grid::RowCol>&& value);
  inline ::capnp::Orphan< ::mas::schema::grid::Grid::RowCol> disownTl();

  inline bool hasBr();
  inline  ::mas::schema::grid::Grid::RowCol::Builder getBr();
  inline void setBr( ::mas::schema::grid::Grid::RowCol::Reader value);
  inline  ::mas::schema::grid::Grid::RowCol::Builder initBr();
  inline void adoptBr(::capnp::Orphan< ::mas::schema::grid::Grid::RowCol>&& value);
  inline ::capnp::Orphan< ::mas::schema::grid::Grid::RowCol> disownBr();

  inline bool hasAggParts();
  inline  ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>::Builder getAggParts();
  inline void setAggParts( ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>::Builder initAggParts(unsigned int size);
  inline void adoptAggParts(::capnp::Orphan< ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>> disownAggParts();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Grid::ClosestValueAtResults::Pipeline {
public:
  typedef ClosestValueAtResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::grid::Grid::Value::Pipeline getVal();
  inline  ::mas::schema::grid::Grid::RowCol::Pipeline getTl();
  inline  ::mas::schema::grid::Grid::RowCol::Pipeline getBr();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Grid::ResolutionParams::Reader {
public:
  typedef ResolutionParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Grid::ResolutionParams::Builder {
public:
  typedef ResolutionParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Grid::ResolutionParams::Pipeline {
public:
  typedef ResolutionParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Grid::ResolutionResults::Reader {
public:
  typedef ResolutionResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getRes() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Grid::ResolutionResults::Builder {
public:
  typedef ResolutionResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getRes();
  inline void setRes( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Grid::ResolutionResults::Pipeline {
public:
  typedef ResolutionResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Grid::DimensionParams::Reader {
public:
  typedef DimensionParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Grid::DimensionParams::Builder {
public:
  typedef DimensionParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Grid::DimensionParams::Pipeline {
public:
  typedef DimensionParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Grid::DimensionResults::Reader {
public:
  typedef DimensionResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getRows() const;

  inline  ::uint64_t getCols() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Grid::DimensionResults::Builder {
public:
  typedef DimensionResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getRows();
  inline void setRows( ::uint64_t value);

  inline  ::uint64_t getCols();
  inline void setCols( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Grid::DimensionResults::Pipeline {
public:
  typedef DimensionResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Grid::NoDataValueParams::Reader {
public:
  typedef NoDataValueParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Grid::NoDataValueParams::Builder {
public:
  typedef NoDataValueParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Grid::NoDataValueParams::Pipeline {
public:
  typedef NoDataValueParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Grid::NoDataValueResults::Reader {
public:
  typedef NoDataValueResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasNodata() const;
  inline  ::mas::schema::grid::Grid::Value::Reader getNodata() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Grid::NoDataValueResults::Builder {
public:
  typedef NoDataValueResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasNodata();
  inline  ::mas::schema::grid::Grid::Value::Builder getNodata();
  inline void setNodata( ::mas::schema::grid::Grid::Value::Reader value);
  inline  ::mas::schema::grid::Grid::Value::Builder initNodata();
  inline void adoptNodata(::capnp::Orphan< ::mas::schema::grid::Grid::Value>&& value);
  inline ::capnp::Orphan< ::mas::schema::grid::Grid::Value> disownNodata();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Grid::NoDataValueResults::Pipeline {
public:
  typedef NoDataValueResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::grid::Grid::Value::Pipeline getNodata();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Grid::ValueAtParams::Reader {
public:
  typedef ValueAtParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getRow() const;

  inline  ::uint64_t getCol() const;

  inline  ::uint64_t getResolution() const;

  inline  ::mas::schema::grid::Aggregation getAgg() const;

  inline bool getIncludeAggParts() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Grid::ValueAtParams::Builder {
public:
  typedef ValueAtParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getRow();
  inline void setRow( ::uint64_t value);

  inline  ::uint64_t getCol();
  inline void setCol( ::uint64_t value);

  inline  ::uint64_t getResolution();
  inline void setResolution( ::uint64_t value);

  inline  ::mas::schema::grid::Aggregation getAgg();
  inline void setAgg( ::mas::schema::grid::Aggregation value);

  inline bool getIncludeAggParts();
  inline void setIncludeAggParts(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Grid::ValueAtParams::Pipeline {
public:
  typedef ValueAtParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Grid::ValueAtResults::Reader {
public:
  typedef ValueAtResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasVal() const;
  inline  ::mas::schema::grid::Grid::Value::Reader getVal() const;

  inline bool hasAggParts() const;
  inline  ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>::Reader getAggParts() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Grid::ValueAtResults::Builder {
public:
  typedef ValueAtResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasVal();
  inline  ::mas::schema::grid::Grid::Value::Builder getVal();
  inline void setVal( ::mas::schema::grid::Grid::Value::Reader value);
  inline  ::mas::schema::grid::Grid::Value::Builder initVal();
  inline void adoptVal(::capnp::Orphan< ::mas::schema::grid::Grid::Value>&& value);
  inline ::capnp::Orphan< ::mas::schema::grid::Grid::Value> disownVal();

  inline bool hasAggParts();
  inline  ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>::Builder getAggParts();
  inline void setAggParts( ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>::Builder initAggParts(unsigned int size);
  inline void adoptAggParts(::capnp::Orphan< ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>> disownAggParts();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Grid::ValueAtResults::Pipeline {
public:
  typedef ValueAtResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::grid::Grid::Value::Pipeline getVal();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Grid::LatLonBoundsParams::Reader {
public:
  typedef LatLonBoundsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getUseCellCenter() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Grid::LatLonBoundsParams::Builder {
public:
  typedef LatLonBoundsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getUseCellCenter();
  inline void setUseCellCenter(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Grid::LatLonBoundsParams::Pipeline {
public:
  typedef LatLonBoundsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Grid::LatLonBoundsResults::Reader {
public:
  typedef LatLonBoundsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTl() const;
  inline  ::mas::schema::geo::LatLonCoord::Reader getTl() const;

  inline bool hasTr() const;
  inline  ::mas::schema::geo::LatLonCoord::Reader getTr() const;

  inline bool hasBr() const;
  inline  ::mas::schema::geo::LatLonCoord::Reader getBr() const;

  inline bool hasBl() const;
  inline  ::mas::schema::geo::LatLonCoord::Reader getBl() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Grid::LatLonBoundsResults::Builder {
public:
  typedef LatLonBoundsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTl();
  inline  ::mas::schema::geo::LatLonCoord::Builder getTl();
  inline void setTl( ::mas::schema::geo::LatLonCoord::Reader value);
  inline  ::mas::schema::geo::LatLonCoord::Builder initTl();
  inline void adoptTl(::capnp::Orphan< ::mas::schema::geo::LatLonCoord>&& value);
  inline ::capnp::Orphan< ::mas::schema::geo::LatLonCoord> disownTl();

  inline bool hasTr();
  inline  ::mas::schema::geo::LatLonCoord::Builder getTr();
  inline void setTr( ::mas::schema::geo::LatLonCoord::Reader value);
  inline  ::mas::schema::geo::LatLonCoord::Builder initTr();
  inline void adoptTr(::capnp::Orphan< ::mas::schema::geo::LatLonCoord>&& value);
  inline ::capnp::Orphan< ::mas::schema::geo::LatLonCoord> disownTr();

  inline bool hasBr();
  inline  ::mas::schema::geo::LatLonCoord::Builder getBr();
  inline void setBr( ::mas::schema::geo::LatLonCoord::Reader value);
  inline  ::mas::schema::geo::LatLonCoord::Builder initBr();
  inline void adoptBr(::capnp::Orphan< ::mas::schema::geo::LatLonCoord>&& value);
  inline ::capnp::Orphan< ::mas::schema::geo::LatLonCoord> disownBr();

  inline bool hasBl();
  inline  ::mas::schema::geo::LatLonCoord::Builder getBl();
  inline void setBl( ::mas::schema::geo::LatLonCoord::Reader value);
  inline  ::mas::schema::geo::LatLonCoord::Builder initBl();
  inline void adoptBl(::capnp::Orphan< ::mas::schema::geo::LatLonCoord>&& value);
  inline ::capnp::Orphan< ::mas::schema::geo::LatLonCoord> disownBl();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Grid::LatLonBoundsResults::Pipeline {
public:
  typedef LatLonBoundsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::geo::LatLonCoord::Pipeline getTl();
  inline  ::mas::schema::geo::LatLonCoord::Pipeline getTr();
  inline  ::mas::schema::geo::LatLonCoord::Pipeline getBr();
  inline  ::mas::schema::geo::LatLonCoord::Pipeline getBl();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Grid::StreamCellsParams::Reader {
public:
  typedef StreamCellsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCallback() const;
#if !CAPNP_LITE
  inline  ::mas::schema::grid::Grid::Callback::Client getCallback() const;
#endif  // !CAPNP_LITE

  inline  ::uint64_t getMaxNoOfCellsPerSend() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Grid::StreamCellsParams::Builder {
public:
  typedef StreamCellsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCallback();
#if !CAPNP_LITE
  inline  ::mas::schema::grid::Grid::Callback::Client getCallback();
  inline void setCallback( ::mas::schema::grid::Grid::Callback::Client&& value);
  inline void setCallback( ::mas::schema::grid::Grid::Callback::Client& value);
  inline void adoptCallback(::capnp::Orphan< ::mas::schema::grid::Grid::Callback>&& value);
  inline ::capnp::Orphan< ::mas::schema::grid::Grid::Callback> disownCallback();
#endif  // !CAPNP_LITE

  inline  ::uint64_t getMaxNoOfCellsPerSend();
  inline void setMaxNoOfCellsPerSend( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Grid::StreamCellsParams::Pipeline {
public:
  typedef StreamCellsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mas::schema::grid::Grid::Callback::Client getCallback();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Grid::StreamCellsResults::Reader {
public:
  typedef StreamCellsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Grid::StreamCellsResults::Builder {
public:
  typedef StreamCellsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Grid::StreamCellsResults::Pipeline {
public:
  typedef StreamCellsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

#if !CAPNP_LITE
inline Grid::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Grid::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Grid::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Grid::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Grid::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::grid::Grid::Client& Grid::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::grid::Grid::Client& Grid::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline  ::mas::schema::grid::Grid::Value::Which Grid::Value::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline  ::mas::schema::grid::Grid::Value::Which Grid::Value::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline bool Grid::Value::Reader::isF() const {
  return which() == Grid::Value::F;
}
inline bool Grid::Value::Builder::isF() {
  return which() == Grid::Value::F;
}
inline double Grid::Value::Reader::getF() const {
  KJ_IREQUIRE((which() == Grid::Value::F),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Grid::Value::Builder::getF() {
  KJ_IREQUIRE((which() == Grid::Value::F),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Grid::Value::Builder::setF(double value) {
  _builder.setDataField<Grid::Value::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Grid::Value::F);
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Grid::Value::Reader::isI() const {
  return which() == Grid::Value::I;
}
inline bool Grid::Value::Builder::isI() {
  return which() == Grid::Value::I;
}
inline  ::int64_t Grid::Value::Reader::getI() const {
  KJ_IREQUIRE((which() == Grid::Value::I),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int64_t Grid::Value::Builder::getI() {
  KJ_IREQUIRE((which() == Grid::Value::I),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Grid::Value::Builder::setI( ::int64_t value) {
  _builder.setDataField<Grid::Value::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Grid::Value::I);
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Grid::Value::Reader::isUi() const {
  return which() == Grid::Value::UI;
}
inline bool Grid::Value::Builder::isUi() {
  return which() == Grid::Value::UI;
}
inline  ::uint64_t Grid::Value::Reader::getUi() const {
  KJ_IREQUIRE((which() == Grid::Value::UI),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Grid::Value::Builder::getUi() {
  KJ_IREQUIRE((which() == Grid::Value::UI),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Grid::Value::Builder::setUi( ::uint64_t value) {
  _builder.setDataField<Grid::Value::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Grid::Value::UI);
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Grid::Value::Reader::isNo() const {
  return which() == Grid::Value::NO;
}
inline bool Grid::Value::Builder::isNo() {
  return which() == Grid::Value::NO;
}
inline bool Grid::Value::Reader::getNo() const {
  KJ_IREQUIRE((which() == Grid::Value::NO),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Grid::Value::Builder::getNo() {
  KJ_IREQUIRE((which() == Grid::Value::NO),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Grid::Value::Builder::setNo(bool value) {
  _builder.setDataField<Grid::Value::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Grid::Value::NO);
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Grid::RowCol::Reader::getRow() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Grid::RowCol::Builder::getRow() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Grid::RowCol::Builder::setRow( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Grid::RowCol::Reader::getCol() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Grid::RowCol::Builder::getCol() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Grid::RowCol::Builder::setCol( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Grid::AggregationPart::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Grid::AggregationPart::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::grid::Grid::Value::Reader Grid::AggregationPart::Reader::getValue() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Value>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::grid::Grid::Value::Builder Grid::AggregationPart::Builder::getValue() {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Value>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::grid::Grid::Value::Pipeline Grid::AggregationPart::Pipeline::getValue() {
  return  ::mas::schema::grid::Grid::Value::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Grid::AggregationPart::Builder::setValue( ::mas::schema::grid::Grid::Value::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Value>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::grid::Grid::Value::Builder Grid::AggregationPart::Builder::initValue() {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Value>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Grid::AggregationPart::Builder::adoptValue(
    ::capnp::Orphan< ::mas::schema::grid::Grid::Value>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Value>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::grid::Grid::Value> Grid::AggregationPart::Builder::disownValue() {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Value>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Grid::AggregationPart::Reader::hasRowCol() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Grid::AggregationPart::Builder::hasRowCol() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::grid::Grid::RowCol::Reader Grid::AggregationPart::Reader::getRowCol() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::RowCol>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::grid::Grid::RowCol::Builder Grid::AggregationPart::Builder::getRowCol() {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::RowCol>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::grid::Grid::RowCol::Pipeline Grid::AggregationPart::Pipeline::getRowCol() {
  return  ::mas::schema::grid::Grid::RowCol::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Grid::AggregationPart::Builder::setRowCol( ::mas::schema::grid::Grid::RowCol::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::RowCol>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::grid::Grid::RowCol::Builder Grid::AggregationPart::Builder::initRowCol() {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::RowCol>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Grid::AggregationPart::Builder::adoptRowCol(
    ::capnp::Orphan< ::mas::schema::grid::Grid::RowCol>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::RowCol>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::grid::Grid::RowCol> Grid::AggregationPart::Builder::disownRowCol() {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::RowCol>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline double Grid::AggregationPart::Reader::getAreaFrac() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Grid::AggregationPart::Builder::getAreaFrac() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Grid::AggregationPart::Builder::setAreaFrac(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Grid::AggregationPart::Reader::getIValue() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Grid::AggregationPart::Builder::getIValue() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Grid::AggregationPart::Builder::setIValue(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

#if !CAPNP_LITE
inline Grid::Callback::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Grid::Callback::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Grid::Callback::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Grid::Callback::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Grid::Callback::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::mas::schema::grid::Grid::Callback::Client& Grid::Callback::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::mas::schema::grid::Grid::Callback::Client& Grid::Callback::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Grid::Callback::SendCellsParams::Reader::hasCells() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Grid::Callback::SendCellsParams::Builder::hasCells() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::grid::Grid::RowCol,  ::capnp::Kind::STRUCT>::Reader Grid::Callback::SendCellsParams::Reader::getCells() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::grid::Grid::RowCol,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::grid::Grid::RowCol,  ::capnp::Kind::STRUCT>::Builder Grid::Callback::SendCellsParams::Builder::getCells() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::grid::Grid::RowCol,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Grid::Callback::SendCellsParams::Builder::setCells( ::capnp::List< ::mas::schema::grid::Grid::RowCol,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::grid::Grid::RowCol,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::grid::Grid::RowCol,  ::capnp::Kind::STRUCT>::Builder Grid::Callback::SendCellsParams::Builder::initCells(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::grid::Grid::RowCol,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Grid::Callback::SendCellsParams::Builder::adoptCells(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::grid::Grid::RowCol,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::grid::Grid::RowCol,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::grid::Grid::RowCol,  ::capnp::Kind::STRUCT>> Grid::Callback::SendCellsParams::Builder::disownCells() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::grid::Grid::RowCol,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Grid::ClosestValueAtParams::Reader::hasLatlonCoord() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Grid::ClosestValueAtParams::Builder::hasLatlonCoord() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::geo::LatLonCoord::Reader Grid::ClosestValueAtParams::Reader::getLatlonCoord() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::geo::LatLonCoord::Builder Grid::ClosestValueAtParams::Builder::getLatlonCoord() {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::geo::LatLonCoord::Pipeline Grid::ClosestValueAtParams::Pipeline::getLatlonCoord() {
  return  ::mas::schema::geo::LatLonCoord::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Grid::ClosestValueAtParams::Builder::setLatlonCoord( ::mas::schema::geo::LatLonCoord::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::geo::LatLonCoord::Builder Grid::ClosestValueAtParams::Builder::initLatlonCoord() {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Grid::ClosestValueAtParams::Builder::adoptLatlonCoord(
    ::capnp::Orphan< ::mas::schema::geo::LatLonCoord>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::geo::LatLonCoord> Grid::ClosestValueAtParams::Builder::disownLatlonCoord() {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Grid::ClosestValueAtParams::Reader::getIgnoreNoData() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, true);
}

inline bool Grid::ClosestValueAtParams::Builder::getIgnoreNoData() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, true);
}
inline void Grid::ClosestValueAtParams::Builder::setIgnoreNoData(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, true);
}

inline  ::uint64_t Grid::ClosestValueAtParams::Reader::getResolution() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Grid::ClosestValueAtParams::Builder::getResolution() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Grid::ClosestValueAtParams::Builder::setResolution( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::mas::schema::grid::Aggregation Grid::ClosestValueAtParams::Reader::getAgg() const {
  return _reader.getDataField< ::mas::schema::grid::Aggregation>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::grid::Aggregation Grid::ClosestValueAtParams::Builder::getAgg() {
  return _builder.getDataField< ::mas::schema::grid::Aggregation>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Grid::ClosestValueAtParams::Builder::setAgg( ::mas::schema::grid::Aggregation value) {
  _builder.setDataField< ::mas::schema::grid::Aggregation>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Grid::ClosestValueAtParams::Reader::getReturnRowCols() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool Grid::ClosestValueAtParams::Builder::getReturnRowCols() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Grid::ClosestValueAtParams::Builder::setReturnRowCols(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Grid::ClosestValueAtParams::Reader::getIncludeAggParts() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline bool Grid::ClosestValueAtParams::Builder::getIncludeAggParts() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Grid::ClosestValueAtParams::Builder::setIncludeAggParts(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Grid::ClosestValueAtResults::Reader::hasVal() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Grid::ClosestValueAtResults::Builder::hasVal() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::grid::Grid::Value::Reader Grid::ClosestValueAtResults::Reader::getVal() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Value>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::grid::Grid::Value::Builder Grid::ClosestValueAtResults::Builder::getVal() {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Value>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::grid::Grid::Value::Pipeline Grid::ClosestValueAtResults::Pipeline::getVal() {
  return  ::mas::schema::grid::Grid::Value::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Grid::ClosestValueAtResults::Builder::setVal( ::mas::schema::grid::Grid::Value::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Value>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::grid::Grid::Value::Builder Grid::ClosestValueAtResults::Builder::initVal() {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Value>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Grid::ClosestValueAtResults::Builder::adoptVal(
    ::capnp::Orphan< ::mas::schema::grid::Grid::Value>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Value>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::grid::Grid::Value> Grid::ClosestValueAtResults::Builder::disownVal() {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Value>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Grid::ClosestValueAtResults::Reader::hasTl() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Grid::ClosestValueAtResults::Builder::hasTl() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::grid::Grid::RowCol::Reader Grid::ClosestValueAtResults::Reader::getTl() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::RowCol>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::grid::Grid::RowCol::Builder Grid::ClosestValueAtResults::Builder::getTl() {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::RowCol>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::grid::Grid::RowCol::Pipeline Grid::ClosestValueAtResults::Pipeline::getTl() {
  return  ::mas::schema::grid::Grid::RowCol::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Grid::ClosestValueAtResults::Builder::setTl( ::mas::schema::grid::Grid::RowCol::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::RowCol>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::grid::Grid::RowCol::Builder Grid::ClosestValueAtResults::Builder::initTl() {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::RowCol>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Grid::ClosestValueAtResults::Builder::adoptTl(
    ::capnp::Orphan< ::mas::schema::grid::Grid::RowCol>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::RowCol>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::grid::Grid::RowCol> Grid::ClosestValueAtResults::Builder::disownTl() {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::RowCol>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Grid::ClosestValueAtResults::Reader::hasBr() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Grid::ClosestValueAtResults::Builder::hasBr() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::grid::Grid::RowCol::Reader Grid::ClosestValueAtResults::Reader::getBr() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::RowCol>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::mas::schema::grid::Grid::RowCol::Builder Grid::ClosestValueAtResults::Builder::getBr() {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::RowCol>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::grid::Grid::RowCol::Pipeline Grid::ClosestValueAtResults::Pipeline::getBr() {
  return  ::mas::schema::grid::Grid::RowCol::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Grid::ClosestValueAtResults::Builder::setBr( ::mas::schema::grid::Grid::RowCol::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::RowCol>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::grid::Grid::RowCol::Builder Grid::ClosestValueAtResults::Builder::initBr() {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::RowCol>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Grid::ClosestValueAtResults::Builder::adoptBr(
    ::capnp::Orphan< ::mas::schema::grid::Grid::RowCol>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::RowCol>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::grid::Grid::RowCol> Grid::ClosestValueAtResults::Builder::disownBr() {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::RowCol>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Grid::ClosestValueAtResults::Reader::hasAggParts() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Grid::ClosestValueAtResults::Builder::hasAggParts() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>::Reader Grid::ClosestValueAtResults::Reader::getAggParts() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>::Builder Grid::ClosestValueAtResults::Builder::getAggParts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Grid::ClosestValueAtResults::Builder::setAggParts( ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>::Builder Grid::ClosestValueAtResults::Builder::initAggParts(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void Grid::ClosestValueAtResults::Builder::adoptAggParts(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>> Grid::ClosestValueAtResults::Builder::disownAggParts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline  ::uint64_t Grid::ResolutionResults::Reader::getRes() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Grid::ResolutionResults::Builder::getRes() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Grid::ResolutionResults::Builder::setRes( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Grid::DimensionResults::Reader::getRows() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Grid::DimensionResults::Builder::getRows() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Grid::DimensionResults::Builder::setRows( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Grid::DimensionResults::Reader::getCols() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Grid::DimensionResults::Builder::getCols() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Grid::DimensionResults::Builder::setCols( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Grid::NoDataValueResults::Reader::hasNodata() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Grid::NoDataValueResults::Builder::hasNodata() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::grid::Grid::Value::Reader Grid::NoDataValueResults::Reader::getNodata() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Value>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::grid::Grid::Value::Builder Grid::NoDataValueResults::Builder::getNodata() {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Value>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::grid::Grid::Value::Pipeline Grid::NoDataValueResults::Pipeline::getNodata() {
  return  ::mas::schema::grid::Grid::Value::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Grid::NoDataValueResults::Builder::setNodata( ::mas::schema::grid::Grid::Value::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Value>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::grid::Grid::Value::Builder Grid::NoDataValueResults::Builder::initNodata() {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Value>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Grid::NoDataValueResults::Builder::adoptNodata(
    ::capnp::Orphan< ::mas::schema::grid::Grid::Value>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Value>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::grid::Grid::Value> Grid::NoDataValueResults::Builder::disownNodata() {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Value>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t Grid::ValueAtParams::Reader::getRow() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Grid::ValueAtParams::Builder::getRow() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Grid::ValueAtParams::Builder::setRow( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Grid::ValueAtParams::Reader::getCol() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Grid::ValueAtParams::Builder::getCol() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Grid::ValueAtParams::Builder::setCol( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Grid::ValueAtParams::Reader::getResolution() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Grid::ValueAtParams::Builder::getResolution() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Grid::ValueAtParams::Builder::setResolution( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::mas::schema::grid::Aggregation Grid::ValueAtParams::Reader::getAgg() const {
  return _reader.getDataField< ::mas::schema::grid::Aggregation>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS);
}

inline  ::mas::schema::grid::Aggregation Grid::ValueAtParams::Builder::getAgg() {
  return _builder.getDataField< ::mas::schema::grid::Aggregation>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS);
}
inline void Grid::ValueAtParams::Builder::setAgg( ::mas::schema::grid::Aggregation value) {
  _builder.setDataField< ::mas::schema::grid::Aggregation>(
      ::capnp::bounded<12>() * ::capnp::ELEMENTS, value);
}

inline bool Grid::ValueAtParams::Reader::getIncludeAggParts() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<208>() * ::capnp::ELEMENTS);
}

inline bool Grid::ValueAtParams::Builder::getIncludeAggParts() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<208>() * ::capnp::ELEMENTS);
}
inline void Grid::ValueAtParams::Builder::setIncludeAggParts(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<208>() * ::capnp::ELEMENTS, value);
}

inline bool Grid::ValueAtResults::Reader::hasVal() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Grid::ValueAtResults::Builder::hasVal() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::grid::Grid::Value::Reader Grid::ValueAtResults::Reader::getVal() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Value>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::grid::Grid::Value::Builder Grid::ValueAtResults::Builder::getVal() {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Value>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::grid::Grid::Value::Pipeline Grid::ValueAtResults::Pipeline::getVal() {
  return  ::mas::schema::grid::Grid::Value::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Grid::ValueAtResults::Builder::setVal( ::mas::schema::grid::Grid::Value::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Value>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::grid::Grid::Value::Builder Grid::ValueAtResults::Builder::initVal() {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Value>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Grid::ValueAtResults::Builder::adoptVal(
    ::capnp::Orphan< ::mas::schema::grid::Grid::Value>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Value>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::grid::Grid::Value> Grid::ValueAtResults::Builder::disownVal() {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Value>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Grid::ValueAtResults::Reader::hasAggParts() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Grid::ValueAtResults::Builder::hasAggParts() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>::Reader Grid::ValueAtResults::Reader::getAggParts() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>::Builder Grid::ValueAtResults::Builder::getAggParts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Grid::ValueAtResults::Builder::setAggParts( ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>::Builder Grid::ValueAtResults::Builder::initAggParts(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Grid::ValueAtResults::Builder::adoptAggParts(
    ::capnp::Orphan< ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>> Grid::ValueAtResults::Builder::disownAggParts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mas::schema::grid::Grid::AggregationPart,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Grid::LatLonBoundsParams::Reader::getUseCellCenter() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Grid::LatLonBoundsParams::Builder::getUseCellCenter() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Grid::LatLonBoundsParams::Builder::setUseCellCenter(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Grid::LatLonBoundsResults::Reader::hasTl() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Grid::LatLonBoundsResults::Builder::hasTl() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::geo::LatLonCoord::Reader Grid::LatLonBoundsResults::Reader::getTl() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::geo::LatLonCoord::Builder Grid::LatLonBoundsResults::Builder::getTl() {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::geo::LatLonCoord::Pipeline Grid::LatLonBoundsResults::Pipeline::getTl() {
  return  ::mas::schema::geo::LatLonCoord::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Grid::LatLonBoundsResults::Builder::setTl( ::mas::schema::geo::LatLonCoord::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::geo::LatLonCoord::Builder Grid::LatLonBoundsResults::Builder::initTl() {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Grid::LatLonBoundsResults::Builder::adoptTl(
    ::capnp::Orphan< ::mas::schema::geo::LatLonCoord>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::geo::LatLonCoord> Grid::LatLonBoundsResults::Builder::disownTl() {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Grid::LatLonBoundsResults::Reader::hasTr() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Grid::LatLonBoundsResults::Builder::hasTr() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::geo::LatLonCoord::Reader Grid::LatLonBoundsResults::Reader::getTr() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mas::schema::geo::LatLonCoord::Builder Grid::LatLonBoundsResults::Builder::getTr() {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::geo::LatLonCoord::Pipeline Grid::LatLonBoundsResults::Pipeline::getTr() {
  return  ::mas::schema::geo::LatLonCoord::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Grid::LatLonBoundsResults::Builder::setTr( ::mas::schema::geo::LatLonCoord::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::geo::LatLonCoord::Builder Grid::LatLonBoundsResults::Builder::initTr() {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Grid::LatLonBoundsResults::Builder::adoptTr(
    ::capnp::Orphan< ::mas::schema::geo::LatLonCoord>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::geo::LatLonCoord> Grid::LatLonBoundsResults::Builder::disownTr() {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Grid::LatLonBoundsResults::Reader::hasBr() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Grid::LatLonBoundsResults::Builder::hasBr() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::geo::LatLonCoord::Reader Grid::LatLonBoundsResults::Reader::getBr() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::mas::schema::geo::LatLonCoord::Builder Grid::LatLonBoundsResults::Builder::getBr() {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::geo::LatLonCoord::Pipeline Grid::LatLonBoundsResults::Pipeline::getBr() {
  return  ::mas::schema::geo::LatLonCoord::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Grid::LatLonBoundsResults::Builder::setBr( ::mas::schema::geo::LatLonCoord::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::geo::LatLonCoord::Builder Grid::LatLonBoundsResults::Builder::initBr() {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Grid::LatLonBoundsResults::Builder::adoptBr(
    ::capnp::Orphan< ::mas::schema::geo::LatLonCoord>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::geo::LatLonCoord> Grid::LatLonBoundsResults::Builder::disownBr() {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Grid::LatLonBoundsResults::Reader::hasBl() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Grid::LatLonBoundsResults::Builder::hasBl() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::mas::schema::geo::LatLonCoord::Reader Grid::LatLonBoundsResults::Reader::getBl() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::mas::schema::geo::LatLonCoord::Builder Grid::LatLonBoundsResults::Builder::getBl() {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mas::schema::geo::LatLonCoord::Pipeline Grid::LatLonBoundsResults::Pipeline::getBl() {
  return  ::mas::schema::geo::LatLonCoord::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void Grid::LatLonBoundsResults::Builder::setBl( ::mas::schema::geo::LatLonCoord::Reader value) {
  ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::mas::schema::geo::LatLonCoord::Builder Grid::LatLonBoundsResults::Builder::initBl() {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Grid::LatLonBoundsResults::Builder::adoptBl(
    ::capnp::Orphan< ::mas::schema::geo::LatLonCoord>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::geo::LatLonCoord> Grid::LatLonBoundsResults::Builder::disownBl() {
  return ::capnp::_::PointerHelpers< ::mas::schema::geo::LatLonCoord>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Grid::StreamCellsParams::Reader::hasCallback() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Grid::StreamCellsParams::Builder::hasCallback() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::mas::schema::grid::Grid::Callback::Client Grid::StreamCellsParams::Reader::getCallback() const {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Callback>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::grid::Grid::Callback::Client Grid::StreamCellsParams::Builder::getCallback() {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Callback>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mas::schema::grid::Grid::Callback::Client Grid::StreamCellsParams::Pipeline::getCallback() {
  return  ::mas::schema::grid::Grid::Callback::Client(_typeless.getPointerField(0).asCap());
}
inline void Grid::StreamCellsParams::Builder::setCallback( ::mas::schema::grid::Grid::Callback::Client&& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Callback>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Grid::StreamCellsParams::Builder::setCallback( ::mas::schema::grid::Grid::Callback::Client& cap) {
  ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Callback>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Grid::StreamCellsParams::Builder::adoptCallback(
    ::capnp::Orphan< ::mas::schema::grid::Grid::Callback>&& value) {
  ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Callback>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mas::schema::grid::Grid::Callback> Grid::StreamCellsParams::Builder::disownCallback() {
  return ::capnp::_::PointerHelpers< ::mas::schema::grid::Grid::Callback>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline  ::uint64_t Grid::StreamCellsParams::Reader::getMaxNoOfCellsPerSend() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 100ull);
}

inline  ::uint64_t Grid::StreamCellsParams::Builder::getMaxNoOfCellsPerSend() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, 100ull);
}
inline void Grid::StreamCellsParams::Builder::setMaxNoOfCellsPerSend( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value, 100ull);
}

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

