// Code generated by capnpc-go. DO NOT EDIT.

package fbp

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	context "context"
	common "github.com/zalf-rpm/mas-infrastructure/capnproto_schemas/gen/go/common"
	persistence "github.com/zalf-rpm/mas-infrastructure/capnproto_schemas/gen/go/persistence"
	strconv "strconv"
)

type IP capnp.Struct

// IP_TypeID is the unique identifier for the type IP.
const IP_TypeID = 0xaf0a1dc4709a5ccf

func NewIP(s *capnp.Segment) (IP, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return IP(st), err
}

func NewRootIP(s *capnp.Segment) (IP, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return IP(st), err
}

func ReadRootIP(msg *capnp.Message) (IP, error) {
	root, err := msg.Root()
	return IP(root.Struct()), err
}

func (s IP) String() string {
	str, _ := text.Marshal(0xaf0a1dc4709a5ccf, capnp.Struct(s))
	return str
}

func (s IP) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IP) DecodeFromPtr(p capnp.Ptr) IP {
	return IP(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IP) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IP) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IP) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IP) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IP) Attributes() (IP_KV_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return IP_KV_List(p.List()), err
}

func (s IP) HasAttributes() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IP) SetAttributes(v IP_KV_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewAttributes sets the attributes field to a newly
// allocated IP_KV_List, preferring placement in s's segment.
func (s IP) NewAttributes(n int32) (IP_KV_List, error) {
	l, err := NewIP_KV_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return IP_KV_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s IP) Content() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(1)
}

func (s IP) HasContent() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s IP) SetContent(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(1, v)
}

// IP_List is a list of IP.
type IP_List = capnp.StructList[IP]

// NewIP creates a new list of IP.
func NewIP_List(s *capnp.Segment, sz int32) (IP_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[IP](l), err
}

// IP_Future is a wrapper for a IP promised by a client call.
type IP_Future struct{ *capnp.Future }

func (f IP_Future) Struct() (IP, error) {
	p, err := f.Future.Ptr()
	return IP(p.Struct()), err
}
func (p IP_Future) Content() *capnp.Future {
	return p.Future.Field(1, nil)
}

type IP_KV capnp.Struct

// IP_KV_TypeID is the unique identifier for the type IP_KV.
const IP_KV_TypeID = 0x9e9e5391e0c499e6

func NewIP_KV(s *capnp.Segment) (IP_KV, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return IP_KV(st), err
}

func NewRootIP_KV(s *capnp.Segment) (IP_KV, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return IP_KV(st), err
}

func ReadRootIP_KV(msg *capnp.Message) (IP_KV, error) {
	root, err := msg.Root()
	return IP_KV(root.Struct()), err
}

func (s IP_KV) String() string {
	str, _ := text.Marshal(0x9e9e5391e0c499e6, capnp.Struct(s))
	return str
}

func (s IP_KV) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IP_KV) DecodeFromPtr(p capnp.Ptr) IP_KV {
	return IP_KV(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IP_KV) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IP_KV) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IP_KV) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IP_KV) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IP_KV) Key() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s IP_KV) HasKey() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IP_KV) KeyBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s IP_KV) SetKey(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s IP_KV) Value() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(1)
}

func (s IP_KV) HasValue() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s IP_KV) SetValue(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(1, v)
}

// IP_KV_List is a list of IP_KV.
type IP_KV_List = capnp.StructList[IP_KV]

// NewIP_KV creates a new list of IP_KV.
func NewIP_KV_List(s *capnp.Segment, sz int32) (IP_KV_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[IP_KV](l), err
}

// IP_KV_Future is a wrapper for a IP_KV promised by a client call.
type IP_KV_Future struct{ *capnp.Future }

func (f IP_KV_Future) Struct() (IP_KV, error) {
	p, err := f.Future.Ptr()
	return IP_KV(p.Struct()), err
}
func (p IP_KV_Future) Value() *capnp.Future {
	return p.Future.Field(1, nil)
}

type Channel capnp.Client

// Channel_TypeID is the unique identifier for the type Channel.
const Channel_TypeID = 0x9c62c32b2ff2b1e8

func (c Channel) SetBufferSize(ctx context.Context, params func(Channel_setBufferSize_Params) error) (Channel_setBufferSize_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x9c62c32b2ff2b1e8,
			MethodID:      0,
			InterfaceName: "fbp.capnp:Channel",
			MethodName:    "setBufferSize",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 8, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Channel_setBufferSize_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Channel_setBufferSize_Results_Future{Future: ans.Future()}, release

}

func (c Channel) Reader(ctx context.Context, params func(Channel_reader_Params) error) (Channel_reader_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x9c62c32b2ff2b1e8,
			MethodID:      1,
			InterfaceName: "fbp.capnp:Channel",
			MethodName:    "reader",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Channel_reader_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Channel_reader_Results_Future{Future: ans.Future()}, release

}

func (c Channel) Writer(ctx context.Context, params func(Channel_writer_Params) error) (Channel_writer_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x9c62c32b2ff2b1e8,
			MethodID:      2,
			InterfaceName: "fbp.capnp:Channel",
			MethodName:    "writer",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Channel_writer_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Channel_writer_Results_Future{Future: ans.Future()}, release

}

func (c Channel) Endpoints(ctx context.Context, params func(Channel_endpoints_Params) error) (Channel_endpoints_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x9c62c32b2ff2b1e8,
			MethodID:      3,
			InterfaceName: "fbp.capnp:Channel",
			MethodName:    "endpoints",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Channel_endpoints_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Channel_endpoints_Results_Future{Future: ans.Future()}, release

}

func (c Channel) SetAutoCloseSemantics(ctx context.Context, params func(Channel_setAutoCloseSemantics_Params) error) (Channel_setAutoCloseSemantics_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x9c62c32b2ff2b1e8,
			MethodID:      4,
			InterfaceName: "fbp.capnp:Channel",
			MethodName:    "setAutoCloseSemantics",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 8, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Channel_setAutoCloseSemantics_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Channel_setAutoCloseSemantics_Results_Future{Future: ans.Future()}, release

}

func (c Channel) Close(ctx context.Context, params func(Channel_close_Params) error) (Channel_close_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x9c62c32b2ff2b1e8,
			MethodID:      5,
			InterfaceName: "fbp.capnp:Channel",
			MethodName:    "close",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 8, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Channel_close_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Channel_close_Results_Future{Future: ans.Future()}, release

}

func (c Channel) Info(ctx context.Context, params func(common.Identifiable_info_Params) error) (common.IdInformation_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xb2afd1cb599c48d5,
			MethodID:      0,
			InterfaceName: "common.capnp:Identifiable",
			MethodName:    "info",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(common.Identifiable_info_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return common.IdInformation_Future{Future: ans.Future()}, release

}

func (c Channel) Save(ctx context.Context, params func(persistence.Persistent_SaveParams) error) (persistence.Persistent_SaveResults_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xc1a7daa0dc36cb65,
			MethodID:      0,
			InterfaceName: "persistence.capnp:Persistent",
			MethodName:    "save",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(persistence.Persistent_SaveParams(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return persistence.Persistent_SaveResults_Future{Future: ans.Future()}, release

}

func (c Channel) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Channel) String() string {
	return "Channel(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Channel) AddRef() Channel {
	return Channel(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Channel) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Channel) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Channel) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Channel) DecodeFromPtr(p capnp.Ptr) Channel {
	return Channel(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Channel) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Channel) IsSame(other Channel) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Channel) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Channel) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Channel_Server is a Channel with a local implementation.
type Channel_Server interface {
	SetBufferSize(context.Context, Channel_setBufferSize) error

	Reader(context.Context, Channel_reader) error

	Writer(context.Context, Channel_writer) error

	Endpoints(context.Context, Channel_endpoints) error

	SetAutoCloseSemantics(context.Context, Channel_setAutoCloseSemantics) error

	Close(context.Context, Channel_close) error

	Info(context.Context, common.Identifiable_info) error

	Save(context.Context, persistence.Persistent_save) error
}

// Channel_NewServer creates a new Server from an implementation of Channel_Server.
func Channel_NewServer(s Channel_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Channel_Methods(nil, s), s, c)
}

// Channel_ServerToClient creates a new Client from an implementation of Channel_Server.
// The caller is responsible for calling Release on the returned Client.
func Channel_ServerToClient(s Channel_Server) Channel {
	return Channel(capnp.NewClient(Channel_NewServer(s)))
}

// Channel_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Channel_Methods(methods []server.Method, s Channel_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 8)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x9c62c32b2ff2b1e8,
			MethodID:      0,
			InterfaceName: "fbp.capnp:Channel",
			MethodName:    "setBufferSize",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.SetBufferSize(ctx, Channel_setBufferSize{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x9c62c32b2ff2b1e8,
			MethodID:      1,
			InterfaceName: "fbp.capnp:Channel",
			MethodName:    "reader",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Reader(ctx, Channel_reader{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x9c62c32b2ff2b1e8,
			MethodID:      2,
			InterfaceName: "fbp.capnp:Channel",
			MethodName:    "writer",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Writer(ctx, Channel_writer{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x9c62c32b2ff2b1e8,
			MethodID:      3,
			InterfaceName: "fbp.capnp:Channel",
			MethodName:    "endpoints",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Endpoints(ctx, Channel_endpoints{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x9c62c32b2ff2b1e8,
			MethodID:      4,
			InterfaceName: "fbp.capnp:Channel",
			MethodName:    "setAutoCloseSemantics",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.SetAutoCloseSemantics(ctx, Channel_setAutoCloseSemantics{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x9c62c32b2ff2b1e8,
			MethodID:      5,
			InterfaceName: "fbp.capnp:Channel",
			MethodName:    "close",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Close(ctx, Channel_close{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xb2afd1cb599c48d5,
			MethodID:      0,
			InterfaceName: "common.capnp:Identifiable",
			MethodName:    "info",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Info(ctx, common.Identifiable_info{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xc1a7daa0dc36cb65,
			MethodID:      0,
			InterfaceName: "persistence.capnp:Persistent",
			MethodName:    "save",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Save(ctx, persistence.Persistent_save{call})
		},
	})

	return methods
}

// Channel_setBufferSize holds the state for a server call to Channel.setBufferSize.
// See server.Call for documentation.
type Channel_setBufferSize struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Channel_setBufferSize) Args() Channel_setBufferSize_Params {
	return Channel_setBufferSize_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Channel_setBufferSize) AllocResults() (Channel_setBufferSize_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_setBufferSize_Results(r), err
}

// Channel_reader holds the state for a server call to Channel.reader.
// See server.Call for documentation.
type Channel_reader struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Channel_reader) Args() Channel_reader_Params {
	return Channel_reader_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Channel_reader) AllocResults() (Channel_reader_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Channel_reader_Results(r), err
}

// Channel_writer holds the state for a server call to Channel.writer.
// See server.Call for documentation.
type Channel_writer struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Channel_writer) Args() Channel_writer_Params {
	return Channel_writer_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Channel_writer) AllocResults() (Channel_writer_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Channel_writer_Results(r), err
}

// Channel_endpoints holds the state for a server call to Channel.endpoints.
// See server.Call for documentation.
type Channel_endpoints struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Channel_endpoints) Args() Channel_endpoints_Params {
	return Channel_endpoints_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Channel_endpoints) AllocResults() (Channel_endpoints_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Channel_endpoints_Results(r), err
}

// Channel_setAutoCloseSemantics holds the state for a server call to Channel.setAutoCloseSemantics.
// See server.Call for documentation.
type Channel_setAutoCloseSemantics struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Channel_setAutoCloseSemantics) Args() Channel_setAutoCloseSemantics_Params {
	return Channel_setAutoCloseSemantics_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Channel_setAutoCloseSemantics) AllocResults() (Channel_setAutoCloseSemantics_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_setAutoCloseSemantics_Results(r), err
}

// Channel_close holds the state for a server call to Channel.close.
// See server.Call for documentation.
type Channel_close struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Channel_close) Args() Channel_close_Params {
	return Channel_close_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Channel_close) AllocResults() (Channel_close_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_close_Results(r), err
}

// Channel_List is a list of Channel.
type Channel_List = capnp.CapList[Channel]

// NewChannel creates a new list of Channel.
func NewChannel_List(s *capnp.Segment, sz int32) (Channel_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Channel](l), err
}

type Channel_CloseSemantics uint16

// Channel_CloseSemantics_TypeID is the unique identifier for the type Channel_CloseSemantics.
const Channel_CloseSemantics_TypeID = 0xa8d787cae7e0b243

// Values of Channel_CloseSemantics.
const (
	Channel_CloseSemantics_fbp Channel_CloseSemantics = 0
	Channel_CloseSemantics_no  Channel_CloseSemantics = 1
)

// String returns the enum's constant name.
func (c Channel_CloseSemantics) String() string {
	switch c {
	case Channel_CloseSemantics_fbp:
		return "fbp"
	case Channel_CloseSemantics_no:
		return "no"

	default:
		return ""
	}
}

// Channel_CloseSemanticsFromString returns the enum value with a name,
// or the zero value if there's no such value.
func Channel_CloseSemanticsFromString(c string) Channel_CloseSemantics {
	switch c {
	case "fbp":
		return Channel_CloseSemantics_fbp
	case "no":
		return Channel_CloseSemantics_no

	default:
		return 0
	}
}

type Channel_CloseSemantics_List = capnp.EnumList[Channel_CloseSemantics]

func NewChannel_CloseSemantics_List(s *capnp.Segment, sz int32) (Channel_CloseSemantics_List, error) {
	return capnp.NewEnumList[Channel_CloseSemantics](s, sz)
}

type Channel_Msg capnp.Struct
type Channel_Msg_Which uint16

const (
	Channel_Msg_Which_value Channel_Msg_Which = 0
	Channel_Msg_Which_done  Channel_Msg_Which = 1
)

func (w Channel_Msg_Which) String() string {
	const s = "valuedone"
	switch w {
	case Channel_Msg_Which_value:
		return s[0:5]
	case Channel_Msg_Which_done:
		return s[5:9]

	}
	return "Channel_Msg_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Channel_Msg_TypeID is the unique identifier for the type Channel_Msg.
const Channel_Msg_TypeID = 0xd5b512f4bcd0aa2e

func NewChannel_Msg(s *capnp.Segment) (Channel_Msg, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Channel_Msg(st), err
}

func NewRootChannel_Msg(s *capnp.Segment) (Channel_Msg, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Channel_Msg(st), err
}

func ReadRootChannel_Msg(msg *capnp.Message) (Channel_Msg, error) {
	root, err := msg.Root()
	return Channel_Msg(root.Struct()), err
}

func (s Channel_Msg) String() string {
	str, _ := text.Marshal(0xd5b512f4bcd0aa2e, capnp.Struct(s))
	return str
}

func (s Channel_Msg) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Channel_Msg) DecodeFromPtr(p capnp.Ptr) Channel_Msg {
	return Channel_Msg(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Channel_Msg) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Channel_Msg) Which() Channel_Msg_Which {
	return Channel_Msg_Which(capnp.Struct(s).Uint16(0))
}
func (s Channel_Msg) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Channel_Msg) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Channel_Msg) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Channel_Msg) Value() (capnp.Ptr, error) {
	if capnp.Struct(s).Uint16(0) != 0 {
		panic("Which() != value")
	}
	return capnp.Struct(s).Ptr(0)
}

func (s Channel_Msg) HasValue() bool {
	if capnp.Struct(s).Uint16(0) != 0 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Channel_Msg) SetValue(v capnp.Ptr) error {
	capnp.Struct(s).SetUint16(0, 0)
	return capnp.Struct(s).SetPtr(0, v)
}
func (s Channel_Msg) SetDone() {
	capnp.Struct(s).SetUint16(0, 1)

}

// Channel_Msg_List is a list of Channel_Msg.
type Channel_Msg_List = capnp.StructList[Channel_Msg]

// NewChannel_Msg creates a new list of Channel_Msg.
func NewChannel_Msg_List(s *capnp.Segment, sz int32) (Channel_Msg_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[Channel_Msg](l), err
}

// Channel_Msg_Future is a wrapper for a Channel_Msg promised by a client call.
type Channel_Msg_Future struct{ *capnp.Future }

func (f Channel_Msg_Future) Struct() (Channel_Msg, error) {
	p, err := f.Future.Ptr()
	return Channel_Msg(p.Struct()), err
}
func (p Channel_Msg_Future) Value() *capnp.Future {
	return p.Future.Field(0, nil)
}

type Channel_StartupInfo capnp.Struct

// Channel_StartupInfo_TypeID is the unique identifier for the type Channel_StartupInfo.
const Channel_StartupInfo_TypeID = 0xe3d7a3237f175028

func NewChannel_StartupInfo(s *capnp.Segment) (Channel_StartupInfo, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 3})
	return Channel_StartupInfo(st), err
}

func NewRootChannel_StartupInfo(s *capnp.Segment) (Channel_StartupInfo, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 3})
	return Channel_StartupInfo(st), err
}

func ReadRootChannel_StartupInfo(msg *capnp.Message) (Channel_StartupInfo, error) {
	root, err := msg.Root()
	return Channel_StartupInfo(root.Struct()), err
}

func (s Channel_StartupInfo) String() string {
	str, _ := text.Marshal(0xe3d7a3237f175028, capnp.Struct(s))
	return str
}

func (s Channel_StartupInfo) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Channel_StartupInfo) DecodeFromPtr(p capnp.Ptr) Channel_StartupInfo {
	return Channel_StartupInfo(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Channel_StartupInfo) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Channel_StartupInfo) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Channel_StartupInfo) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Channel_StartupInfo) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Channel_StartupInfo) BufferSize() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s Channel_StartupInfo) SetBufferSize(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s Channel_StartupInfo) CloseSemantics() Channel_CloseSemantics {
	return Channel_CloseSemantics(capnp.Struct(s).Uint16(8))
}

func (s Channel_StartupInfo) SetCloseSemantics(v Channel_CloseSemantics) {
	capnp.Struct(s).SetUint16(8, uint16(v))
}

func (s Channel_StartupInfo) ChannelSR() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Channel_StartupInfo) HasChannelSR() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Channel_StartupInfo) ChannelSRBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Channel_StartupInfo) SetChannelSR(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Channel_StartupInfo) ReaderSRs() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.TextList(p.List()), err
}

func (s Channel_StartupInfo) HasReaderSRs() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Channel_StartupInfo) SetReaderSRs(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewReaderSRs sets the readerSRs field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Channel_StartupInfo) NewReaderSRs(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s Channel_StartupInfo) WriterSRs() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return capnp.TextList(p.List()), err
}

func (s Channel_StartupInfo) HasWriterSRs() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Channel_StartupInfo) SetWriterSRs(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewWriterSRs sets the writerSRs field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Channel_StartupInfo) NewWriterSRs(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}

// Channel_StartupInfo_List is a list of Channel_StartupInfo.
type Channel_StartupInfo_List = capnp.StructList[Channel_StartupInfo]

// NewChannel_StartupInfo creates a new list of Channel_StartupInfo.
func NewChannel_StartupInfo_List(s *capnp.Segment, sz int32) (Channel_StartupInfo_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 3}, sz)
	return capnp.StructList[Channel_StartupInfo](l), err
}

// Channel_StartupInfo_Future is a wrapper for a Channel_StartupInfo promised by a client call.
type Channel_StartupInfo_Future struct{ *capnp.Future }

func (f Channel_StartupInfo_Future) Struct() (Channel_StartupInfo, error) {
	p, err := f.Future.Ptr()
	return Channel_StartupInfo(p.Struct()), err
}

type Channel_Reader capnp.Client

// Channel_Reader_TypeID is the unique identifier for the type Channel_Reader.
const Channel_Reader_TypeID = 0x8bc69192f3bc97cc

func (c Channel_Reader) Read(ctx context.Context, params func(Channel_Reader_read_Params) error) (Channel_Msg_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x8bc69192f3bc97cc,
			MethodID:      0,
			InterfaceName: "fbp.capnp:Channel.Reader",
			MethodName:    "read",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Channel_Reader_read_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Channel_Msg_Future{Future: ans.Future()}, release

}

func (c Channel_Reader) Close(ctx context.Context, params func(Channel_Reader_close_Params) error) (Channel_Reader_close_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x8bc69192f3bc97cc,
			MethodID:      1,
			InterfaceName: "fbp.capnp:Channel.Reader",
			MethodName:    "close",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Channel_Reader_close_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Channel_Reader_close_Results_Future{Future: ans.Future()}, release

}

func (c Channel_Reader) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Channel_Reader) String() string {
	return "Channel_Reader(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Channel_Reader) AddRef() Channel_Reader {
	return Channel_Reader(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Channel_Reader) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Channel_Reader) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Channel_Reader) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Channel_Reader) DecodeFromPtr(p capnp.Ptr) Channel_Reader {
	return Channel_Reader(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Channel_Reader) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Channel_Reader) IsSame(other Channel_Reader) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Channel_Reader) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Channel_Reader) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Channel_Reader_Server is a Channel_Reader with a local implementation.
type Channel_Reader_Server interface {
	Read(context.Context, Channel_Reader_read) error

	Close(context.Context, Channel_Reader_close) error
}

// Channel_Reader_NewServer creates a new Server from an implementation of Channel_Reader_Server.
func Channel_Reader_NewServer(s Channel_Reader_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Channel_Reader_Methods(nil, s), s, c)
}

// Channel_Reader_ServerToClient creates a new Client from an implementation of Channel_Reader_Server.
// The caller is responsible for calling Release on the returned Client.
func Channel_Reader_ServerToClient(s Channel_Reader_Server) Channel_Reader {
	return Channel_Reader(capnp.NewClient(Channel_Reader_NewServer(s)))
}

// Channel_Reader_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Channel_Reader_Methods(methods []server.Method, s Channel_Reader_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 2)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x8bc69192f3bc97cc,
			MethodID:      0,
			InterfaceName: "fbp.capnp:Channel.Reader",
			MethodName:    "read",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Read(ctx, Channel_Reader_read{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x8bc69192f3bc97cc,
			MethodID:      1,
			InterfaceName: "fbp.capnp:Channel.Reader",
			MethodName:    "close",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Close(ctx, Channel_Reader_close{call})
		},
	})

	return methods
}

// Channel_Reader_read holds the state for a server call to Channel_Reader.read.
// See server.Call for documentation.
type Channel_Reader_read struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Channel_Reader_read) Args() Channel_Reader_read_Params {
	return Channel_Reader_read_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Channel_Reader_read) AllocResults() (Channel_Msg, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Channel_Msg(r), err
}

// Channel_Reader_close holds the state for a server call to Channel_Reader.close.
// See server.Call for documentation.
type Channel_Reader_close struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Channel_Reader_close) Args() Channel_Reader_close_Params {
	return Channel_Reader_close_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Channel_Reader_close) AllocResults() (Channel_Reader_close_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_Reader_close_Results(r), err
}

// Channel_Reader_List is a list of Channel_Reader.
type Channel_Reader_List = capnp.CapList[Channel_Reader]

// NewChannel_Reader creates a new list of Channel_Reader.
func NewChannel_Reader_List(s *capnp.Segment, sz int32) (Channel_Reader_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Channel_Reader](l), err
}

type Channel_Reader_read_Params capnp.Struct

// Channel_Reader_read_Params_TypeID is the unique identifier for the type Channel_Reader_read_Params.
const Channel_Reader_read_Params_TypeID = 0xc0335d99db8b2ba5

func NewChannel_Reader_read_Params(s *capnp.Segment) (Channel_Reader_read_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_Reader_read_Params(st), err
}

func NewRootChannel_Reader_read_Params(s *capnp.Segment) (Channel_Reader_read_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_Reader_read_Params(st), err
}

func ReadRootChannel_Reader_read_Params(msg *capnp.Message) (Channel_Reader_read_Params, error) {
	root, err := msg.Root()
	return Channel_Reader_read_Params(root.Struct()), err
}

func (s Channel_Reader_read_Params) String() string {
	str, _ := text.Marshal(0xc0335d99db8b2ba5, capnp.Struct(s))
	return str
}

func (s Channel_Reader_read_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Channel_Reader_read_Params) DecodeFromPtr(p capnp.Ptr) Channel_Reader_read_Params {
	return Channel_Reader_read_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Channel_Reader_read_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Channel_Reader_read_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Channel_Reader_read_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Channel_Reader_read_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Channel_Reader_read_Params_List is a list of Channel_Reader_read_Params.
type Channel_Reader_read_Params_List = capnp.StructList[Channel_Reader_read_Params]

// NewChannel_Reader_read_Params creates a new list of Channel_Reader_read_Params.
func NewChannel_Reader_read_Params_List(s *capnp.Segment, sz int32) (Channel_Reader_read_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Channel_Reader_read_Params](l), err
}

// Channel_Reader_read_Params_Future is a wrapper for a Channel_Reader_read_Params promised by a client call.
type Channel_Reader_read_Params_Future struct{ *capnp.Future }

func (f Channel_Reader_read_Params_Future) Struct() (Channel_Reader_read_Params, error) {
	p, err := f.Future.Ptr()
	return Channel_Reader_read_Params(p.Struct()), err
}

type Channel_Reader_close_Params capnp.Struct

// Channel_Reader_close_Params_TypeID is the unique identifier for the type Channel_Reader_close_Params.
const Channel_Reader_close_Params_TypeID = 0x9428ea64f18c41c8

func NewChannel_Reader_close_Params(s *capnp.Segment) (Channel_Reader_close_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_Reader_close_Params(st), err
}

func NewRootChannel_Reader_close_Params(s *capnp.Segment) (Channel_Reader_close_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_Reader_close_Params(st), err
}

func ReadRootChannel_Reader_close_Params(msg *capnp.Message) (Channel_Reader_close_Params, error) {
	root, err := msg.Root()
	return Channel_Reader_close_Params(root.Struct()), err
}

func (s Channel_Reader_close_Params) String() string {
	str, _ := text.Marshal(0x9428ea64f18c41c8, capnp.Struct(s))
	return str
}

func (s Channel_Reader_close_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Channel_Reader_close_Params) DecodeFromPtr(p capnp.Ptr) Channel_Reader_close_Params {
	return Channel_Reader_close_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Channel_Reader_close_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Channel_Reader_close_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Channel_Reader_close_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Channel_Reader_close_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Channel_Reader_close_Params_List is a list of Channel_Reader_close_Params.
type Channel_Reader_close_Params_List = capnp.StructList[Channel_Reader_close_Params]

// NewChannel_Reader_close_Params creates a new list of Channel_Reader_close_Params.
func NewChannel_Reader_close_Params_List(s *capnp.Segment, sz int32) (Channel_Reader_close_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Channel_Reader_close_Params](l), err
}

// Channel_Reader_close_Params_Future is a wrapper for a Channel_Reader_close_Params promised by a client call.
type Channel_Reader_close_Params_Future struct{ *capnp.Future }

func (f Channel_Reader_close_Params_Future) Struct() (Channel_Reader_close_Params, error) {
	p, err := f.Future.Ptr()
	return Channel_Reader_close_Params(p.Struct()), err
}

type Channel_Reader_close_Results capnp.Struct

// Channel_Reader_close_Results_TypeID is the unique identifier for the type Channel_Reader_close_Results.
const Channel_Reader_close_Results_TypeID = 0xb3fe08a1bf53821a

func NewChannel_Reader_close_Results(s *capnp.Segment) (Channel_Reader_close_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_Reader_close_Results(st), err
}

func NewRootChannel_Reader_close_Results(s *capnp.Segment) (Channel_Reader_close_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_Reader_close_Results(st), err
}

func ReadRootChannel_Reader_close_Results(msg *capnp.Message) (Channel_Reader_close_Results, error) {
	root, err := msg.Root()
	return Channel_Reader_close_Results(root.Struct()), err
}

func (s Channel_Reader_close_Results) String() string {
	str, _ := text.Marshal(0xb3fe08a1bf53821a, capnp.Struct(s))
	return str
}

func (s Channel_Reader_close_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Channel_Reader_close_Results) DecodeFromPtr(p capnp.Ptr) Channel_Reader_close_Results {
	return Channel_Reader_close_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Channel_Reader_close_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Channel_Reader_close_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Channel_Reader_close_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Channel_Reader_close_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Channel_Reader_close_Results_List is a list of Channel_Reader_close_Results.
type Channel_Reader_close_Results_List = capnp.StructList[Channel_Reader_close_Results]

// NewChannel_Reader_close_Results creates a new list of Channel_Reader_close_Results.
func NewChannel_Reader_close_Results_List(s *capnp.Segment, sz int32) (Channel_Reader_close_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Channel_Reader_close_Results](l), err
}

// Channel_Reader_close_Results_Future is a wrapper for a Channel_Reader_close_Results promised by a client call.
type Channel_Reader_close_Results_Future struct{ *capnp.Future }

func (f Channel_Reader_close_Results_Future) Struct() (Channel_Reader_close_Results, error) {
	p, err := f.Future.Ptr()
	return Channel_Reader_close_Results(p.Struct()), err
}

type Channel_Writer capnp.Client

// Channel_Writer_TypeID is the unique identifier for the type Channel_Writer.
const Channel_Writer_TypeID = 0xf7fec613b4a8c79f

func (c Channel_Writer) Write(ctx context.Context, params func(Channel_Msg) error) (Channel_Writer_write_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf7fec613b4a8c79f,
			MethodID:      0,
			InterfaceName: "fbp.capnp:Channel.Writer",
			MethodName:    "write",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 8, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Channel_Msg(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Channel_Writer_write_Results_Future{Future: ans.Future()}, release

}

func (c Channel_Writer) Close(ctx context.Context, params func(Channel_Writer_close_Params) error) (Channel_Writer_close_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf7fec613b4a8c79f,
			MethodID:      1,
			InterfaceName: "fbp.capnp:Channel.Writer",
			MethodName:    "close",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Channel_Writer_close_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Channel_Writer_close_Results_Future{Future: ans.Future()}, release

}

func (c Channel_Writer) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Channel_Writer) String() string {
	return "Channel_Writer(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Channel_Writer) AddRef() Channel_Writer {
	return Channel_Writer(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Channel_Writer) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Channel_Writer) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Channel_Writer) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Channel_Writer) DecodeFromPtr(p capnp.Ptr) Channel_Writer {
	return Channel_Writer(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Channel_Writer) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Channel_Writer) IsSame(other Channel_Writer) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Channel_Writer) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Channel_Writer) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Channel_Writer_Server is a Channel_Writer with a local implementation.
type Channel_Writer_Server interface {
	Write(context.Context, Channel_Writer_write) error

	Close(context.Context, Channel_Writer_close) error
}

// Channel_Writer_NewServer creates a new Server from an implementation of Channel_Writer_Server.
func Channel_Writer_NewServer(s Channel_Writer_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Channel_Writer_Methods(nil, s), s, c)
}

// Channel_Writer_ServerToClient creates a new Client from an implementation of Channel_Writer_Server.
// The caller is responsible for calling Release on the returned Client.
func Channel_Writer_ServerToClient(s Channel_Writer_Server) Channel_Writer {
	return Channel_Writer(capnp.NewClient(Channel_Writer_NewServer(s)))
}

// Channel_Writer_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Channel_Writer_Methods(methods []server.Method, s Channel_Writer_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 2)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf7fec613b4a8c79f,
			MethodID:      0,
			InterfaceName: "fbp.capnp:Channel.Writer",
			MethodName:    "write",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Write(ctx, Channel_Writer_write{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf7fec613b4a8c79f,
			MethodID:      1,
			InterfaceName: "fbp.capnp:Channel.Writer",
			MethodName:    "close",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Close(ctx, Channel_Writer_close{call})
		},
	})

	return methods
}

// Channel_Writer_write holds the state for a server call to Channel_Writer.write.
// See server.Call for documentation.
type Channel_Writer_write struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Channel_Writer_write) Args() Channel_Msg {
	return Channel_Msg(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Channel_Writer_write) AllocResults() (Channel_Writer_write_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_Writer_write_Results(r), err
}

// Channel_Writer_close holds the state for a server call to Channel_Writer.close.
// See server.Call for documentation.
type Channel_Writer_close struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Channel_Writer_close) Args() Channel_Writer_close_Params {
	return Channel_Writer_close_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Channel_Writer_close) AllocResults() (Channel_Writer_close_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_Writer_close_Results(r), err
}

// Channel_Writer_List is a list of Channel_Writer.
type Channel_Writer_List = capnp.CapList[Channel_Writer]

// NewChannel_Writer creates a new list of Channel_Writer.
func NewChannel_Writer_List(s *capnp.Segment, sz int32) (Channel_Writer_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Channel_Writer](l), err
}

type Channel_Writer_write_Results capnp.Struct

// Channel_Writer_write_Results_TypeID is the unique identifier for the type Channel_Writer_write_Results.
const Channel_Writer_write_Results_TypeID = 0xce9f24b8ec149524

func NewChannel_Writer_write_Results(s *capnp.Segment) (Channel_Writer_write_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_Writer_write_Results(st), err
}

func NewRootChannel_Writer_write_Results(s *capnp.Segment) (Channel_Writer_write_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_Writer_write_Results(st), err
}

func ReadRootChannel_Writer_write_Results(msg *capnp.Message) (Channel_Writer_write_Results, error) {
	root, err := msg.Root()
	return Channel_Writer_write_Results(root.Struct()), err
}

func (s Channel_Writer_write_Results) String() string {
	str, _ := text.Marshal(0xce9f24b8ec149524, capnp.Struct(s))
	return str
}

func (s Channel_Writer_write_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Channel_Writer_write_Results) DecodeFromPtr(p capnp.Ptr) Channel_Writer_write_Results {
	return Channel_Writer_write_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Channel_Writer_write_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Channel_Writer_write_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Channel_Writer_write_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Channel_Writer_write_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Channel_Writer_write_Results_List is a list of Channel_Writer_write_Results.
type Channel_Writer_write_Results_List = capnp.StructList[Channel_Writer_write_Results]

// NewChannel_Writer_write_Results creates a new list of Channel_Writer_write_Results.
func NewChannel_Writer_write_Results_List(s *capnp.Segment, sz int32) (Channel_Writer_write_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Channel_Writer_write_Results](l), err
}

// Channel_Writer_write_Results_Future is a wrapper for a Channel_Writer_write_Results promised by a client call.
type Channel_Writer_write_Results_Future struct{ *capnp.Future }

func (f Channel_Writer_write_Results_Future) Struct() (Channel_Writer_write_Results, error) {
	p, err := f.Future.Ptr()
	return Channel_Writer_write_Results(p.Struct()), err
}

type Channel_Writer_close_Params capnp.Struct

// Channel_Writer_close_Params_TypeID is the unique identifier for the type Channel_Writer_close_Params.
const Channel_Writer_close_Params_TypeID = 0xbadc988dda3d1e50

func NewChannel_Writer_close_Params(s *capnp.Segment) (Channel_Writer_close_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_Writer_close_Params(st), err
}

func NewRootChannel_Writer_close_Params(s *capnp.Segment) (Channel_Writer_close_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_Writer_close_Params(st), err
}

func ReadRootChannel_Writer_close_Params(msg *capnp.Message) (Channel_Writer_close_Params, error) {
	root, err := msg.Root()
	return Channel_Writer_close_Params(root.Struct()), err
}

func (s Channel_Writer_close_Params) String() string {
	str, _ := text.Marshal(0xbadc988dda3d1e50, capnp.Struct(s))
	return str
}

func (s Channel_Writer_close_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Channel_Writer_close_Params) DecodeFromPtr(p capnp.Ptr) Channel_Writer_close_Params {
	return Channel_Writer_close_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Channel_Writer_close_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Channel_Writer_close_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Channel_Writer_close_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Channel_Writer_close_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Channel_Writer_close_Params_List is a list of Channel_Writer_close_Params.
type Channel_Writer_close_Params_List = capnp.StructList[Channel_Writer_close_Params]

// NewChannel_Writer_close_Params creates a new list of Channel_Writer_close_Params.
func NewChannel_Writer_close_Params_List(s *capnp.Segment, sz int32) (Channel_Writer_close_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Channel_Writer_close_Params](l), err
}

// Channel_Writer_close_Params_Future is a wrapper for a Channel_Writer_close_Params promised by a client call.
type Channel_Writer_close_Params_Future struct{ *capnp.Future }

func (f Channel_Writer_close_Params_Future) Struct() (Channel_Writer_close_Params, error) {
	p, err := f.Future.Ptr()
	return Channel_Writer_close_Params(p.Struct()), err
}

type Channel_Writer_close_Results capnp.Struct

// Channel_Writer_close_Results_TypeID is the unique identifier for the type Channel_Writer_close_Results.
const Channel_Writer_close_Results_TypeID = 0xcb02dc91e18e58c9

func NewChannel_Writer_close_Results(s *capnp.Segment) (Channel_Writer_close_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_Writer_close_Results(st), err
}

func NewRootChannel_Writer_close_Results(s *capnp.Segment) (Channel_Writer_close_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_Writer_close_Results(st), err
}

func ReadRootChannel_Writer_close_Results(msg *capnp.Message) (Channel_Writer_close_Results, error) {
	root, err := msg.Root()
	return Channel_Writer_close_Results(root.Struct()), err
}

func (s Channel_Writer_close_Results) String() string {
	str, _ := text.Marshal(0xcb02dc91e18e58c9, capnp.Struct(s))
	return str
}

func (s Channel_Writer_close_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Channel_Writer_close_Results) DecodeFromPtr(p capnp.Ptr) Channel_Writer_close_Results {
	return Channel_Writer_close_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Channel_Writer_close_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Channel_Writer_close_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Channel_Writer_close_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Channel_Writer_close_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Channel_Writer_close_Results_List is a list of Channel_Writer_close_Results.
type Channel_Writer_close_Results_List = capnp.StructList[Channel_Writer_close_Results]

// NewChannel_Writer_close_Results creates a new list of Channel_Writer_close_Results.
func NewChannel_Writer_close_Results_List(s *capnp.Segment, sz int32) (Channel_Writer_close_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Channel_Writer_close_Results](l), err
}

// Channel_Writer_close_Results_Future is a wrapper for a Channel_Writer_close_Results promised by a client call.
type Channel_Writer_close_Results_Future struct{ *capnp.Future }

func (f Channel_Writer_close_Results_Future) Struct() (Channel_Writer_close_Results, error) {
	p, err := f.Future.Ptr()
	return Channel_Writer_close_Results(p.Struct()), err
}

type Channel_setBufferSize_Params capnp.Struct

// Channel_setBufferSize_Params_TypeID is the unique identifier for the type Channel_setBufferSize_Params.
const Channel_setBufferSize_Params_TypeID = 0x92101e3b7a761333

func NewChannel_setBufferSize_Params(s *capnp.Segment) (Channel_setBufferSize_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Channel_setBufferSize_Params(st), err
}

func NewRootChannel_setBufferSize_Params(s *capnp.Segment) (Channel_setBufferSize_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Channel_setBufferSize_Params(st), err
}

func ReadRootChannel_setBufferSize_Params(msg *capnp.Message) (Channel_setBufferSize_Params, error) {
	root, err := msg.Root()
	return Channel_setBufferSize_Params(root.Struct()), err
}

func (s Channel_setBufferSize_Params) String() string {
	str, _ := text.Marshal(0x92101e3b7a761333, capnp.Struct(s))
	return str
}

func (s Channel_setBufferSize_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Channel_setBufferSize_Params) DecodeFromPtr(p capnp.Ptr) Channel_setBufferSize_Params {
	return Channel_setBufferSize_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Channel_setBufferSize_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Channel_setBufferSize_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Channel_setBufferSize_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Channel_setBufferSize_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Channel_setBufferSize_Params) Size() uint64 {
	return capnp.Struct(s).Uint64(0) ^ 1
}

func (s Channel_setBufferSize_Params) SetSize(v uint64) {
	capnp.Struct(s).SetUint64(0, v^1)
}

// Channel_setBufferSize_Params_List is a list of Channel_setBufferSize_Params.
type Channel_setBufferSize_Params_List = capnp.StructList[Channel_setBufferSize_Params]

// NewChannel_setBufferSize_Params creates a new list of Channel_setBufferSize_Params.
func NewChannel_setBufferSize_Params_List(s *capnp.Segment, sz int32) (Channel_setBufferSize_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[Channel_setBufferSize_Params](l), err
}

// Channel_setBufferSize_Params_Future is a wrapper for a Channel_setBufferSize_Params promised by a client call.
type Channel_setBufferSize_Params_Future struct{ *capnp.Future }

func (f Channel_setBufferSize_Params_Future) Struct() (Channel_setBufferSize_Params, error) {
	p, err := f.Future.Ptr()
	return Channel_setBufferSize_Params(p.Struct()), err
}

type Channel_setBufferSize_Results capnp.Struct

// Channel_setBufferSize_Results_TypeID is the unique identifier for the type Channel_setBufferSize_Results.
const Channel_setBufferSize_Results_TypeID = 0xfe6a08d5e0712c23

func NewChannel_setBufferSize_Results(s *capnp.Segment) (Channel_setBufferSize_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_setBufferSize_Results(st), err
}

func NewRootChannel_setBufferSize_Results(s *capnp.Segment) (Channel_setBufferSize_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_setBufferSize_Results(st), err
}

func ReadRootChannel_setBufferSize_Results(msg *capnp.Message) (Channel_setBufferSize_Results, error) {
	root, err := msg.Root()
	return Channel_setBufferSize_Results(root.Struct()), err
}

func (s Channel_setBufferSize_Results) String() string {
	str, _ := text.Marshal(0xfe6a08d5e0712c23, capnp.Struct(s))
	return str
}

func (s Channel_setBufferSize_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Channel_setBufferSize_Results) DecodeFromPtr(p capnp.Ptr) Channel_setBufferSize_Results {
	return Channel_setBufferSize_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Channel_setBufferSize_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Channel_setBufferSize_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Channel_setBufferSize_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Channel_setBufferSize_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Channel_setBufferSize_Results_List is a list of Channel_setBufferSize_Results.
type Channel_setBufferSize_Results_List = capnp.StructList[Channel_setBufferSize_Results]

// NewChannel_setBufferSize_Results creates a new list of Channel_setBufferSize_Results.
func NewChannel_setBufferSize_Results_List(s *capnp.Segment, sz int32) (Channel_setBufferSize_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Channel_setBufferSize_Results](l), err
}

// Channel_setBufferSize_Results_Future is a wrapper for a Channel_setBufferSize_Results promised by a client call.
type Channel_setBufferSize_Results_Future struct{ *capnp.Future }

func (f Channel_setBufferSize_Results_Future) Struct() (Channel_setBufferSize_Results, error) {
	p, err := f.Future.Ptr()
	return Channel_setBufferSize_Results(p.Struct()), err
}

type Channel_reader_Params capnp.Struct

// Channel_reader_Params_TypeID is the unique identifier for the type Channel_reader_Params.
const Channel_reader_Params_TypeID = 0xe607c9dd64da04c4

func NewChannel_reader_Params(s *capnp.Segment) (Channel_reader_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_reader_Params(st), err
}

func NewRootChannel_reader_Params(s *capnp.Segment) (Channel_reader_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_reader_Params(st), err
}

func ReadRootChannel_reader_Params(msg *capnp.Message) (Channel_reader_Params, error) {
	root, err := msg.Root()
	return Channel_reader_Params(root.Struct()), err
}

func (s Channel_reader_Params) String() string {
	str, _ := text.Marshal(0xe607c9dd64da04c4, capnp.Struct(s))
	return str
}

func (s Channel_reader_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Channel_reader_Params) DecodeFromPtr(p capnp.Ptr) Channel_reader_Params {
	return Channel_reader_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Channel_reader_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Channel_reader_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Channel_reader_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Channel_reader_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Channel_reader_Params_List is a list of Channel_reader_Params.
type Channel_reader_Params_List = capnp.StructList[Channel_reader_Params]

// NewChannel_reader_Params creates a new list of Channel_reader_Params.
func NewChannel_reader_Params_List(s *capnp.Segment, sz int32) (Channel_reader_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Channel_reader_Params](l), err
}

// Channel_reader_Params_Future is a wrapper for a Channel_reader_Params promised by a client call.
type Channel_reader_Params_Future struct{ *capnp.Future }

func (f Channel_reader_Params_Future) Struct() (Channel_reader_Params, error) {
	p, err := f.Future.Ptr()
	return Channel_reader_Params(p.Struct()), err
}

type Channel_reader_Results capnp.Struct

// Channel_reader_Results_TypeID is the unique identifier for the type Channel_reader_Results.
const Channel_reader_Results_TypeID = 0xb135ffc9ccc9eca6

func NewChannel_reader_Results(s *capnp.Segment) (Channel_reader_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Channel_reader_Results(st), err
}

func NewRootChannel_reader_Results(s *capnp.Segment) (Channel_reader_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Channel_reader_Results(st), err
}

func ReadRootChannel_reader_Results(msg *capnp.Message) (Channel_reader_Results, error) {
	root, err := msg.Root()
	return Channel_reader_Results(root.Struct()), err
}

func (s Channel_reader_Results) String() string {
	str, _ := text.Marshal(0xb135ffc9ccc9eca6, capnp.Struct(s))
	return str
}

func (s Channel_reader_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Channel_reader_Results) DecodeFromPtr(p capnp.Ptr) Channel_reader_Results {
	return Channel_reader_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Channel_reader_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Channel_reader_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Channel_reader_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Channel_reader_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Channel_reader_Results) R() Channel_Reader {
	p, _ := capnp.Struct(s).Ptr(0)
	return Channel_Reader(p.Interface().Client())
}

func (s Channel_reader_Results) HasR() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Channel_reader_Results) SetR(v Channel_Reader) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// Channel_reader_Results_List is a list of Channel_reader_Results.
type Channel_reader_Results_List = capnp.StructList[Channel_reader_Results]

// NewChannel_reader_Results creates a new list of Channel_reader_Results.
func NewChannel_reader_Results_List(s *capnp.Segment, sz int32) (Channel_reader_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Channel_reader_Results](l), err
}

// Channel_reader_Results_Future is a wrapper for a Channel_reader_Results promised by a client call.
type Channel_reader_Results_Future struct{ *capnp.Future }

func (f Channel_reader_Results_Future) Struct() (Channel_reader_Results, error) {
	p, err := f.Future.Ptr()
	return Channel_reader_Results(p.Struct()), err
}
func (p Channel_reader_Results_Future) R() Channel_Reader {
	return Channel_Reader(p.Future.Field(0, nil).Client())
}

type Channel_writer_Params capnp.Struct

// Channel_writer_Params_TypeID is the unique identifier for the type Channel_writer_Params.
const Channel_writer_Params_TypeID = 0xbe611d34e368e109

func NewChannel_writer_Params(s *capnp.Segment) (Channel_writer_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_writer_Params(st), err
}

func NewRootChannel_writer_Params(s *capnp.Segment) (Channel_writer_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_writer_Params(st), err
}

func ReadRootChannel_writer_Params(msg *capnp.Message) (Channel_writer_Params, error) {
	root, err := msg.Root()
	return Channel_writer_Params(root.Struct()), err
}

func (s Channel_writer_Params) String() string {
	str, _ := text.Marshal(0xbe611d34e368e109, capnp.Struct(s))
	return str
}

func (s Channel_writer_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Channel_writer_Params) DecodeFromPtr(p capnp.Ptr) Channel_writer_Params {
	return Channel_writer_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Channel_writer_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Channel_writer_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Channel_writer_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Channel_writer_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Channel_writer_Params_List is a list of Channel_writer_Params.
type Channel_writer_Params_List = capnp.StructList[Channel_writer_Params]

// NewChannel_writer_Params creates a new list of Channel_writer_Params.
func NewChannel_writer_Params_List(s *capnp.Segment, sz int32) (Channel_writer_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Channel_writer_Params](l), err
}

// Channel_writer_Params_Future is a wrapper for a Channel_writer_Params promised by a client call.
type Channel_writer_Params_Future struct{ *capnp.Future }

func (f Channel_writer_Params_Future) Struct() (Channel_writer_Params, error) {
	p, err := f.Future.Ptr()
	return Channel_writer_Params(p.Struct()), err
}

type Channel_writer_Results capnp.Struct

// Channel_writer_Results_TypeID is the unique identifier for the type Channel_writer_Results.
const Channel_writer_Results_TypeID = 0xb47b53679e985c7e

func NewChannel_writer_Results(s *capnp.Segment) (Channel_writer_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Channel_writer_Results(st), err
}

func NewRootChannel_writer_Results(s *capnp.Segment) (Channel_writer_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Channel_writer_Results(st), err
}

func ReadRootChannel_writer_Results(msg *capnp.Message) (Channel_writer_Results, error) {
	root, err := msg.Root()
	return Channel_writer_Results(root.Struct()), err
}

func (s Channel_writer_Results) String() string {
	str, _ := text.Marshal(0xb47b53679e985c7e, capnp.Struct(s))
	return str
}

func (s Channel_writer_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Channel_writer_Results) DecodeFromPtr(p capnp.Ptr) Channel_writer_Results {
	return Channel_writer_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Channel_writer_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Channel_writer_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Channel_writer_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Channel_writer_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Channel_writer_Results) W() Channel_Writer {
	p, _ := capnp.Struct(s).Ptr(0)
	return Channel_Writer(p.Interface().Client())
}

func (s Channel_writer_Results) HasW() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Channel_writer_Results) SetW(v Channel_Writer) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// Channel_writer_Results_List is a list of Channel_writer_Results.
type Channel_writer_Results_List = capnp.StructList[Channel_writer_Results]

// NewChannel_writer_Results creates a new list of Channel_writer_Results.
func NewChannel_writer_Results_List(s *capnp.Segment, sz int32) (Channel_writer_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Channel_writer_Results](l), err
}

// Channel_writer_Results_Future is a wrapper for a Channel_writer_Results promised by a client call.
type Channel_writer_Results_Future struct{ *capnp.Future }

func (f Channel_writer_Results_Future) Struct() (Channel_writer_Results, error) {
	p, err := f.Future.Ptr()
	return Channel_writer_Results(p.Struct()), err
}
func (p Channel_writer_Results_Future) W() Channel_Writer {
	return Channel_Writer(p.Future.Field(0, nil).Client())
}

type Channel_endpoints_Params capnp.Struct

// Channel_endpoints_Params_TypeID is the unique identifier for the type Channel_endpoints_Params.
const Channel_endpoints_Params_TypeID = 0xd23f817e914373d8

func NewChannel_endpoints_Params(s *capnp.Segment) (Channel_endpoints_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_endpoints_Params(st), err
}

func NewRootChannel_endpoints_Params(s *capnp.Segment) (Channel_endpoints_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_endpoints_Params(st), err
}

func ReadRootChannel_endpoints_Params(msg *capnp.Message) (Channel_endpoints_Params, error) {
	root, err := msg.Root()
	return Channel_endpoints_Params(root.Struct()), err
}

func (s Channel_endpoints_Params) String() string {
	str, _ := text.Marshal(0xd23f817e914373d8, capnp.Struct(s))
	return str
}

func (s Channel_endpoints_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Channel_endpoints_Params) DecodeFromPtr(p capnp.Ptr) Channel_endpoints_Params {
	return Channel_endpoints_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Channel_endpoints_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Channel_endpoints_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Channel_endpoints_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Channel_endpoints_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Channel_endpoints_Params_List is a list of Channel_endpoints_Params.
type Channel_endpoints_Params_List = capnp.StructList[Channel_endpoints_Params]

// NewChannel_endpoints_Params creates a new list of Channel_endpoints_Params.
func NewChannel_endpoints_Params_List(s *capnp.Segment, sz int32) (Channel_endpoints_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Channel_endpoints_Params](l), err
}

// Channel_endpoints_Params_Future is a wrapper for a Channel_endpoints_Params promised by a client call.
type Channel_endpoints_Params_Future struct{ *capnp.Future }

func (f Channel_endpoints_Params_Future) Struct() (Channel_endpoints_Params, error) {
	p, err := f.Future.Ptr()
	return Channel_endpoints_Params(p.Struct()), err
}

type Channel_endpoints_Results capnp.Struct

// Channel_endpoints_Results_TypeID is the unique identifier for the type Channel_endpoints_Results.
const Channel_endpoints_Results_TypeID = 0xf37401d21f8d97bb

func NewChannel_endpoints_Results(s *capnp.Segment) (Channel_endpoints_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Channel_endpoints_Results(st), err
}

func NewRootChannel_endpoints_Results(s *capnp.Segment) (Channel_endpoints_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Channel_endpoints_Results(st), err
}

func ReadRootChannel_endpoints_Results(msg *capnp.Message) (Channel_endpoints_Results, error) {
	root, err := msg.Root()
	return Channel_endpoints_Results(root.Struct()), err
}

func (s Channel_endpoints_Results) String() string {
	str, _ := text.Marshal(0xf37401d21f8d97bb, capnp.Struct(s))
	return str
}

func (s Channel_endpoints_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Channel_endpoints_Results) DecodeFromPtr(p capnp.Ptr) Channel_endpoints_Results {
	return Channel_endpoints_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Channel_endpoints_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Channel_endpoints_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Channel_endpoints_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Channel_endpoints_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Channel_endpoints_Results) R() Channel_Reader {
	p, _ := capnp.Struct(s).Ptr(0)
	return Channel_Reader(p.Interface().Client())
}

func (s Channel_endpoints_Results) HasR() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Channel_endpoints_Results) SetR(v Channel_Reader) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

func (s Channel_endpoints_Results) W() Channel_Writer {
	p, _ := capnp.Struct(s).Ptr(1)
	return Channel_Writer(p.Interface().Client())
}

func (s Channel_endpoints_Results) HasW() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Channel_endpoints_Results) SetW(v Channel_Writer) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(1, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(1, in.ToPtr())
}

// Channel_endpoints_Results_List is a list of Channel_endpoints_Results.
type Channel_endpoints_Results_List = capnp.StructList[Channel_endpoints_Results]

// NewChannel_endpoints_Results creates a new list of Channel_endpoints_Results.
func NewChannel_endpoints_Results_List(s *capnp.Segment, sz int32) (Channel_endpoints_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Channel_endpoints_Results](l), err
}

// Channel_endpoints_Results_Future is a wrapper for a Channel_endpoints_Results promised by a client call.
type Channel_endpoints_Results_Future struct{ *capnp.Future }

func (f Channel_endpoints_Results_Future) Struct() (Channel_endpoints_Results, error) {
	p, err := f.Future.Ptr()
	return Channel_endpoints_Results(p.Struct()), err
}
func (p Channel_endpoints_Results_Future) R() Channel_Reader {
	return Channel_Reader(p.Future.Field(0, nil).Client())
}

func (p Channel_endpoints_Results_Future) W() Channel_Writer {
	return Channel_Writer(p.Future.Field(1, nil).Client())
}

type Channel_setAutoCloseSemantics_Params capnp.Struct

// Channel_setAutoCloseSemantics_Params_TypeID is the unique identifier for the type Channel_setAutoCloseSemantics_Params.
const Channel_setAutoCloseSemantics_Params_TypeID = 0xb49836b545583add

func NewChannel_setAutoCloseSemantics_Params(s *capnp.Segment) (Channel_setAutoCloseSemantics_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Channel_setAutoCloseSemantics_Params(st), err
}

func NewRootChannel_setAutoCloseSemantics_Params(s *capnp.Segment) (Channel_setAutoCloseSemantics_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Channel_setAutoCloseSemantics_Params(st), err
}

func ReadRootChannel_setAutoCloseSemantics_Params(msg *capnp.Message) (Channel_setAutoCloseSemantics_Params, error) {
	root, err := msg.Root()
	return Channel_setAutoCloseSemantics_Params(root.Struct()), err
}

func (s Channel_setAutoCloseSemantics_Params) String() string {
	str, _ := text.Marshal(0xb49836b545583add, capnp.Struct(s))
	return str
}

func (s Channel_setAutoCloseSemantics_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Channel_setAutoCloseSemantics_Params) DecodeFromPtr(p capnp.Ptr) Channel_setAutoCloseSemantics_Params {
	return Channel_setAutoCloseSemantics_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Channel_setAutoCloseSemantics_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Channel_setAutoCloseSemantics_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Channel_setAutoCloseSemantics_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Channel_setAutoCloseSemantics_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Channel_setAutoCloseSemantics_Params) Cs() Channel_CloseSemantics {
	return Channel_CloseSemantics(capnp.Struct(s).Uint16(0))
}

func (s Channel_setAutoCloseSemantics_Params) SetCs(v Channel_CloseSemantics) {
	capnp.Struct(s).SetUint16(0, uint16(v))
}

// Channel_setAutoCloseSemantics_Params_List is a list of Channel_setAutoCloseSemantics_Params.
type Channel_setAutoCloseSemantics_Params_List = capnp.StructList[Channel_setAutoCloseSemantics_Params]

// NewChannel_setAutoCloseSemantics_Params creates a new list of Channel_setAutoCloseSemantics_Params.
func NewChannel_setAutoCloseSemantics_Params_List(s *capnp.Segment, sz int32) (Channel_setAutoCloseSemantics_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[Channel_setAutoCloseSemantics_Params](l), err
}

// Channel_setAutoCloseSemantics_Params_Future is a wrapper for a Channel_setAutoCloseSemantics_Params promised by a client call.
type Channel_setAutoCloseSemantics_Params_Future struct{ *capnp.Future }

func (f Channel_setAutoCloseSemantics_Params_Future) Struct() (Channel_setAutoCloseSemantics_Params, error) {
	p, err := f.Future.Ptr()
	return Channel_setAutoCloseSemantics_Params(p.Struct()), err
}

type Channel_setAutoCloseSemantics_Results capnp.Struct

// Channel_setAutoCloseSemantics_Results_TypeID is the unique identifier for the type Channel_setAutoCloseSemantics_Results.
const Channel_setAutoCloseSemantics_Results_TypeID = 0xc0fc6e5a3fcb3206

func NewChannel_setAutoCloseSemantics_Results(s *capnp.Segment) (Channel_setAutoCloseSemantics_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_setAutoCloseSemantics_Results(st), err
}

func NewRootChannel_setAutoCloseSemantics_Results(s *capnp.Segment) (Channel_setAutoCloseSemantics_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_setAutoCloseSemantics_Results(st), err
}

func ReadRootChannel_setAutoCloseSemantics_Results(msg *capnp.Message) (Channel_setAutoCloseSemantics_Results, error) {
	root, err := msg.Root()
	return Channel_setAutoCloseSemantics_Results(root.Struct()), err
}

func (s Channel_setAutoCloseSemantics_Results) String() string {
	str, _ := text.Marshal(0xc0fc6e5a3fcb3206, capnp.Struct(s))
	return str
}

func (s Channel_setAutoCloseSemantics_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Channel_setAutoCloseSemantics_Results) DecodeFromPtr(p capnp.Ptr) Channel_setAutoCloseSemantics_Results {
	return Channel_setAutoCloseSemantics_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Channel_setAutoCloseSemantics_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Channel_setAutoCloseSemantics_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Channel_setAutoCloseSemantics_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Channel_setAutoCloseSemantics_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Channel_setAutoCloseSemantics_Results_List is a list of Channel_setAutoCloseSemantics_Results.
type Channel_setAutoCloseSemantics_Results_List = capnp.StructList[Channel_setAutoCloseSemantics_Results]

// NewChannel_setAutoCloseSemantics_Results creates a new list of Channel_setAutoCloseSemantics_Results.
func NewChannel_setAutoCloseSemantics_Results_List(s *capnp.Segment, sz int32) (Channel_setAutoCloseSemantics_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Channel_setAutoCloseSemantics_Results](l), err
}

// Channel_setAutoCloseSemantics_Results_Future is a wrapper for a Channel_setAutoCloseSemantics_Results promised by a client call.
type Channel_setAutoCloseSemantics_Results_Future struct{ *capnp.Future }

func (f Channel_setAutoCloseSemantics_Results_Future) Struct() (Channel_setAutoCloseSemantics_Results, error) {
	p, err := f.Future.Ptr()
	return Channel_setAutoCloseSemantics_Results(p.Struct()), err
}

type Channel_close_Params capnp.Struct

// Channel_close_Params_TypeID is the unique identifier for the type Channel_close_Params.
const Channel_close_Params_TypeID = 0x95d8ad01c1113d9c

func NewChannel_close_Params(s *capnp.Segment) (Channel_close_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Channel_close_Params(st), err
}

func NewRootChannel_close_Params(s *capnp.Segment) (Channel_close_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Channel_close_Params(st), err
}

func ReadRootChannel_close_Params(msg *capnp.Message) (Channel_close_Params, error) {
	root, err := msg.Root()
	return Channel_close_Params(root.Struct()), err
}

func (s Channel_close_Params) String() string {
	str, _ := text.Marshal(0x95d8ad01c1113d9c, capnp.Struct(s))
	return str
}

func (s Channel_close_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Channel_close_Params) DecodeFromPtr(p capnp.Ptr) Channel_close_Params {
	return Channel_close_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Channel_close_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Channel_close_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Channel_close_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Channel_close_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Channel_close_Params) WaitForEmptyBuffer() bool {
	return !capnp.Struct(s).Bit(0)
}

func (s Channel_close_Params) SetWaitForEmptyBuffer(v bool) {
	capnp.Struct(s).SetBit(0, !v)
}

// Channel_close_Params_List is a list of Channel_close_Params.
type Channel_close_Params_List = capnp.StructList[Channel_close_Params]

// NewChannel_close_Params creates a new list of Channel_close_Params.
func NewChannel_close_Params_List(s *capnp.Segment, sz int32) (Channel_close_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[Channel_close_Params](l), err
}

// Channel_close_Params_Future is a wrapper for a Channel_close_Params promised by a client call.
type Channel_close_Params_Future struct{ *capnp.Future }

func (f Channel_close_Params_Future) Struct() (Channel_close_Params, error) {
	p, err := f.Future.Ptr()
	return Channel_close_Params(p.Struct()), err
}

type Channel_close_Results capnp.Struct

// Channel_close_Results_TypeID is the unique identifier for the type Channel_close_Results.
const Channel_close_Results_TypeID = 0xcc079ad60f1363b7

func NewChannel_close_Results(s *capnp.Segment) (Channel_close_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_close_Results(st), err
}

func NewRootChannel_close_Results(s *capnp.Segment) (Channel_close_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Channel_close_Results(st), err
}

func ReadRootChannel_close_Results(msg *capnp.Message) (Channel_close_Results, error) {
	root, err := msg.Root()
	return Channel_close_Results(root.Struct()), err
}

func (s Channel_close_Results) String() string {
	str, _ := text.Marshal(0xcc079ad60f1363b7, capnp.Struct(s))
	return str
}

func (s Channel_close_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Channel_close_Results) DecodeFromPtr(p capnp.Ptr) Channel_close_Results {
	return Channel_close_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Channel_close_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Channel_close_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Channel_close_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Channel_close_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Channel_close_Results_List is a list of Channel_close_Results.
type Channel_close_Results_List = capnp.StructList[Channel_close_Results]

// NewChannel_close_Results creates a new list of Channel_close_Results.
func NewChannel_close_Results_List(s *capnp.Segment, sz int32) (Channel_close_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Channel_close_Results](l), err
}

// Channel_close_Results_Future is a wrapper for a Channel_close_Results promised by a client call.
type Channel_close_Results_Future struct{ *capnp.Future }

func (f Channel_close_Results_Future) Struct() (Channel_close_Results, error) {
	p, err := f.Future.Ptr()
	return Channel_close_Results(p.Struct()), err
}

const schema_bf602c4868dbb22f = "x\xda\xbcW}l\x1b\xe5\x1d\xfe=w\xe7\x9e\x1d\x9f" +
	"\xe3\xbc>K\x8c\x88`\xb5\x04\xad\x94\x12hB\x99\x94" +
	"\x15\x99k\xd6\xa9\x15\x8b\xe4\x8b\xb5B\xaaV\x9a\xe3\\" +
	"Z\xb3\xd4\xf6|\x17\xaaf+\x88j(\x9b\x18\x93R" +
	"\xad\xa2TU\xa1\xda\x07\xdd\xb4\x8a5k\xb5iC#" +
	"\xd1R\xb64\x15k\x912PI\xa5D\x0c\xf6!\xfe" +
	"Ia\x9b\x98Pnz\xef|\xf69q\xdaf\xd2\xf8" +
	"\xcf\xba\xf7\xf7\xfd{\x9e\xe7}\xfd\xc0\xfb\xd2#\xd2\xa6" +
	"\xc8H\x13\x09\xfax`\x8d}\xe9\x85\xd7>:2\xfa" +
	"\xc6s\xc4b\xa2\xfd\xb7\xb3\xd7\xef\xbf\xf7\xf7}'\x88" +
	"\xa8\x09\xea=\xc1\x8b\xea\xe6\xa0\xacn\x0e&\xd4\xde\xe0" +
	"\x88\xfaIP&\xb2;\xd4'\x87\xbfxg\xd3\x11\xd2" +
	"c\x00\x91$7\xa1c>\xd8\x09\x82\xfa\xf7`\x92`" +
	"\xffQ\xfb\xdeB\xff?\xd6\xff\x80\xd8\xed\xdey(\xd4" +
	"\x0e\x92\xec\x13\x0f\xb3\x09\x9cy\xe7\xa8\xcfU]\x08\xfe" +
	"\x87\xa0\xfe\xd3\xf1\xac\xa4g\x0d\xa2}\xff\xd8\xbb\xfb\xb6" +
	"o\xfc\xda\xebn--\xa1#\xea\xdd\xa1\xc7\x88:\x8c" +
	"\xd0\x08\xd4\xaf\x86?\xaf\x1a\xe1\xa8\xfd\xc1\x8b\x93s\xa3" +
	"\xe9\x93'\x89E`\xffi\xf7\xf1\xe2dK\xc3\xab\x14" +
	"\x10d\"\xb57|X\xdd\x13v\x7f\x1d \xd8]c" +
	"s\x7f\xbd8\xf2\xf6ib1\xa1\xb6\xd3\x8e\xf3\xe1\x06" +
	"\xa8\x17\x1c\xdb\x89\xf0\x17\xc8\x17\x8a5\xa0Z\x89\x1b\xf7" +
	"B\xf8\x09u*|\x1b\x91z\xc5\x89\xfb\x93\x0f\xa7." +
	"M\xd9\x9b\xcf\x12\x8b\x81(\x00\xde\xb0\xa64\xf0\x81\xec" +
	"Px[\xcd\x87\xd3\xaf\x9f\x0a.\xfe\xd27\x90CJ" +
	"'\x1f\xc8S\xbb\x8f\x9d\xdc\x9b\xfe\xe69\xbf\xab\xe1\xba" +
	"\xeew\\\xafu>\xbe\xed\xfcC\xc7\xce\xf9\x87}J" +
	"\x19\xe6\x06g\x1c\x83\xd4\x9d\x0f_}\xfe\xd8\xeco|" +
	"\xb1\xe7\x15g\xd8\xa1\xf9}\xef=\xd8\x92\xf9\x9d\x1b\xdb" +
	"9\x99R\x04~\xf2\xe3{\x9f{\xf7\xc5=\x1d\xe3>" +
	"\x9f3\xca\x06~\xb2\xa6}:\xb9+\xff\xe9\xb8\xcf\xe7" +
	"\xa8r\x98\x9fL=\xfe\xfd\xf9\xd1Ya\xda\xe7\xf3\x8c" +
	"\xdb\xc3\xaf\xb2j\xf4\xcf\xc7\xe5K>\x9f\x9c\x9b\xa7\xf5" +
	"h\xfc\xc3_\xb7\xbe\xf4\xa6\xcf\xa7\xdb\xf5y\xc7\xec\x1a" +
	"}\xea\x99\xe4[>\x9f\xcdJ3?i\xfb\xd9\xe5\xd7" +
	">\x8e\x9d\x9fq\x1a\xaeni\x1bd\x81\xa3@\x19S" +
	"\xefV\xf8\x12\xd6*|\xf4\xebS\xb7=}\xd7\x0f\xdf" +
	"~\x8f[\xfbv\x1a\x109\xb2\x0e)\xd7\xd5\xefr\xe3" +
	"\x8eg\x95\x04\x08\xf6\xa4t\xb5\xff\xda\x94\xfc\x81/\xeb" +
	"\xb5\x88S\xe9o_x>\xf1\x16\xac\x8f\xca{\x10\xf8" +
	"\xd1Dd\x1d\x1f\xf3T\x84'z\xe9\x0f\xa7\xcf\xa9o" +
	",\xfe\xbb\x0eK\xba\x1b/\xaa\xbd\x8d\xb2\xda\xdb\x98P" +
	"\x0f5\x8e\xa8-Q\xce\x92\xbb6~cn&\xf8\xc4" +
	"\xa2/W \xba\x15\xf4/{\xa0\xaf\xd8\x96\xcd\x14\xf3" +
	"B\xb1\xb3k_&\x9f7\x06\xdbz\x8cL\xbfQ\"" +
	"J\x01\xba\x04\xc1~sta\xf1\xe0+\xfd\xd7I\x97" +
	"\x04hq@!b\xd8es{nK\"\xb7\xd6\x83" +
	"b\x80\xa8\xb2Mx\xa3c\x9b6\x10i\x1b\xa1m\x01" +
	"\xeb\x96Q%$< 2\xad\x9dH\xdb\x02\xed+`" +
	"{\xe4h\xc9\xc8\xf43$x\xb2jo\x1cnu?" +
	">\x82Dv\xb0`\x1a\xab\xf1H\x01\x95\xbe\xc5j\xdf" +
	"\xa6am\x1d\x1a\x180J\xe9\xdc\xb0\xd1\x9aLeJ" +
	"\x99\xfd\xa6.\x89\x12\x91\x04\x80E68]B\x8f\x0b" +
	"\x88\x9a\xb9a\x03!\x12\x10\xe21\xeb\x85s\xc7\xd8\xe6" +
	"T\xd7\x9aJ8\xd1\xea\x8d\xdb5\xa8\x93\xee8\x91\xde" +
	"$B\xbfC\x80} \x93\xb3\xbe\\(m\xc3\xfe\xa2" +
	"u\x90W)\x1a%\x80\x84\x008\x94\xbc\xa8\xf0\xa2b" +
	"P\x8f\xc3\xaf1k\x87\xabXfk\xd7U\xa1\xcaZ" +
	"\xfa|\xa2\xdb\xd2\xe9\xc3\xd6\xed\x9dv\x17\xaf-m\xec" +
	"\xa7d&o\xe5\xb2\xa6\xdcm\xee\xb5\xd3V\xa6d\x0d" +
	"\x15w\x90\x9c\x1f($\xdd6\x93\x8f\x95r\x96Q\xd2" +
	"?\xe7\x80\xc0\x13ex\xb8cgKD\xda/\xa0\x8d" +
	"\x83]\xe1 \xf0\xc0\x0fO\xae\xd8\x85N\"m\x1c\xda" +
	"e\xb0y\x19BE0\xe0\xa9\x12\x9b\xe1\x16\x97\xa1\xcd" +
	"\x81-\xc8\x10+\xb4\x85\xc7\x17\xf6~\x0f\x91\xf6\x17h" +
	"\x1fC\x0d@\x86T\x11,xR\xc2>\x19#\xd2>" +
	"E\x97\x02\xa8-\x90\x11\xa8\\\x03\xf0\xa4Ceh'" +
	"\xe2\x16]w\x00\xea}\x90m\x0f\x1a\x94p\xc0\xb1\x1a" +
	"\xb0%K\xce\x80V\xe5r\xc0\x19\xe6j\\l#\xdf" +
	"_,\xe4\xf2\x16\xc1\\\x95\x9fiX\xda\x90U\xe8B" +
	"y\xd3\x99\x84\xb3\xe8\xff/\x01\xf5 `\xcfl?\xd1" +
	";}\xe5\xd51\"\xb2\x8d\xe9\x87f_\xbe\xfa\xca\x04" +
	"\x11i\x12\x18b\xd8\xe9\x07\xf5\x8eT\xdb\xa3;\x1d=" +
	"\x0a\xba\xf4 b\xf7\xac#\xd2[E\xe8\x0f\x08`@" +
	"\xdcIw_;\x91\xbe^\x84\xfe\xa0\x00\xf9\xeb\xc6A" +
	"($@!$\x9e\xcc\x0c\x0e\x19\x88\x91\x80\x18\xd5%" +
	"\xbf\x87t\x17\xe7\xae\xf8\x05!\x101\xb6\x8e\x08`\xa1" +
	"f\"y\xa0\xaf(\xe6\x0b\x15\x7f\x8a\xf2\xdat\x09\xf0" +
	"]\xfdh\x16\x1f\xdd\xe9/tW\xb9\xa6/\xf9\x0a\xd5" +
	"\xb6\x12\xe9[D\xe8\xdb\x05\xd8\x19\xcb*\xe5\xfa\x86," +
	"\x12\x0d\x13\x8d\x84\x94\x084U#\x12\xf8\xc7\xa7\xb3\x85" +
	"\xbce\xe4\xad\x1b5\xe1B\xad\xb5\xc70\x87\x06-\x93" +
	"\xc8S\x13\"\x16\x89\x95\xc5k\xbd\x00\x94\xc0\xaa\xa4\xe7" +
	"\x0b\xa9\xbb'\xb0\xfaYj\x84\xad'\xe9&\xabg\xe8" +
	"\xc2\xf8\xe6\xe5\x1c\x00\xab\xca\xce\xad\x95#\xd5\xc8\xb6\x83" +
	"\xe0\x9a\x05.\xd5S\x9e\xb2\xb9\x9aR\xcc\x9a\x88V\xe5" +
	"q\xe5\x9c\xd1\xfa#p\xd5n\x05m\x97\x97M\xc0\xad" +
	"\x85<\x83e\xa3\xe4{kMe\xa25aB7k" +
	"\xd1\x9b\xeb\xf2\xb05\xe5-\xdb\x90\xbc\xf4\xee\xb9i " +
	"\xa7\x8d\x1b\xae\xda\x93\x1f\xd3\xe9U\xf4\xb5Q\xb9\x93\x12" +
	"\x83m\xdd\xe6\xde2\x89\x15\xdbv\xc9\xd1^eq\x04" +
	"\x8bv\x99\xc6\x1b\xaa4\xf6\xa8\xeb\x7f\x7f\x11q\x06D" +
	"\xfb\x0by\x83\xd6\xd4\xbbS\xdd+*Q\xdc\x91\x1f(" +
	"\xf0\x8c\xf1\x0a\x0a\x0eq6~K\x84\xfe\x1d\xceF\xc9" +
	"\xcd\xf7\xec0\x91\xfem\x11\xfa\x8f\x04@\x88;\xb4?" +
	"\xd5C\xa4\xbf,B\xff\xb9\x00&\"\x0e\x91\x88\xfd\x94" +
	"\x7f<-B\x9f\x14\xc0$!\x0e\x89\x88M\xf0\x8f\xe3" +
	"\"\xf4Y\x01v_\xf9\x05A\xa2\xf7> \xd8\xd9%" +
	"\xd7\xe8\xadc/\xeb6\x94&\xf4xZf\xbb,O" +
	"\xf7\x10*j\xc1\x8f\x1a\x09\xb6\x8b\xb7\xbaGu\xb6_" +
	"\x96\x8b\x15\xd1Y]*G\x88<h\x99~Y\x8b\x95" +
	"7W#k\xb1\xb2\xac\xed^\x95\xca\xfc/\x0a ," +
	"E\xe9\xad=X\xb9m\xcd\x83\xd5{\x16\xc1\xfb\x7f\xc0" +
	"6\xb5\xd7>X\xbd?5\xf0\xfeu\xd4>X\x13\xce" +
	"\xd0?\xbb\x17\xab\xb4\xd2\x8b\xd5\xa3\xf1\x7f\x03\x00\x00\xff" +
	"\xff\x1eT\x87G"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_bf602c4868dbb22f,
		Nodes: []uint64{
			0x8bc69192f3bc97cc,
			0x92101e3b7a761333,
			0x9428ea64f18c41c8,
			0x95d8ad01c1113d9c,
			0x9c62c32b2ff2b1e8,
			0x9e9e5391e0c499e6,
			0xa8d787cae7e0b243,
			0xaf0a1dc4709a5ccf,
			0xb135ffc9ccc9eca6,
			0xb3fe08a1bf53821a,
			0xb47b53679e985c7e,
			0xb49836b545583add,
			0xbadc988dda3d1e50,
			0xbe611d34e368e109,
			0xc0335d99db8b2ba5,
			0xc0fc6e5a3fcb3206,
			0xcb02dc91e18e58c9,
			0xcc079ad60f1363b7,
			0xce9f24b8ec149524,
			0xd23f817e914373d8,
			0xd5b512f4bcd0aa2e,
			0xe3d7a3237f175028,
			0xe607c9dd64da04c4,
			0xf37401d21f8d97bb,
			0xf7fec613b4a8c79f,
			0xfe6a08d5e0712c23,
		},
		Compressed: true,
	})
}
