@namespace Mas.Infrastructure.BlazorComponents

@using System.Text;
@using Allegiance.Blazor.Highcharts.Services
@using Allegiance.Blazor.Highcharts.Charts
@using Allegiance.Blazor.Highcharts.Constants;
@using Allegiance.Blazor.Highcharts.Options;
@using Newtonsoft.Json.Linq
@using Newtonsoft.Json
@using System.Text.Json

@inject IJSRuntime jsRuntime
@inject IChartService chartService

@implements IDisposable

<div id=@chartId></div>

@code {
    [Parameter]
    public Dictionary<String, IEnumerable<float>>? Data { get; set; }

    [Parameter]
    public IEnumerable<DateTime>? Dates { get; set; }

    [Parameter]
    public String Type { get; set; } = ChartType.Line;

    [Parameter]
    public bool DataChanged { get; set; } = false;

    [Parameter]
    public EventCallback ChartRerendered { get; set; }

    [Parameter]
    public string? Title { get; set; }

    [Parameter]
    public string? XAxisTitle { get; set; }

    public class AxisConfig
    {
        public string? Title { get; set; }
        public string? Id { get; set; }
        public bool Opposite { get; set; } = false;
    }
    [Parameter]
    public List<AxisConfig> YAxisConfigs { get; set; } = new();

    [Parameter]
    public bool AllCurvesVisible { get; set; } = false;

    private Dictionary<string, int> _axisIdToCurveNo = new();

    public class CurveConfig
    {
        public bool IsVisible { get; set; } = false;
        public string? DisplayAxisId { get; set; }
    }
    [Parameter]
    public Dictionary<string, CurveConfig> CurveName2Config { get; set; } = new();

    private string chartId = Guid.NewGuid().ToString();
    private bool chartRenderedOnce = false;

    private ChartObject? lineGraph;

    protected override void OnInitialized()
    {
        lineGraph = new ChartObject()
        {
            Chart = new Chart(ChartType.Line, false),
            Legend = new Legend(true, Layout.Vertical, Align.Right, VerticalAlign.Middle),
            //PlotOptions = new PlotOptions(new PlotOptionsSeries(new Label(false), 2010)),
            Responsive = new Responsive(new Rule(new Condition(500),
            new ChartOptions(new Legend(true, Layout.Vertical, Align.Right, VerticalAlign.Middle)))),
            Series = new List<SeriesElement>(),
            //Subtitle = new Title("MONICA Result Data"),
            //Title = new Title(Title),
            //YAxis = new YAxis(new Title(YAxisTitle)),
            XAxis = new XAxis
            {
                Accessibility = new Accessibility("Date / days"),
                Type = "datetime",
                Labels = new Labels()// { Rotation = 0 },
            }
        };
    }

    protected override async Task OnParametersSetAsync()
    {
        if (Data == null) return;

        if (DataChanged && lineGraph != null)
        {
            lineGraph.Series = new List<SeriesElement>();

            var noDates = Dates == null || Dates.Count() == 0;
            var milliDates = noDates ? null : Dates?.Select(d => new DateTimeOffset(d).ToUnixTimeMilliseconds());
            lineGraph.Title = new(Title);
            lineGraph.XAxis.Type = noDates ? "linear" : "datetime";
            lineGraph.XAxis.Title = new(XAxisTitle);

            foreach (var (p, i) in Data.Select((p, i) => (p, i)))
            {
                var curveName = p.Key;
                var ds = noDates
                    ? p.Value.Select(v => (object)v).ToList()
                    : p.Value.Zip(milliDates!).Select(z => new List<object>() { z.Second, z.First }).ToList<object>();

                bool isVisible = AllCurvesVisible || CurveName2Config.GetValueOrDefault(curveName,
                    new CurveConfig { IsVisible = i == 0 && !CurveName2Config.Any() }).IsVisible;
                lineGraph.Series.Add(new SeriesElement()
                {
                    Name = p.Key,
                    Data = ds,
                    Visible = isVisible
                });
            }

            if (chartRenderedOnce)
            {
                await chartService.RenderChart(chartId, UpdateJsonGraphOptions(lineGraph.Generate()));
                if (ChartRerendered.HasDelegate) _ = ChartRerendered.InvokeAsync(false);
            }
        }
    }

    private string UpdateJsonGraphOptions(string options)
    {
        var joptions = JObject.Parse(options);
        if(joptions["tooltip"] is JObject tt) tt["xDateFormat"] = "%Y-%m-%d";

        if (YAxisConfigs.Any()) joptions["yAxis"] = new JArray();
        foreach (var (i, conf) in YAxisConfigs.Select((conf, i) => (i, conf)))
        {
            var yAxis = new JObject {
                { "title", new JObject { { "text", conf.Title } , { "style", new JObject() } } },
                { "opposite", conf.Opposite },
                { "labels", new JObject { { "rotation", 0 } } }
            };
            _axisIdToCurveNo[conf.Id ?? i.ToString()] = i;
            joptions.Value<JArray>("yAxis").Add(yAxis);
        }

        joptions.Value<JObject>("xAxis")?.Value<JObject>("labels")?.Add("rotation", 0);

        var curves = joptions["series"];
        if (curves != null)
        {
            foreach (var c in curves)
            {
                if (c is JObject curve)
                {
                    var name = curve.Value<string>("name");
                    var index = name.LastIndexOf("_@");
                    if (index > 0)
                    {
                        var curveNo = int.Parse(name.Substring(index + 2));
                        curve["yAxis"] = curveNo;
                        curve["name"] = name.Substring(0, index);
                    }
                    else if (CurveName2Config.ContainsKey(name))
                    {
                        var conf = CurveName2Config[name];
                        if (conf.DisplayAxisId != null) curve["yAxis"] = _axisIdToCurveNo.GetValueOrDefault(conf.DisplayAxisId, 0);
                    }
                }
            }
        }
        return joptions.ToString();
    }

    protected override void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);
        if (firstRender && lineGraph != null)
        {
            chartService.RenderChart(chartId, UpdateJsonGraphOptions(lineGraph.Generate()));
            jsRuntime.InvokeVoidAsync("prettyPrint");
            chartRenderedOnce = true;
        }
    }

    public void Dispose()
    {
        lineGraph?.DisposeChart(jsRuntime, chartId);
    }
}
