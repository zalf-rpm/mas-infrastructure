@using Blazor.Diagrams.Components.Renderers;
@using BlazorDrawFBP.Models;
@using BlazorDrawFBP.Renderers
@using System.Text

<div>
    <MudCard>
        <MudCardHeader>
            @*<CardHeaderAvatar>
                <MudAvatar Color="Color.Secondary"
                           >@InterpreterShortcut(Node.PathToInterpreter)</MudAvatar>
            </CardHeaderAvatar>*@
            <CardHeaderContent>
                <MudTextField Class="d-inline-flex pr-4"
                              @bind-Value="Node.ProcessName"
                              Label="Process name"
                              Variant="Variant.Outlined"/>
                <MudToggleIconButton Style="position: absolute; right: -5px; top: -5px;"
                                     @bind-Toggled="@ParallelOn"
                                     Icon="@Icons.Material.Filled.PlaylistAddCircle" Color="@Color.Primary" Title="Parallel On"
                                     ToggledIcon="@Icons.Material.Filled.LooksOne" ToggledColor="@Color.Secondary" ToggledTitle="Parallel Off"/>
                @if (ParallelOn)
                {
                    <MudNumericField Class="d-inline-flex pr-6" Style="width: 80px;" 
                                     @bind-Value="Node.InParallelCount"
                                     Label="#Procs"
                                     Variant="Variant.Outlined"
                                     Min="1" Max="10000"/>
                }
                @if (!Node.Editable && Node.ShortDescription.Length > 0)
                {
                    <MudField Label="Description"
                              Variant="Variant.Outlined">
                        <MudText Typo="Typo.body2">@Node.ShortDescription</MudText>
                    </MudField>
                }
            </CardHeaderContent>
            @*<CardHeaderActions>
                <MudIconButton Icon="@Icons.Material.Filled.Edit" 
                               Color="Color.Default"
                               OnClick="() => Node.Editable = !Node.Editable"/>
            </CardHeaderActions>*@
        </MudCardHeader>
        @* <MudCardMedia Image="images/pilars.jpg" Height="250" /> *@
        @if (Node.Editable || Node.CmdParamString.Length > 0)
        {
            <MudCardContent>
                @if (!Node.Editable && Node.CmdParamString.Length > 0)
                {
                    <MudField Label="CMD arguments"
                              Variant="Variant.Outlined">
                        <MudText Typo="Typo.body2">@Node.ShortDescription</MudText>
                    </MudField>
                }
                @if (Node.Editable)
                {
                    <MudTextField T="string"
                                  @bind-Value="Node.CmdParamString"
                                  Lines="2"
                                  Label="CMD arguments (Key=Value)"
                                  Variant="Variant.Outlined"/>
                    <MudField Label="Component data"
                              Variant="Variant.Outlined">
                        <MudTextField @bind-Value="Node.ComponentId"
                                      Label="Component ID"
                                      Variant="Variant.Outlined"/>
                        <MudTextField @bind-Value="Node.ShortDescription"
                                      Label="Description"
                                      Variant="Variant.Outlined"/>
                        <MudTextField T="string"
                                      @bind-Value="Node.PathToInterpreter"
                                      Label="Path to interpreter"
                                      Variant="Variant.Outlined"/>
                        <MudTextField T="string"
                                      @bind-Value="Node.PathToFile"
                                      Label="Path to .py file"
                                      Variant="Variant.Outlined"/>
                    </MudField>
                }
            </MudCardContent>
        }
    </MudCard>

    @foreach (var port in Node.Ports)
    {
        if (port is not CapnpFbpPortModel capnpPort) continue;

        capnpPort.Alignment = capnpPort.ThePortType switch
        {
            CapnpFbpPortModel.PortType.In => capnpPort.OrderNo switch
            {
                10 => PortAlignment.TopLeft,
                > 10 => PortAlignment.Top,
                _ => PortAlignment.Left
            },
            CapnpFbpPortModel.PortType.Out => capnpPort.OrderNo switch
            {
                10 => PortAlignment.BottomRight,
                > 10 => PortAlignment.Bottom,
                _ => PortAlignment.Right
            },
            _ => throw new ArgumentOutOfRangeException()
        };

        var portCount = Node.Ports.Where(p =>
        {
            if (p is CapnpFbpPortModel cp) return cp.ThePortType == capnpPort.ThePortType;
            return false;
        }).Count();
        var offsets = capnpPort.Alignment switch
        {
            PortAlignment.Left => _leftRightOffsetsMap[Math.Min(portCount, 11)],
            PortAlignment.Right => _leftRightOffsetsMap[Math.Min(portCount, 11)],
            PortAlignment.Top => _topBottomOffsets,
            PortAlignment.Bottom => _topBottomOffsets,
            _ => new List<int>()
        };
        if (capnpPort.Alignment is PortAlignment.Right or PortAlignment.Bottom)
        {
            offsets = new List<int>(offsets);
            offsets.Reverse();
        }

        ;

        var style = capnpPort.Alignment switch
        {
            PortAlignment.Left => $"top: {50 + offsets[capnpPort.OrderNo]}%;",
            PortAlignment.Top => $"left: {50 + offsets[capnpPort.OrderNo - 11]}%;",
            PortAlignment.Right => $"top: {50 + offsets[capnpPort.OrderNo]}%;",
            PortAlignment.Bottom => $"left: {50 + offsets[capnpPort.OrderNo - 11]}%;",
            _ => ""
        };
        // Console.WriteLine(capnpPort.ThePortType.ToString() + " OrderNo: " + capnpPort.OrderNo + " -> " + style);
        <CapnpFbpPortRenderer @key="port" Port="capnpPort" Style="@style">
            @($"{capnpPort.ThePortType.ToString().ToUpper()[0]} {capnpPort.Name}")
        </CapnpFbpPortRenderer>
    }
</div>

@code {
    [Parameter] public CapnpFbpComponentModel Node { get; set; } = null!;

    private bool _parallelOn = false;
    private bool ParallelOn
    {
        get => Node.InParallelCount > 1; //_parallelOn;
        set =>
            //_parallelOn = value;
            Node.InParallelCount = value ? 2 : 1;
    }

    private readonly Dictionary<int, List<int>> _leftRightOffsetsMap = new()
    {
        { 1, new List<int> { 0 } },
        { 2, new List<int> { 10, -10 } },
        { 3, new List<int> { 20, 0, -20 } },
        { 4, new List<int> { 30, 10, -10, -30 } },
        { 5, new List<int> { 30, 15, 0, -15, -30 } },
        { 6, new List<int> { 35, 21, 7, -7, -21, -35 } },
        { 7, new List<int> { 45, 30, 15, 0, -15, -30, -45 } },
        { 8, new List<int> { 42, 30, 18, 6, -6, -18, -30, -42 } },
        { 9, new List<int> { 36, 27, 18, 9, 0, -9, -18, -27, -36 } },
        { 10, new List<int> { -45, -35, -25, -15, -5, 5, 15, 25, 35, 45 } },
        { 11, new List<int> { 50, 40, 30, 20, 10, 0, -10, -20, -30, -40, -50 } },
    };

    private readonly List<int> _topBottomOffsets = new() { -40, -30, -20, -10, 0, 10, 20, 30, 40 };

    private readonly Dictionary<PortAlignment, int> _portCounts = new();

    static string InterpreterShortcut(string path)
    {
        if (path == null) return "Exe";
        if (path.Contains("python")) return "Py";
        if (path.Contains("python3")) return "Py3";
        if (path.Contains("node")) return "Js";
        return "";
    }


}